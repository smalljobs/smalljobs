(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('react-dom')) :
    typeof define === 'function' && define.amd ? define(['react', 'react-dom'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chat = factory(global.React, global.ReactDOM));
})(this, (function (require$$0$1, reactDom) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
    var require$$0__namespace = /*#__PURE__*/_interopNamespace(require$$0$1);

    var RcCtx = require$$0$1.createContext(null);
    var Rc = function (_a) {
        var children = _a.children, instance = _a.instance;
        return (require$$0__default["default"].createElement(RcCtx.Provider, { value: {
                rc: instance
            } }, children));
    };
    var useRc = function () { return require$$0$1.useContext(RcCtx); };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var shim = {exports: {}};

    var useSyncExternalStoreShim_production_min = {};

    /**
     * @license React
     * use-sync-external-store-shim.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e$4=require$$0__default["default"];function h$6(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k$3="function"===typeof Object.is?Object.is:h$6,l$6=e$4.useState,m$5=e$4.useEffect,n$5=e$4.useLayoutEffect,p$6=e$4.useDebugValue;function q$4(a,b){var d=b(),f=l$6({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n$5(function(){c.value=d;c.getSnapshot=b;r$5(c)&&g({inst:c});},[a,d,b]);m$5(function(){r$5(c)&&g({inst:c});return a(function(){r$5(c)&&g({inst:c});})},[a]);p$6(d);return d}
    function r$5(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k$3(a,d)}catch(f){return !0}}function t$7(a,b){return b()}var u$6="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t$7:q$4;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e$4.useSyncExternalStore?e$4.useSyncExternalStore:u$6;

    {
      shim.exports = useSyncExternalStoreShim_production_min;
    }

    var withSelector = {exports: {}};

    var withSelector_production_min = {};

    /**
     * @license React
     * use-sync-external-store-shim/with-selector.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var h$5=require$$0__default["default"],n$4=shim.exports;function p$5(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q$3="function"===typeof Object.is?Object.is:p$5,r$4=n$4.useSyncExternalStore,t$6=h$5.useRef,u$5=h$5.useEffect,v$5=h$5.useMemo,w$4=h$5.useDebugValue;
    withSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t$6(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v$5(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q$3(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r$4(a,c[0],c[1]);
    u$5(function(){f.hasValue=!0;f.value=d;},[d]);w$4(d);return d};

    {
      withSelector.exports = withSelector_production_min;
    }

    // Default to a dummy "batch" implementation that just runs the callback
    function defaultNoopBatch(callback) {
      callback();
    }

    let batch = defaultNoopBatch; // Allow injecting another batching function later

    const setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings

    const getBatch = () => batch;

    const ReactReduxContext = /*#__PURE__*/require$$0$1.createContext(null);

    /**
     * A hook to access the value of the `ReactReduxContext`. This is a low-level
     * hook that you should usually not need to call directly.
     *
     * @returns {any} the value of the `ReactReduxContext`
     *
     * @example
     *
     * import React from 'react'
     * import { useReduxContext } from 'react-redux'
     *
     * export const CounterComponent = () => {
     *   const { store } = useReduxContext()
     *   return <div>{store.getState()}</div>
     * }
     */
    function useReduxContext() {
      const contextValue = require$$0$1.useContext(ReactReduxContext);

      return contextValue;
    }

    const notInitialized = () => {
      throw new Error('uSES not initialized!');
    };

    let useSyncExternalStoreWithSelector = notInitialized;
    const initializeUseSelector = fn => {
      useSyncExternalStoreWithSelector = fn;
    };

    const refEquality = (a, b) => a === b;
    /**
     * Hook factory, which creates a `useSelector` hook bound to a given context.
     *
     * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
     * @returns {Function} A `useSelector` hook bound to the specified context.
     */


    function createSelectorHook(context = ReactReduxContext) {
      const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : () => require$$0$1.useContext(context);
      return function useSelector(selector, equalityFn = refEquality) {

        const {
          store,
          subscription,
          getServerState
        } = useReduxContext$1();
        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, selector, equalityFn);
        require$$0$1.useDebugValue(selectedState);
        return selectedState;
      };
    }
    /**
     * A hook to access the redux store's state. This hook takes a selector function
     * as an argument. The selector is called with the store state.
     *
     * This hook takes an optional equality comparison function as the second parameter
     * that allows you to customize the way the selected state is compared to determine
     * whether the component needs to be re-rendered.
     *
     * @param {Function} selector the selector function
     * @param {Function=} equalityFn the function that will be used to determine equality
     *
     * @returns {any} the selected state
     *
     * @example
     *
     * import React from 'react'
     * import { useSelector } from 'react-redux'
     *
     * export const CounterComponent = () => {
     *   const counter = useSelector(state => state.counter)
     *   return <div>{counter}</div>
     * }
     */

    const useSelector = /*#__PURE__*/createSelectorHook();

    var reactIs$1 = {exports: {}};

    var reactIs_production_min$1 = {};

    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$2="function"===typeof Symbol&&Symbol.for,c$2=b$2?Symbol.for("react.element"):60103,d$4=b$2?Symbol.for("react.portal"):60106,e$3=b$2?Symbol.for("react.fragment"):60107,f$7=b$2?Symbol.for("react.strict_mode"):60108,g$3=b$2?Symbol.for("react.profiler"):60114,h$4=b$2?Symbol.for("react.provider"):60109,k$2=b$2?Symbol.for("react.context"):60110,l$5=b$2?Symbol.for("react.async_mode"):60111,m$4=b$2?Symbol.for("react.concurrent_mode"):60111,n$3=b$2?Symbol.for("react.forward_ref"):60112,p$4=b$2?Symbol.for("react.suspense"):60113,q$2=b$2?
    Symbol.for("react.suspense_list"):60120,r$3=b$2?Symbol.for("react.memo"):60115,t$5=b$2?Symbol.for("react.lazy"):60116,v$4=b$2?Symbol.for("react.block"):60121,w$3=b$2?Symbol.for("react.fundamental"):60117,x$2=b$2?Symbol.for("react.responder"):60118,y$2=b$2?Symbol.for("react.scope"):60119;
    function z$1(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c$2:switch(a=a.type,a){case l$5:case m$4:case e$3:case g$3:case f$7:case p$4:return a;default:switch(a=a&&a.$$typeof,a){case k$2:case n$3:case t$5:case r$3:case h$4:return a;default:return u}}case d$4:return u}}}function A$3(a){return z$1(a)===m$4}reactIs_production_min$1.AsyncMode=l$5;reactIs_production_min$1.ConcurrentMode=m$4;reactIs_production_min$1.ContextConsumer=k$2;reactIs_production_min$1.ContextProvider=h$4;reactIs_production_min$1.Element=c$2;reactIs_production_min$1.ForwardRef=n$3;reactIs_production_min$1.Fragment=e$3;reactIs_production_min$1.Lazy=t$5;reactIs_production_min$1.Memo=r$3;reactIs_production_min$1.Portal=d$4;
    reactIs_production_min$1.Profiler=g$3;reactIs_production_min$1.StrictMode=f$7;reactIs_production_min$1.Suspense=p$4;reactIs_production_min$1.isAsyncMode=function(a){return A$3(a)||z$1(a)===l$5};reactIs_production_min$1.isConcurrentMode=A$3;reactIs_production_min$1.isContextConsumer=function(a){return z$1(a)===k$2};reactIs_production_min$1.isContextProvider=function(a){return z$1(a)===h$4};reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c$2};reactIs_production_min$1.isForwardRef=function(a){return z$1(a)===n$3};reactIs_production_min$1.isFragment=function(a){return z$1(a)===e$3};reactIs_production_min$1.isLazy=function(a){return z$1(a)===t$5};
    reactIs_production_min$1.isMemo=function(a){return z$1(a)===r$3};reactIs_production_min$1.isPortal=function(a){return z$1(a)===d$4};reactIs_production_min$1.isProfiler=function(a){return z$1(a)===g$3};reactIs_production_min$1.isStrictMode=function(a){return z$1(a)===f$7};reactIs_production_min$1.isSuspense=function(a){return z$1(a)===p$4};
    reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e$3||a===m$4||a===g$3||a===f$7||a===p$4||a===q$2||"object"===typeof a&&null!==a&&(a.$$typeof===t$5||a.$$typeof===r$3||a.$$typeof===h$4||a.$$typeof===k$2||a.$$typeof===n$3||a.$$typeof===w$3||a.$$typeof===x$2||a.$$typeof===y$2||a.$$typeof===v$4)};reactIs_production_min$1.typeOf=z$1;

    {
      reactIs$1.exports = reactIs_production_min$1;
    }

    var reactIs = reactIs$1.exports;
    var FORWARD_REF_STATICS = {
      '$$typeof': true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      '$$typeof': true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

    var reactIs_production_min = {};

    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1=Symbol.for("react.element"),c$1=Symbol.for("react.portal"),d$3=Symbol.for("react.fragment"),e$2=Symbol.for("react.strict_mode"),f$6=Symbol.for("react.profiler"),g$2=Symbol.for("react.provider"),h$3=Symbol.for("react.context"),k$1=Symbol.for("react.server_context"),l$4=Symbol.for("react.forward_ref"),m$3=Symbol.for("react.suspense"),n$2=Symbol.for("react.suspense_list"),p$3=Symbol.for("react.memo"),q$1=Symbol.for("react.lazy"),t$4=Symbol.for("react.offscreen"),u$4;u$4=Symbol.for("react.module.reference");
    function v$3(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b$1:switch(a=a.type,a){case d$3:case f$6:case e$2:case m$3:case n$2:return a;default:switch(a=a&&a.$$typeof,a){case k$1:case h$3:case l$4:case q$1:case p$3:case g$2:return a;default:return r}}case c$1:return r}}}reactIs_production_min.ContextConsumer=h$3;reactIs_production_min.ContextProvider=g$2;reactIs_production_min.Element=b$1;reactIs_production_min.ForwardRef=l$4;reactIs_production_min.Fragment=d$3;reactIs_production_min.Lazy=q$1;reactIs_production_min.Memo=p$3;reactIs_production_min.Portal=c$1;reactIs_production_min.Profiler=f$6;reactIs_production_min.StrictMode=e$2;reactIs_production_min.Suspense=m$3;
    reactIs_production_min.SuspenseList=n$2;reactIs_production_min.isAsyncMode=function(){return !1};reactIs_production_min.isConcurrentMode=function(){return !1};reactIs_production_min.isContextConsumer=function(a){return v$3(a)===h$3};reactIs_production_min.isContextProvider=function(a){return v$3(a)===g$2};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b$1};reactIs_production_min.isForwardRef=function(a){return v$3(a)===l$4};reactIs_production_min.isFragment=function(a){return v$3(a)===d$3};reactIs_production_min.isLazy=function(a){return v$3(a)===q$1};reactIs_production_min.isMemo=function(a){return v$3(a)===p$3};
    reactIs_production_min.isPortal=function(a){return v$3(a)===c$1};reactIs_production_min.isProfiler=function(a){return v$3(a)===f$6};reactIs_production_min.isStrictMode=function(a){return v$3(a)===e$2};reactIs_production_min.isSuspense=function(a){return v$3(a)===m$3};reactIs_production_min.isSuspenseList=function(a){return v$3(a)===n$2};
    reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d$3||a===f$6||a===e$2||a===m$3||a===n$2||a===t$4||"object"===typeof a&&null!==a&&(a.$$typeof===q$1||a.$$typeof===p$3||a.$$typeof===g$2||a.$$typeof===h$3||a.$$typeof===l$4||a.$$typeof===u$4||void 0!==a.getModuleId)?!0:!1};reactIs_production_min.typeOf=v$3;

    // well as nesting subscriptions of descendant components, so that we can ensure the
    // ancestor components re-render before descendants

    function createListenerCollection() {
      const batch = getBatch();
      let first = null;
      let last = null;
      return {
        clear() {
          first = null;
          last = null;
        },

        notify() {
          batch(() => {
            let listener = first;

            while (listener) {
              listener.callback();
              listener = listener.next;
            }
          });
        },

        get() {
          let listeners = [];
          let listener = first;

          while (listener) {
            listeners.push(listener);
            listener = listener.next;
          }

          return listeners;
        },

        subscribe(callback) {
          let isSubscribed = true;
          let listener = last = {
            callback,
            next: null,
            prev: last
          };

          if (listener.prev) {
            listener.prev.next = listener;
          } else {
            first = listener;
          }

          return function unsubscribe() {
            if (!isSubscribed || first === null) return;
            isSubscribed = false;

            if (listener.next) {
              listener.next.prev = listener.prev;
            } else {
              last = listener.prev;
            }

            if (listener.prev) {
              listener.prev.next = listener.next;
            } else {
              first = listener.next;
            }
          };
        }

      };
    }

    const nullListeners = {
      notify() {},

      get: () => []
    };
    function createSubscription(store, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;

      function addNestedSub(listener) {
        trySubscribe();
        return listeners.subscribe(listener);
      }

      function notifyNestedSubs() {
        listeners.notify();
      }

      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }

      function isSubscribed() {
        return Boolean(unsubscribe);
      }

      function trySubscribe() {
        if (!unsubscribe) {
          unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }

      function tryUnsubscribe() {
        if (unsubscribe) {
          unsubscribe();
          unsubscribe = undefined;
          listeners.clear();
          listeners = nullListeners;
        }
      }

      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe,
        tryUnsubscribe,
        getListeners: () => listeners
      };
      return subscription;
    }

    // To get around it, we can conditionally useEffect on the server (no-op) and
    // useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
    // subscription callback always has the selector from the latest render commit
    // available, otherwise a store update may happen between render and the effect,
    // which may cause missed updates; we also must ensure the store subscription
    // is created synchronously, otherwise a store update may occur before the
    // subscription is created and an inconsistent state may be observed
    // Matches logic in React's `shared/ExecutionEnvironment` file

    const canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
    const useIsomorphicLayoutEffect = canUseDOM ? require$$0$1.useLayoutEffect : require$$0$1.useEffect;

    function Provider({
      store,
      context,
      children,
      serverState
    }) {
      const contextValue = require$$0$1.useMemo(() => {
        const subscription = createSubscription(store);
        return {
          store,
          subscription,
          getServerState: serverState ? () => serverState : undefined
        };
      }, [store, serverState]);
      const previousState = require$$0$1.useMemo(() => store.getState(), [store]);
      useIsomorphicLayoutEffect(() => {
        const {
          subscription
        } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();

        if (previousState !== store.getState()) {
          subscription.notifyNestedSubs();
        }

        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = undefined;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype

      return /*#__PURE__*/require$$0__default["default"].createElement(Context.Provider, {
        value: contextValue
      }, children);
    }

    /**
     * Hook factory, which creates a `useStore` hook bound to a given context.
     *
     * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
     * @returns {Function} A `useStore` hook bound to the specified context.
     */

    function createStoreHook(context = ReactReduxContext) {
      const useReduxContext$1 = // @ts-ignore
      context === ReactReduxContext ? useReduxContext : () => require$$0$1.useContext(context);
      return function useStore() {
        const {
          store
        } = useReduxContext$1(); // @ts-ignore

        return store;
      };
    }
    /**
     * A hook to access the redux store.
     *
     * @returns {any} the redux store
     *
     * @example
     *
     * import React from 'react'
     * import { useStore } from 'react-redux'
     *
     * export const ExampleComponent = () => {
     *   const store = useStore()
     *   return <div>{store.getState()}</div>
     * }
     */

    const useStore = /*#__PURE__*/createStoreHook();

    /**
     * Hook factory, which creates a `useDispatch` hook bound to a given context.
     *
     * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
     * @returns {Function} A `useDispatch` hook bound to the specified context.
     */

    function createDispatchHook(context = ReactReduxContext) {
      const useStore$1 = // @ts-ignore
      context === ReactReduxContext ? useStore : createStoreHook(context);
      return function useDispatch() {
        const store = useStore$1(); // @ts-ignore

        return store.dispatch;
      };
    }
    /**
     * A hook to access the redux `dispatch` function.
     *
     * @returns {any|function} redux store's `dispatch` function
     *
     * @example
     *
     * import React, { useCallback } from 'react'
     * import { useDispatch } from 'react-redux'
     *
     * export const CounterComponent = ({ value }) => {
     *   const dispatch = useDispatch()
     *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
     *   return (
     *     <div>
     *       <span>{value}</span>
     *       <button onClick={increaseCounter}>Increase counter</button>
     *     </div>
     *   )
     * }
     */

    const useDispatch = /*#__PURE__*/createDispatchHook();

    // The primary entry point assumes we're working with standard ReactDOM/RN, but
    initializeUseSelector(withSelector.exports.useSyncExternalStoreWithSelector);
    // with standard React renderers (ReactDOM, React Native)

    setBatch(reactDom.unstable_batchedUpdates);

    function n$1(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return "'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r$2(n){return !!n&&!!n[Q]}function t$3(n){var r;return !!n&&(function(n){if(!n||"object"!=typeof n)return !1;var r=Object.getPrototypeOf(n);if(null===r)return !0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L$2]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L$2])||s$4(n)||v$2(n))}function i$4(n,r,t){void 0===t&&(t=!1),0===o$5(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n);})):n.forEach((function(t,e){return r(e,t,n)}));}function o$5(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s$4(n)?2:v$2(n)?3:0}function u$3(n,r){return 2===o$5(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a$1(n,r){return 2===o$5(n)?n.get(r):n[r]}function f$5(n,r,t){var e=o$5(n);2===e?n.set(r,t):3===e?n.add(t):n[r]=t;}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s$4(n){return X$1&&n instanceof Map}function v$2(n){return q&&n instanceof Set}function p$2(n){return n.o||n.t}function l$3(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]});}return Object.create(Object.getPrototypeOf(n),r)}function d$2(n,e){return void 0===e&&(e=!1),y$1(n)||r$2(n)||!t$3(n)||(o$5(n)>1&&(n.set=n.add=n.clear=n.delete=h$2),Object.freeze(n),e&&i$4(n,(function(n,r){return d$2(r,!0)}),!0)),n}function h$2(){n$1(2);}function y$1(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n$1(18,r),t}function m$2(n,r){tn[n]||(tn[n]=r);}function _(){return U$1}function j$1(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r);}function O$2(n){g$1(n),n.p.forEach(S$1),n.p=null;}function g$1(n){n===U$1&&(U$1=n.l);}function w$2(n){return U$1={p:[],l:U$1,h:n,m:!0,_:0}}function S$1(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0;}function P$2(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O$2(e),n$1(4)),t$3(r)&&(r=M$2(e,r),e.l||x$1(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M$2(e,i,[]),O$2(e),e.u&&e.v(e.u,e.s),r!==H$1?r:void 0}function M$2(n,r,t){if(y$1(r))return r;var e=r[Q];if(!e)return i$4(r,(function(i,o){return A$2(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x$1(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l$3(e.k):e.o,u=o,a=!1;3===e.i&&(u=new Set(o),o.clear(),a=!0),i$4(u,(function(r,i){return A$2(n,e,o,r,i,t,a)})),x$1(n,o,!1),t&&n.u&&b("Patches").N(e,t,n.u,n.s);}return e.o}function A$2(e,i,o,a,c,s,v){if(r$2(c)){var p=M$2(e,c,s&&i&&3!==i.i&&!u$3(i.R,a)?s.concat(a):void 0);if(f$5(o,a,p),!r$2(p))return;e.m=!1;}else v&&o.add(c);if(t$3(c)&&!y$1(c)){if(!e.h.D&&e._<1)return;M$2(e,c),i&&i.A.l||x$1(e,c);}}function x$1(n,r,t){void 0===t&&(t=!1),n.h.D&&n.m&&d$2(r,t);}function z(n,r){var t=n[Q];return (t?p$2(t):n)[r]}function I$3(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t);}}function k(n){n.P||(n.P=!0,n.l&&k(n.l));}function E$1(n){n.o||(n.o=l$3(n.t));}function N$1(n,r,t){var e=s$4(r)?b("MapSet").F(r,t):v$2(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,R:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en$2;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return (t?t.A:_()).p.push(e),e}function R(e){return r$2(e)||n$1(22,e),function n(r){if(!t$3(r))return r;var e,u=r[Q],c=o$5(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=D$1(r,c),u.I=!1;}else e=D$1(r,c);return i$4(e,(function(r,t){u&&a$1(u.t,r)===t||f$5(e,r,n(t));})),3===c?new Set(e):e}(e)}function D$1(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l$3(n)}function F$3(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return en$2.get(r,n)},set:function(r){var t=this[Q];en$2.set(t,n,r);}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t);}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u$3(r,o))return !0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return !0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return !0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return !0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return !0;return !1}var s={};m$2("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable);}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,R:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r$2(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.R,c=t.i;if(4===c)i$4(o,(function(r){r!==Q&&(void 0!==e[r]||u$3(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)));})),i$4(e,(function(n){void 0!==o[n]||u$3(o,n)||(f[n]=!1,k(t));}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l]);}}}}(n.p[0]),e(n.p));},K:function(n){return 4===n.i?o(n):a(n)}});}var G$1,U$1,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X$1="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H$1=W?Symbol.for("immer-nothing"):((G$1={})["immer-nothing"]=!0,G$1),L$2=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t);})),r},tn={},en$2={get:function(n,r){if(r===Q)return n;var e=p$2(n);if(!u$3(e,r))return function(n,r,t){var e,i=I$3(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t$3(i)?i:i===z(n.t,r)?(E$1(n),n.o[r]=N$1(n.A.h,i,n)):i},has:function(n,r){return r in p$2(n)},ownKeys:function(n){return Reflect.ownKeys(p$2(n))},set:function(n,r,t){var e=I$3(p$2(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p$2(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.R[r]=!1,!0;if(c(t,i)&&(void 0!==t||u$3(n.t,r)))return !0;E$1(n),k(n);}return n.o[r]===t&&(void 0!==t||r in n.o)||Number.isNaN(t)&&Number.isNaN(n.o[r])||(n.o[r]=t,n.R[r]=!0),!0},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.R[r]=!1,E$1(n),k(n)):delete n.R[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p$2(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n$1(11);},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n$1(12);}},on={};i$4(en$2,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)};})),on.deleteProperty=function(r,t){return on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return en$2.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.D=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return (t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n$1(6),void 0!==o&&"function"!=typeof o&&n$1(7),t$3(r)){var c=w$2(e),s=N$1(e,r,void 0),v=!0;try{f=i(s),v=!1;}finally{v?O$2(c):g$1(c);}return "undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j$1(c,o),P$2(n,c)}),(function(n){throw O$2(c),n})):(j$1(c,o),P$2(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H$1&&(f=void 0),e.D&&d$2(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l);}return f}n$1(21,r);},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r;}));return "undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return [n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze);}var i=e.prototype;return i.createDraft=function(e){t$3(e)||n$1(8),r$2(e)&&(e=R(e));var i=w$2(this),o=N$1(this,e,void 0);return o[Q].C=!0,g$1(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];var i=e.A;return j$1(i,t),P$2(void 0,i)},i.setAutoFreeze=function(n){this.D=n;},i.setUseProxies=function(r){r&&!B&&n$1(20),this.g=r;},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r$2(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce;an.produceWithPatches.bind(an);an.setAutoFreeze.bind(an);an.setUseProxies.bind(an);an.applyPatches.bind(an);an.createDraft.bind(an);an.finishDraft.bind(an);var createNextState3 = fn;

    function _typeof$2(obj) {
      "@babel/helpers - typeof";

      return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof$2(obj);
    }

    function _toPrimitive(input, hint) {
      if (_typeof$2(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof$2(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof$2(key) === "symbol" ? key : String(key);
    }

    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }

    function ownKeys$9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }

    /**
     * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
     *
     * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
     * during build.
     * @param {number} code
     */
    function formatProdErrorMessage(code) {
      return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
    }

    // Inlined version of the `symbol-observable` polyfill
    var $$observable = (function () {
      return typeof Symbol === 'function' && Symbol.observable || '@@observable';
    })();

    /**
     * These are private action types reserved by Redux.
     * For any unknown actions, you must return the current state.
     * If the current state is undefined, you must return the initial state.
     * Do not reference these action types directly in your code.
     */
    var randomString = function randomString() {
      return Math.random().toString(36).substring(7).split('').join('.');
    };

    var ActionTypes = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };

    /**
     * @param {any} obj The object to inspect.
     * @returns {boolean} True if the argument appears to be a plain object.
     */
    function isPlainObject$3(obj) {
      if (typeof obj !== 'object' || obj === null) return false;
      var proto = obj;

      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }

      return Object.getPrototypeOf(obj) === proto;
    }

    /**
     * @deprecated
     *
     * **We recommend using the `configureStore` method
     * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
     *
     * Redux Toolkit is our recommended approach for writing Redux logic today,
     * including store setup, reducers, data fetching, and more.
     *
     * **For more details, please read this Redux docs page:**
     * **https://redux.js.org/introduction/why-rtk-is-redux-today**
     *
     * `configureStore` from Redux Toolkit is an improved version of `createStore` that
     * simplifies setup and helps avoid common bugs.
     *
     * You should not be using the `redux` core package by itself today, except for learning purposes.
     * The `createStore` method from the core `redux` package will not be removed, but we encourage
     * all users to migrate to using Redux Toolkit for all Redux code.
     *
     * If you want to use `createStore` without this visual deprecation warning, use
     * the `legacy_createStore` import instead:
     *
     * `import { legacy_createStore as createStore} from 'redux'`
     *
     */

    function createStore(reducer, preloadedState, enhancer) {
      var _ref2;

      if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
        throw new Error(formatProdErrorMessage(0) );
      }

      if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
        enhancer = preloadedState;
        preloadedState = undefined;
      }

      if (typeof enhancer !== 'undefined') {
        if (typeof enhancer !== 'function') {
          throw new Error(formatProdErrorMessage(1) );
        }

        return enhancer(createStore)(reducer, preloadedState);
      }

      if (typeof reducer !== 'function') {
        throw new Error(formatProdErrorMessage(2) );
      }

      var currentReducer = reducer;
      var currentState = preloadedState;
      var currentListeners = [];
      var nextListeners = currentListeners;
      var isDispatching = false;
      /**
       * This makes a shallow copy of currentListeners so we can use
       * nextListeners as a temporary list while dispatching.
       *
       * This prevents any bugs around consumers calling
       * subscribe/unsubscribe in the middle of a dispatch.
       */

      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = currentListeners.slice();
        }
      }
      /**
       * Reads the state tree managed by the store.
       *
       * @returns {any} The current state tree of your application.
       */


      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(3) );
        }

        return currentState;
      }
      /**
       * Adds a change listener. It will be called any time an action is dispatched,
       * and some part of the state tree may potentially have changed. You may then
       * call `getState()` to read the current state tree inside the callback.
       *
       * You may call `dispatch()` from a change listener, with the following
       * caveats:
       *
       * 1. The subscriptions are snapshotted just before every `dispatch()` call.
       * If you subscribe or unsubscribe while the listeners are being invoked, this
       * will not have any effect on the `dispatch()` that is currently in progress.
       * However, the next `dispatch()` call, whether nested or not, will use a more
       * recent snapshot of the subscription list.
       *
       * 2. The listener should not expect to see all state changes, as the state
       * might have been updated multiple times during a nested `dispatch()` before
       * the listener is called. It is, however, guaranteed that all subscribers
       * registered before the `dispatch()` started will be called with the latest
       * state by the time it exits.
       *
       * @param {Function} listener A callback to be invoked on every dispatch.
       * @returns {Function} A function to remove this change listener.
       */


      function subscribe(listener) {
        if (typeof listener !== 'function') {
          throw new Error(formatProdErrorMessage(4) );
        }

        if (isDispatching) {
          throw new Error(formatProdErrorMessage(5) );
        }

        var isSubscribed = true;
        ensureCanMutateNextListeners();
        nextListeners.push(listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }

          if (isDispatching) {
            throw new Error(formatProdErrorMessage(6) );
          }

          isSubscribed = false;
          ensureCanMutateNextListeners();
          var index = nextListeners.indexOf(listener);
          nextListeners.splice(index, 1);
          currentListeners = null;
        };
      }
      /**
       * Dispatches an action. It is the only way to trigger a state change.
       *
       * The `reducer` function, used to create the store, will be called with the
       * current state tree and the given `action`. Its return value will
       * be considered the **next** state of the tree, and the change listeners
       * will be notified.
       *
       * The base implementation only supports plain object actions. If you want to
       * dispatch a Promise, an Observable, a thunk, or something else, you need to
       * wrap your store creating function into the corresponding middleware. For
       * example, see the documentation for the `redux-thunk` package. Even the
       * middleware will eventually dispatch plain object actions using this method.
       *
       * @param {Object} action A plain object representing “what changed”. It is
       * a good idea to keep actions serializable so you can record and replay user
       * sessions, or use the time travelling `redux-devtools`. An action must have
       * a `type` property which may not be `undefined`. It is a good idea to use
       * string constants for action types.
       *
       * @returns {Object} For convenience, the same action object you dispatched.
       *
       * Note that, if you use a custom middleware, it may wrap `dispatch()` to
       * return something else (for example, a Promise you can await).
       */


      function dispatch(action) {
        if (!isPlainObject$3(action)) {
          throw new Error(formatProdErrorMessage(7) );
        }

        if (typeof action.type === 'undefined') {
          throw new Error(formatProdErrorMessage(8) );
        }

        if (isDispatching) {
          throw new Error(formatProdErrorMessage(9) );
        }

        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }

        var listeners = currentListeners = nextListeners;

        for (var i = 0; i < listeners.length; i++) {
          var listener = listeners[i];
          listener();
        }

        return action;
      }
      /**
       * Replaces the reducer currently used by the store to calculate the state.
       *
       * You might need this if your app implements code splitting and you want to
       * load some of the reducers dynamically. You might also need this if you
       * implement a hot reloading mechanism for Redux.
       *
       * @param {Function} nextReducer The reducer for the store to use instead.
       * @returns {void}
       */


      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== 'function') {
          throw new Error(formatProdErrorMessage(10) );
        }

        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
        // Any reducers that existed in both the new and old rootReducer
        // will receive the previous state. This effectively populates
        // the new state tree with any relevant data from the old one.

        dispatch({
          type: ActionTypes.REPLACE
        });
      }
      /**
       * Interoperability point for observable/reactive libraries.
       * @returns {observable} A minimal observable of state changes.
       * For more information, see the observable proposal:
       * https://github.com/tc39/proposal-observable
       */


      function observable() {
        var _ref;

        var outerSubscribe = subscribe;
        return _ref = {
          /**
           * The minimal observable subscription method.
           * @param {Object} observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns {subscription} An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe: function subscribe(observer) {
            if (typeof observer !== 'object' || observer === null) {
              throw new Error(formatProdErrorMessage(11) );
            }

            function observeState() {
              if (observer.next) {
                observer.next(getState());
              }
            }

            observeState();
            var unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe: unsubscribe
            };
          }
        }, _ref[$$observable] = function () {
          return this;
        }, _ref;
      } // When a store is created, an "INIT" action is dispatched so that every
      // reducer returns their initial state. This effectively populates
      // the initial state tree.


      dispatch({
        type: ActionTypes.INIT
      });
      return _ref2 = {
        dispatch: dispatch,
        subscribe: subscribe,
        getState: getState,
        replaceReducer: replaceReducer
      }, _ref2[$$observable] = observable, _ref2;
    }

    function assertReducerShape(reducers) {
      Object.keys(reducers).forEach(function (key) {
        var reducer = reducers[key];
        var initialState = reducer(undefined, {
          type: ActionTypes.INIT
        });

        if (typeof initialState === 'undefined') {
          throw new Error(formatProdErrorMessage(12) );
        }

        if (typeof reducer(undefined, {
          type: ActionTypes.PROBE_UNKNOWN_ACTION()
        }) === 'undefined') {
          throw new Error(formatProdErrorMessage(13) );
        }
      });
    }
    /**
     * Turns an object whose values are different reducer functions, into a single
     * reducer function. It will call every child reducer, and gather their results
     * into a single state object, whose keys correspond to the keys of the passed
     * reducer functions.
     *
     * @param {Object} reducers An object whose values correspond to different
     * reducer functions that need to be combined into one. One handy way to obtain
     * it is to use ES6 `import * as reducers` syntax. The reducers may never return
     * undefined for any action. Instead, they should return their initial state
     * if the state passed to them was undefined, and the current state for any
     * unrecognized action.
     *
     * @returns {Function} A reducer function that invokes every reducer inside the
     * passed object, and builds a state object with the same shape.
     */


    function combineReducers(reducers) {
      var reducerKeys = Object.keys(reducers);
      var finalReducers = {};

      for (var i = 0; i < reducerKeys.length; i++) {
        var key = reducerKeys[i];

        if (typeof reducers[key] === 'function') {
          finalReducers[key] = reducers[key];
        }
      }

      var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same

      var shapeAssertionError;

      try {
        assertReducerShape(finalReducers);
      } catch (e) {
        shapeAssertionError = e;
      }

      return function combination(state, action) {
        if (state === void 0) {
          state = {};
        }

        if (shapeAssertionError) {
          throw shapeAssertionError;
        }

        var hasChanged = false;
        var nextState = {};

        for (var _i = 0; _i < finalReducerKeys.length; _i++) {
          var _key = finalReducerKeys[_i];
          var reducer = finalReducers[_key];
          var previousStateForKey = state[_key];
          var nextStateForKey = reducer(previousStateForKey, action);

          if (typeof nextStateForKey === 'undefined') {
            action && action.type;
            throw new Error(formatProdErrorMessage(14) );
          }

          nextState[_key] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }

        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
      };
    }

    /**
     * Composes single-argument functions from right to left. The rightmost
     * function can take multiple arguments as it provides the signature for
     * the resulting composite function.
     *
     * @param {...Function} funcs The functions to compose.
     * @returns {Function} A function obtained by composing the argument functions
     * from right to left. For example, compose(f, g, h) is identical to doing
     * (...args) => f(g(h(...args))).
     */
    function compose() {
      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }

      if (funcs.length === 0) {
        return function (arg) {
          return arg;
        };
      }

      if (funcs.length === 1) {
        return funcs[0];
      }

      return funcs.reduce(function (a, b) {
        return function () {
          return a(b.apply(void 0, arguments));
        };
      });
    }

    /**
     * Creates a store enhancer that applies middleware to the dispatch method
     * of the Redux store. This is handy for a variety of tasks, such as expressing
     * asynchronous actions in a concise manner, or logging every action payload.
     *
     * See `redux-thunk` package as an example of the Redux middleware.
     *
     * Because middleware is potentially asynchronous, this should be the first
     * store enhancer in the composition chain.
     *
     * Note that each middleware will be given the `dispatch` and `getState` functions
     * as named arguments.
     *
     * @param {...Function} middlewares The middleware chain to be applied.
     * @returns {Function} A store enhancer applying the middleware.
     */

    function applyMiddleware() {
      for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        middlewares[_key] = arguments[_key];
      }

      return function (createStore) {
        return function () {
          var store = createStore.apply(void 0, arguments);

          var _dispatch = function dispatch() {
            throw new Error(formatProdErrorMessage(15) );
          };

          var middlewareAPI = {
            getState: store.getState,
            dispatch: function dispatch() {
              return _dispatch.apply(void 0, arguments);
            }
          };
          var chain = middlewares.map(function (middleware) {
            return middleware(middlewareAPI);
          });
          _dispatch = compose.apply(void 0, chain)(store.dispatch);
          return _objectSpread2(_objectSpread2({}, store), {}, {
            dispatch: _dispatch
          });
        };
      };
    }

    // Cache implementation based on Erik Rasmussen's `lru-memoize`:
    // https://github.com/erikras/lru-memoize
    var NOT_FOUND = 'NOT_FOUND';

    function createSingletonCache(equals) {
      var entry;
      return {
        get: function get(key) {
          if (entry && equals(entry.key, key)) {
            return entry.value;
          }

          return NOT_FOUND;
        },
        put: function put(key, value) {
          entry = {
            key: key,
            value: value
          };
        },
        getEntries: function getEntries() {
          return entry ? [entry] : [];
        },
        clear: function clear() {
          entry = undefined;
        }
      };
    }

    function createLruCache(maxSize, equals) {
      var entries = [];

      function get(key) {
        var cacheIndex = entries.findIndex(function (entry) {
          return equals(key, entry.key);
        }); // We found a cached entry

        if (cacheIndex > -1) {
          var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top

          if (cacheIndex > 0) {
            entries.splice(cacheIndex, 1);
            entries.unshift(entry);
          }

          return entry.value;
        } // No entry found in cache, return sentinel


        return NOT_FOUND;
      }

      function put(key, value) {
        if (get(key) === NOT_FOUND) {
          // TODO Is unshift slow?
          entries.unshift({
            key: key,
            value: value
          });

          if (entries.length > maxSize) {
            entries.pop();
          }
        }
      }

      function getEntries() {
        return entries;
      }

      function clear() {
        entries = [];
      }

      return {
        get: get,
        put: put,
        getEntries: getEntries,
        clear: clear
      };
    }

    var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
      return a === b;
    };
    function createCacheKeyComparator(equalityCheck) {
      return function areArgumentsShallowlyEqual(prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
          return false;
        } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.


        var length = prev.length;

        for (var i = 0; i < length; i++) {
          if (!equalityCheck(prev[i], next[i])) {
            return false;
          }
        }

        return true;
      };
    }
    // defaultMemoize now supports a configurable cache size with LRU behavior,
    // and optional comparison of the result value with existing values
    function defaultMemoize(func, equalityCheckOrOptions) {
      var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {
        equalityCheck: equalityCheckOrOptions
      };
      var _providedOptions$equa = providedOptions.equalityCheck,
          equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,
          _providedOptions$maxS = providedOptions.maxSize,
          maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,
          resultEqualityCheck = providedOptions.resultEqualityCheck;
      var comparator = createCacheKeyComparator(equalityCheck);
      var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons

      function memoized() {
        var value = cache.get(arguments);

        if (value === NOT_FOUND) {
          // @ts-ignore
          value = func.apply(null, arguments);

          if (resultEqualityCheck) {
            var entries = cache.getEntries();
            var matchingEntry = entries.find(function (entry) {
              return resultEqualityCheck(entry.value, value);
            });

            if (matchingEntry) {
              value = matchingEntry.value;
            }
          }

          cache.put(arguments, value);
        }

        return value;
      }

      memoized.clearCache = function () {
        return cache.clear();
      };

      return memoized;
    }

    function getDependencies(funcs) {
      var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

      if (!dependencies.every(function (dep) {
        return typeof dep === 'function';
      })) {
        var dependencyTypes = dependencies.map(function (dep) {
          return typeof dep === 'function' ? "function " + (dep.name || 'unnamed') + "()" : typeof dep;
        }).join(', ');
        throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
      }

      return dependencies;
    }

    function createSelectorCreator(memoize) {
      for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        memoizeOptionsFromArgs[_key - 1] = arguments[_key];
      }

      var createSelector = function createSelector() {
        for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          funcs[_key2] = arguments[_key2];
        }

        var _recomputations = 0;

        var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.
        // So, start by declaring the default value here.
        // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)


        var directlyPassedOptions = {
          memoizeOptions: undefined
        }; // Normally, the result func or "output selector" is the last arg

        var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object

        if (typeof resultFunc === 'object') {
          directlyPassedOptions = resultFunc; // and pop the real result func off

          resultFunc = funcs.pop();
        }

        if (typeof resultFunc !== 'function') {
          throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
        } // Determine which set of options we're using. Prefer options passed directly,
        // but fall back to options given to createSelectorCreator.


        var _directlyPassedOption = directlyPassedOptions,
            _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,
            memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer
        // is an array. In most libs I've looked at, it's an equality function or options object.
        // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full
        // user-provided array of options. Otherwise, it must be just the _first_ arg, and so
        // we wrap it in an array so we can apply it.

        var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
        var dependencies = getDependencies(funcs);
        var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {
          _recomputations++; // apply arguments instead of spreading for performance.

          return resultFunc.apply(null, arguments);
        }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.

        var selector = memoize(function dependenciesChecker() {
          var params = [];
          var length = dependencies.length;

          for (var i = 0; i < length; i++) {
            // apply arguments instead of spreading and mutate a local list of params for performance.
            // @ts-ignore
            params.push(dependencies[i].apply(null, arguments));
          } // apply arguments instead of spreading for performance.


          _lastResult = memoizedResultFunc.apply(null, params);
          return _lastResult;
        });
        Object.assign(selector, {
          resultFunc: resultFunc,
          memoizedResultFunc: memoizedResultFunc,
          dependencies: dependencies,
          lastResult: function lastResult() {
            return _lastResult;
          },
          recomputations: function recomputations() {
            return _recomputations;
          },
          resetRecomputations: function resetRecomputations() {
            return _recomputations = 0;
          }
        });
        return selector;
      }; // @ts-ignore


      return createSelector;
    }
    var createSelector = /* #__PURE__ */createSelectorCreator(defaultMemoize);

    /** A function that accepts a potential "extra argument" value to be injected later,
     * and returns an instance of the thunk middleware that uses that value
     */
    function createThunkMiddleware(extraArgument) {
      // Standard Redux middleware definition pattern:
      // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
      var middleware = function middleware(_ref) {
        var dispatch = _ref.dispatch,
            getState = _ref.getState;
        return function (next) {
          return function (action) {
            // The thunk middleware looks for any functions that were passed to `store.dispatch`.
            // If this "action" is really a function, call it and return the result.
            if (typeof action === 'function') {
              // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
              return action(dispatch, getState, extraArgument);
            } // Otherwise, pass the action down the middleware chain as usual


            return next(action);
          };
        };
      };

      return middleware;
    }

    var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
    // with whatever "extra arg" they want to inject into their thunks

    thunk.withExtraArgument = createThunkMiddleware;
    var thunkMiddleware = thunk;

    var __extends$6 = (window && window.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __generator$6 = (window && window.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __spreadArray = (window && window.__spreadArray) || function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = function (obj, key, value) { return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value }) : obj[key] = value; };
    var __spreadValues = function (a, b) {
        for (var prop in b || (b = {}))
            if (__hasOwnProp.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        if (__getOwnPropSymbols)
            for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {
                var prop = _c[_i];
                if (__propIsEnum.call(b, prop))
                    __defNormalProp(a, prop, b[prop]);
            }
        return a;
    };
    var __spreadProps = function (a, b) { return __defProps(a, __getOwnPropDescs(b)); };
    var __async = function (__this, __arguments, generator) {
        return new Promise(function (resolve, reject) {
            var fulfilled = function (value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            };
            var rejected = function (value) {
                try {
                    step(generator.throw(value));
                }
                catch (e) {
                    reject(e);
                }
            };
            var step = function (x) { return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected); };
            step((generator = generator.apply(__this, __arguments)).next());
        });
    };
    var createDraftSafeSelector = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var selector = createSelector.apply(void 0, args);
        var wrappedSelector = function (value) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            return selector.apply(void 0, __spreadArray([r$2(value) ? R(value) : value], rest));
        };
        return wrappedSelector;
    };
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
        if (arguments.length === 0)
            return void 0;
        if (typeof arguments[0] === "object")
            return compose;
        return compose.apply(null, arguments);
    };
    // src/isPlainObject.ts
    function isPlainObject$2(value) {
        if (typeof value !== "object" || value === null)
            return false;
        var proto = Object.getPrototypeOf(value);
        if (proto === null)
            return true;
        var baseProto = proto;
        while (Object.getPrototypeOf(baseProto) !== null) {
            baseProto = Object.getPrototypeOf(baseProto);
        }
        return proto === baseProto;
    }
    var MiddlewareArray = /** @class */ (function (_super) {
        __extends$6(MiddlewareArray, _super);
        function MiddlewareArray() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            Object.setPrototypeOf(_this, MiddlewareArray.prototype);
            return _this;
        }
        Object.defineProperty(MiddlewareArray, Symbol.species, {
            get: function () {
                return MiddlewareArray;
            },
            enumerable: false,
            configurable: true
        });
        MiddlewareArray.prototype.concat = function () {
            var arr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arr[_i] = arguments[_i];
            }
            return _super.prototype.concat.apply(this, arr);
        };
        MiddlewareArray.prototype.prepend = function () {
            var arr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arr[_i] = arguments[_i];
            }
            if (arr.length === 1 && Array.isArray(arr[0])) {
                return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();
            }
            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();
        };
        return MiddlewareArray;
    }(Array));
    function freezeDraftable(val) {
        return t$3(val) ? createNextState3(val, function () {
        }) : val;
    }
    // src/getDefaultMiddleware.ts
    function isBoolean$1(x) {
        return typeof x === "boolean";
    }
    function curryGetDefaultMiddleware() {
        return function curriedGetDefaultMiddleware(options) {
            return getDefaultMiddleware(options);
        };
    }
    function getDefaultMiddleware(options) {
        if (options === void 0) { options = {}; }
        var _c = options.thunk, thunk = _c === void 0 ? true : _c; options.immutableCheck; options.serializableCheck;
        var middlewareArray = new MiddlewareArray();
        if (thunk) {
            if (isBoolean$1(thunk)) {
                middlewareArray.push(thunkMiddleware);
            }
            else {
                middlewareArray.push(thunkMiddleware.withExtraArgument(thunk.extraArgument));
            }
        }
        return middlewareArray;
    }
    // src/configureStore.ts
    var IS_PRODUCTION = "production" === "production";
    function configureStore(options) {
        var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
        var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
        var rootReducer;
        if (typeof reducer === "function") {
            rootReducer = reducer;
        }
        else if (isPlainObject$2(reducer)) {
            rootReducer = combineReducers(reducer);
        }
        else {
            throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
        }
        var finalMiddleware = middleware;
        if (typeof finalMiddleware === "function") {
            finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
        }
        var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
        var finalCompose = compose;
        if (devTools) {
            finalCompose = composeWithDevTools(__spreadValues({
                trace: !IS_PRODUCTION
            }, typeof devTools === "object" && devTools));
        }
        var storeEnhancers = [middlewareEnhancer];
        if (Array.isArray(enhancers)) {
            storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
        }
        else if (typeof enhancers === "function") {
            storeEnhancers = enhancers(storeEnhancers);
        }
        var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
        return createStore(rootReducer, preloadedState, composedEnhancer);
    }
    // src/createAction.ts
    function createAction(type, prepareAction) {
        function actionCreator() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (prepareAction) {
                var prepared = prepareAction.apply(void 0, args);
                if (!prepared) {
                    throw new Error("prepareAction did not return an object");
                }
                return __spreadValues(__spreadValues({
                    type: type,
                    payload: prepared.payload
                }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
            }
            return { type: type, payload: args[0] };
        }
        actionCreator.toString = function () { return "" + type; };
        actionCreator.type = type;
        actionCreator.match = function (action) { return action.type === type; };
        return actionCreator;
    }
    function isFSA(action) {
        return isPlainObject$2(action) && typeof action.type === "string" && Object.keys(action).every(isValidKey);
    }
    function isValidKey(key) {
        return ["type", "payload", "error", "meta"].indexOf(key) > -1;
    }
    // src/mapBuilders.ts
    function executeReducerBuilderCallback(builderCallback) {
        var actionsMap = {};
        var actionMatchers = [];
        var defaultCaseReducer;
        var builder = {
            addCase: function (typeOrActionCreator, reducer) {
                var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
                if (type in actionsMap) {
                    throw new Error("addCase cannot be called with two reducers for the same action type");
                }
                actionsMap[type] = reducer;
                return builder;
            },
            addMatcher: function (matcher, reducer) {
                actionMatchers.push({ matcher: matcher, reducer: reducer });
                return builder;
            },
            addDefaultCase: function (reducer) {
                defaultCaseReducer = reducer;
                return builder;
            }
        };
        builderCallback(builder);
        return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    // src/createReducer.ts
    function isStateFunction(x) {
        return typeof x === "function";
    }
    function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
        if (actionMatchers === void 0) { actionMatchers = []; }
        var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
        var getInitialState;
        if (isStateFunction(initialState)) {
            getInitialState = function () { return freezeDraftable(initialState()); };
        }
        else {
            var frozenInitialState_1 = freezeDraftable(initialState);
            getInitialState = function () { return frozenInitialState_1; };
        }
        function reducer(state, action) {
            if (state === void 0) { state = getInitialState(); }
            var caseReducers = __spreadArray([
                actionsMap[action.type]
            ], finalActionMatchers.filter(function (_c) {
                var matcher = _c.matcher;
                return matcher(action);
            }).map(function (_c) {
                var reducer2 = _c.reducer;
                return reducer2;
            }));
            if (caseReducers.filter(function (cr) { return !!cr; }).length === 0) {
                caseReducers = [finalDefaultCaseReducer];
            }
            return caseReducers.reduce(function (previousState, caseReducer) {
                if (caseReducer) {
                    if (r$2(previousState)) {
                        var draft = previousState;
                        var result = caseReducer(draft, action);
                        if (result === void 0) {
                            return previousState;
                        }
                        return result;
                    }
                    else if (!t$3(previousState)) {
                        var result = caseReducer(previousState, action);
                        if (result === void 0) {
                            if (previousState === null) {
                                return previousState;
                            }
                            throw Error("A case reducer on a non-draftable value must not return undefined");
                        }
                        return result;
                    }
                    else {
                        return createNextState3(previousState, function (draft) {
                            return caseReducer(draft, action);
                        });
                    }
                }
                return previousState;
            }, state);
        }
        reducer.getInitialState = getInitialState;
        return reducer;
    }
    function getType2(slice, actionKey) {
        return slice + "/" + actionKey;
    }
    function createSlice(options) {
        var name = options.name;
        if (!name) {
            throw new Error("`name` is a required option for createSlice");
        }
        if (typeof process !== "undefined" && "production" === "development") {
            if (options.initialState === void 0) {
                console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
            }
        }
        var initialState = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
        var reducers = options.reducers || {};
        var reducerNames = Object.keys(reducers);
        var sliceCaseReducersByName = {};
        var sliceCaseReducersByType = {};
        var actionCreators = {};
        reducerNames.forEach(function (reducerName) {
            var maybeReducerWithPrepare = reducers[reducerName];
            var type = getType2(name, reducerName);
            var caseReducer;
            var prepareCallback;
            if ("reducer" in maybeReducerWithPrepare) {
                caseReducer = maybeReducerWithPrepare.reducer;
                prepareCallback = maybeReducerWithPrepare.prepare;
            }
            else {
                caseReducer = maybeReducerWithPrepare;
            }
            sliceCaseReducersByName[reducerName] = caseReducer;
            sliceCaseReducersByType[type] = caseReducer;
            actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
        });
        function buildReducer() {
            var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
            var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
            return createReducer(initialState, function (builder) {
                for (var key in finalCaseReducers) {
                    builder.addCase(key, finalCaseReducers[key]);
                }
                for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
                    var m = actionMatchers_1[_i];
                    builder.addMatcher(m.matcher, m.reducer);
                }
                if (defaultCaseReducer) {
                    builder.addDefaultCase(defaultCaseReducer);
                }
            });
        }
        var _reducer;
        return {
            name: name,
            reducer: function (state, action) {
                if (!_reducer)
                    _reducer = buildReducer();
                return _reducer(state, action);
            },
            actions: actionCreators,
            caseReducers: sliceCaseReducersByName,
            getInitialState: function () {
                if (!_reducer)
                    _reducer = buildReducer();
                return _reducer.getInitialState();
            }
        };
    }
    // src/entities/entity_state.ts
    function getInitialEntityState() {
        return {
            ids: [],
            entities: {}
        };
    }
    function createInitialStateFactory() {
        function getInitialState(additionalState) {
            if (additionalState === void 0) { additionalState = {}; }
            return Object.assign(getInitialEntityState(), additionalState);
        }
        return { getInitialState: getInitialState };
    }
    // src/entities/state_selectors.ts
    function createSelectorsFactory() {
        function getSelectors(selectState) {
            var selectIds = function (state) { return state.ids; };
            var selectEntities = function (state) { return state.entities; };
            var selectAll = createDraftSafeSelector(selectIds, selectEntities, function (ids, entities) { return ids.map(function (id) { return entities[id]; }); });
            var selectId = function (_, id) { return id; };
            var selectById = function (entities, id) { return entities[id]; };
            var selectTotal = createDraftSafeSelector(selectIds, function (ids) { return ids.length; });
            if (!selectState) {
                return {
                    selectIds: selectIds,
                    selectEntities: selectEntities,
                    selectAll: selectAll,
                    selectTotal: selectTotal,
                    selectById: createDraftSafeSelector(selectEntities, selectId, selectById)
                };
            }
            var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);
            return {
                selectIds: createDraftSafeSelector(selectState, selectIds),
                selectEntities: selectGlobalizedEntities,
                selectAll: createDraftSafeSelector(selectState, selectAll),
                selectTotal: createDraftSafeSelector(selectState, selectTotal),
                selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)
            };
        }
        return { getSelectors: getSelectors };
    }
    function createSingleArgumentStateOperator(mutator) {
        var operator = createStateOperator(function (_, state) { return mutator(state); });
        return function operation(state) {
            return operator(state, void 0);
        };
    }
    function createStateOperator(mutator) {
        return function operation(state, arg) {
            function isPayloadActionArgument(arg2) {
                return isFSA(arg2);
            }
            var runMutator = function (draft) {
                if (isPayloadActionArgument(arg)) {
                    mutator(arg.payload, draft);
                }
                else {
                    mutator(arg, draft);
                }
            };
            if (r$2(state)) {
                runMutator(state);
                return state;
            }
            else {
                return createNextState3(state, runMutator);
            }
        };
    }
    // src/entities/utils.ts
    function selectIdValue(entity, selectId) {
        var key = selectId(entity);
        return key;
    }
    function ensureEntitiesArray(entities) {
        if (!Array.isArray(entities)) {
            entities = Object.values(entities);
        }
        return entities;
    }
    function splitAddedUpdatedEntities(newEntities, selectId, state) {
        newEntities = ensureEntitiesArray(newEntities);
        var added = [];
        var updated = [];
        for (var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++) {
            var entity = newEntities_1[_i];
            var id = selectIdValue(entity, selectId);
            if (id in state.entities) {
                updated.push({ id: id, changes: entity });
            }
            else {
                added.push(entity);
            }
        }
        return [added, updated];
    }
    // src/entities/unsorted_state_adapter.ts
    function createUnsortedStateAdapter(selectId) {
        function addOneMutably(entity, state) {
            var key = selectIdValue(entity, selectId);
            if (key in state.entities) {
                return;
            }
            state.ids.push(key);
            state.entities[key] = entity;
        }
        function addManyMutably(newEntities, state) {
            newEntities = ensureEntitiesArray(newEntities);
            for (var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++) {
                var entity = newEntities_2[_i];
                addOneMutably(entity, state);
            }
        }
        function setOneMutably(entity, state) {
            var key = selectIdValue(entity, selectId);
            if (!(key in state.entities)) {
                state.ids.push(key);
            }
            state.entities[key] = entity;
        }
        function setManyMutably(newEntities, state) {
            newEntities = ensureEntitiesArray(newEntities);
            for (var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++) {
                var entity = newEntities_3[_i];
                setOneMutably(entity, state);
            }
        }
        function setAllMutably(newEntities, state) {
            newEntities = ensureEntitiesArray(newEntities);
            state.ids = [];
            state.entities = {};
            addManyMutably(newEntities, state);
        }
        function removeOneMutably(key, state) {
            return removeManyMutably([key], state);
        }
        function removeManyMutably(keys, state) {
            var didMutate = false;
            keys.forEach(function (key) {
                if (key in state.entities) {
                    delete state.entities[key];
                    didMutate = true;
                }
            });
            if (didMutate) {
                state.ids = state.ids.filter(function (id) { return id in state.entities; });
            }
        }
        function removeAllMutably(state) {
            Object.assign(state, {
                ids: [],
                entities: {}
            });
        }
        function takeNewKey(keys, update, state) {
            var original2 = state.entities[update.id];
            var updated = Object.assign({}, original2, update.changes);
            var newKey = selectIdValue(updated, selectId);
            var hasNewKey = newKey !== update.id;
            if (hasNewKey) {
                keys[update.id] = newKey;
                delete state.entities[update.id];
            }
            state.entities[newKey] = updated;
            return hasNewKey;
        }
        function updateOneMutably(update, state) {
            return updateManyMutably([update], state);
        }
        function updateManyMutably(updates, state) {
            var newKeys = {};
            var updatesPerEntity = {};
            updates.forEach(function (update) {
                if (update.id in state.entities) {
                    updatesPerEntity[update.id] = {
                        id: update.id,
                        changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)
                    };
                }
            });
            updates = Object.values(updatesPerEntity);
            var didMutateEntities = updates.length > 0;
            if (didMutateEntities) {
                var didMutateIds = updates.filter(function (update) { return takeNewKey(newKeys, update, state); }).length > 0;
                if (didMutateIds) {
                    state.ids = Object.keys(state.entities);
                }
            }
        }
        function upsertOneMutably(entity, state) {
            return upsertManyMutably([entity], state);
        }
        function upsertManyMutably(newEntities, state) {
            var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];
            updateManyMutably(updated, state);
            addManyMutably(added, state);
        }
        return {
            removeAll: createSingleArgumentStateOperator(removeAllMutably),
            addOne: createStateOperator(addOneMutably),
            addMany: createStateOperator(addManyMutably),
            setOne: createStateOperator(setOneMutably),
            setMany: createStateOperator(setManyMutably),
            setAll: createStateOperator(setAllMutably),
            updateOne: createStateOperator(updateOneMutably),
            updateMany: createStateOperator(updateManyMutably),
            upsertOne: createStateOperator(upsertOneMutably),
            upsertMany: createStateOperator(upsertManyMutably),
            removeOne: createStateOperator(removeOneMutably),
            removeMany: createStateOperator(removeManyMutably)
        };
    }
    // src/entities/sorted_state_adapter.ts
    function createSortedStateAdapter(selectId, sort) {
        var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;
        function addOneMutably(entity, state) {
            return addManyMutably([entity], state);
        }
        function addManyMutably(newEntities, state) {
            newEntities = ensureEntitiesArray(newEntities);
            var models = newEntities.filter(function (model) { return !(selectIdValue(model, selectId) in state.entities); });
            if (models.length !== 0) {
                merge(models, state);
            }
        }
        function setOneMutably(entity, state) {
            return setManyMutably([entity], state);
        }
        function setManyMutably(newEntities, state) {
            newEntities = ensureEntitiesArray(newEntities);
            if (newEntities.length !== 0) {
                merge(newEntities, state);
            }
        }
        function setAllMutably(newEntities, state) {
            newEntities = ensureEntitiesArray(newEntities);
            state.entities = {};
            state.ids = [];
            addManyMutably(newEntities, state);
        }
        function updateOneMutably(update, state) {
            return updateManyMutably([update], state);
        }
        function updateManyMutably(updates, state) {
            var appliedUpdates = false;
            for (var _i = 0, updates_1 = updates; _i < updates_1.length; _i++) {
                var update = updates_1[_i];
                var entity = state.entities[update.id];
                if (!entity) {
                    continue;
                }
                appliedUpdates = true;
                Object.assign(entity, update.changes);
                var newId = selectId(entity);
                if (update.id !== newId) {
                    delete state.entities[update.id];
                    state.entities[newId] = entity;
                }
            }
            if (appliedUpdates) {
                resortEntities(state);
            }
        }
        function upsertOneMutably(entity, state) {
            return upsertManyMutably([entity], state);
        }
        function upsertManyMutably(newEntities, state) {
            var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];
            updateManyMutably(updated, state);
            addManyMutably(added, state);
        }
        function areArraysEqual(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length && i < b.length; i++) {
                if (a[i] === b[i]) {
                    continue;
                }
                return false;
            }
            return true;
        }
        function merge(models, state) {
            models.forEach(function (model) {
                state.entities[selectId(model)] = model;
            });
            resortEntities(state);
        }
        function resortEntities(state) {
            var allEntities = Object.values(state.entities);
            allEntities.sort(sort);
            var newSortedIds = allEntities.map(selectId);
            var ids = state.ids;
            if (!areArraysEqual(ids, newSortedIds)) {
                state.ids = newSortedIds;
            }
        }
        return {
            removeOne: removeOne,
            removeMany: removeMany,
            removeAll: removeAll,
            addOne: createStateOperator(addOneMutably),
            updateOne: createStateOperator(updateOneMutably),
            upsertOne: createStateOperator(upsertOneMutably),
            setOne: createStateOperator(setOneMutably),
            setMany: createStateOperator(setManyMutably),
            setAll: createStateOperator(setAllMutably),
            addMany: createStateOperator(addManyMutably),
            updateMany: createStateOperator(updateManyMutably),
            upsertMany: createStateOperator(upsertManyMutably)
        };
    }
    // src/entities/create_adapter.ts
    function createEntityAdapter(options) {
        if (options === void 0) { options = {}; }
        var _c = __spreadValues({
            sortComparer: false,
            selectId: function (instance) { return instance.id; }
        }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;
        var stateFactory = createInitialStateFactory();
        var selectorsFactory = createSelectorsFactory();
        var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
        return __spreadValues(__spreadValues(__spreadValues({
            selectId: selectId,
            sortComparer: sortComparer
        }, stateFactory), selectorsFactory), stateAdapter);
    }
    // src/nanoid.ts
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = function (size) {
        if (size === void 0) { size = 21; }
        var id = "";
        var i = size;
        while (i--) {
            id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
    };
    // src/createAsyncThunk.ts
    var commonProperties = [
        "name",
        "message",
        "stack",
        "code"
    ];
    var RejectWithValue = /** @class */ (function () {
        function RejectWithValue(payload, meta) {
            this.payload = payload;
            this.meta = meta;
        }
        return RejectWithValue;
    }());
    var FulfillWithMeta = /** @class */ (function () {
        function FulfillWithMeta(payload, meta) {
            this.payload = payload;
            this.meta = meta;
        }
        return FulfillWithMeta;
    }());
    var miniSerializeError = function (value) {
        if (typeof value === "object" && value !== null) {
            var simpleError = {};
            for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
                var property = commonProperties_1[_i];
                if (typeof value[property] === "string") {
                    simpleError[property] = value[property];
                }
            }
            return simpleError;
        }
        return { message: String(value) };
    };
    ((function () {
        function createAsyncThunk2(typePrefix, payloadCreator, options) {
            var fulfilled = createAction(typePrefix + "/fulfilled", function (payload, requestId, arg, meta) { return ({
                payload: payload,
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                    arg: arg,
                    requestId: requestId,
                    requestStatus: "fulfilled"
                })
            }); });
            var pending = createAction(typePrefix + "/pending", function (requestId, arg, meta) { return ({
                payload: void 0,
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                    arg: arg,
                    requestId: requestId,
                    requestStatus: "pending"
                })
            }); });
            var rejected = createAction(typePrefix + "/rejected", function (error, requestId, arg, payload, meta) { return ({
                payload: payload,
                error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                    arg: arg,
                    requestId: requestId,
                    rejectedWithValue: !!payload,
                    requestStatus: "rejected",
                    aborted: (error == null ? void 0 : error.name) === "AbortError",
                    condition: (error == null ? void 0 : error.name) === "ConditionError"
                })
            }); });
            var AC = typeof AbortController !== "undefined" ? AbortController : /** @class */ (function () {
                function class_1() {
                    this.signal = {
                        aborted: false,
                        addEventListener: function () {
                        },
                        dispatchEvent: function () {
                            return false;
                        },
                        onabort: function () {
                        },
                        removeEventListener: function () {
                        },
                        reason: void 0,
                        throwIfAborted: function () {
                        }
                    };
                }
                class_1.prototype.abort = function () {
                };
                return class_1;
            }());
            function actionCreator(arg) {
                return function (dispatch, getState, extra) {
                    var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
                    var abortController = new AC();
                    var abortReason;
                    function abort(reason) {
                        abortReason = reason;
                        abortController.abort();
                    }
                    var promise2 = function () {
                        return __async(this, null, function () {
                            var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
                            return __generator$6(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _c.trys.push([0, 4, , 5]);
                                        conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState: getState, extra: extra });
                                        if (!isThenable(conditionResult)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, conditionResult];
                                    case 1:
                                        conditionResult = _c.sent();
                                        _c.label = 2;
                                    case 2:
                                        if (conditionResult === false || abortController.signal.aborted) {
                                            throw {
                                                name: "ConditionError",
                                                message: "Aborted due to condition callback returning false."
                                            };
                                        }
                                        abortedPromise = new Promise(function (_, reject) { return abortController.signal.addEventListener("abort", function () { return reject({
                                            name: "AbortError",
                                            message: abortReason || "Aborted"
                                        }); }); });
                                        dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId: requestId, arg: arg }, { getState: getState, extra: extra })));
                                        return [4 /*yield*/, Promise.race([
                                                abortedPromise,
                                                Promise.resolve(payloadCreator(arg, {
                                                    dispatch: dispatch,
                                                    getState: getState,
                                                    extra: extra,
                                                    requestId: requestId,
                                                    signal: abortController.signal,
                                                    abort: abort,
                                                    rejectWithValue: function (value, meta) {
                                                        return new RejectWithValue(value, meta);
                                                    },
                                                    fulfillWithValue: function (value, meta) {
                                                        return new FulfillWithMeta(value, meta);
                                                    }
                                                })).then(function (result) {
                                                    if (result instanceof RejectWithValue) {
                                                        throw result;
                                                    }
                                                    if (result instanceof FulfillWithMeta) {
                                                        return fulfilled(result.payload, requestId, arg, result.meta);
                                                    }
                                                    return fulfilled(result, requestId, arg);
                                                })
                                            ])];
                                    case 3:
                                        finalAction = _c.sent();
                                        return [3 /*break*/, 5];
                                    case 4:
                                        err_1 = _c.sent();
                                        finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                                        return [3 /*break*/, 5];
                                    case 5:
                                        skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                                        if (!skipDispatch) {
                                            dispatch(finalAction);
                                        }
                                        return [2 /*return*/, finalAction];
                                }
                            });
                        });
                    }();
                    return Object.assign(promise2, {
                        abort: abort,
                        requestId: requestId,
                        arg: arg,
                        unwrap: function () {
                            return promise2.then(unwrapResult);
                        }
                    });
                };
            }
            return Object.assign(actionCreator, {
                pending: pending,
                rejected: rejected,
                fulfilled: fulfilled,
                typePrefix: typePrefix
            });
        }
        createAsyncThunk2.withTypes = function () { return createAsyncThunk2; };
        return createAsyncThunk2;
    }))();
    function unwrapResult(action) {
        if (action.meta && action.meta.rejectedWithValue) {
            throw action.payload;
        }
        if (action.error) {
            throw action.error;
        }
        return action.payload;
    }
    function isThenable(value) {
        return value !== null && typeof value === "object" && typeof value.then === "function";
    }
    var alm = "listenerMiddleware";
    createAction(alm + "/add");
    createAction(alm + "/removeAll");
    createAction(alm + "/remove");
    var promise;
    typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function (cb) { return (promise || (promise = Promise.resolve())).then(cb).catch(function (err) { return setTimeout(function () {
        throw err;
    }, 0); }); };
    // src/index.ts
    F$3();

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || _typeof$1(argument) === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    /**
     * @name compareAsc
     * @category Common Helpers
     * @summary Compare the two dates and return -1, 0 or 1.
     *
     * @description
     * Compare the two dates and return 1 if the first date is after the second,
     * -1 if the first date is before the second or 0 if dates are equal.
     *
     * @param {Date|Number} dateLeft - the first date to compare
     * @param {Date|Number} dateRight - the second date to compare
     * @returns {Number} the result of the comparison
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Compare 11 February 1987 and 10 July 1989:
     * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
     * //=> -1
     *
     * @example
     * // Sort the array of dates:
     * const result = [
     *   new Date(1995, 6, 2),
     *   new Date(1987, 1, 11),
     *   new Date(1989, 6, 10)
     * ].sort(compareAsc)
     * //=> [
     * //   Wed Feb 11 1987 00:00:00,
     * //   Mon Jul 10 1989 00:00:00,
     * //   Sun Jul 02 1995 00:00:00
     * // ]
     */

    function compareAsc(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var diff = dateLeft.getTime() - dateRight.getTime();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    var _a$3;
    var messagesAdapter = createEntityAdapter({
        selectId: function (message) { return message._id; },
        sortComparer: function (a, b) { return compareAsc(new Date(a.ts), new Date(b.ts)); }
    });
    var initialState$3 = messagesAdapter.getInitialState();
    var messagesSlice = createSlice({
        name: 'messages',
        initialState: initialState$3,
        reducers: {
            addMessages: messagesAdapter.addMany,
            addMessage: messagesAdapter.addOne,
            upsertMessage: messagesAdapter.upsertOne,
            removeAll: messagesAdapter.removeAll,
            removeOne: messagesAdapter.removeOne
        }
    });
    var addMessages = (_a$3 = messagesSlice.actions, _a$3.addMessages); _a$3.addMessage; var upsertMessage = _a$3.upsertMessage, removeAll = _a$3.removeAll, removeOne = _a$3.removeOne;
    var messagesSelectors = messagesAdapter.getSelectors(function (state) { return state.messages; });
    var MessagesSlice = messagesSlice.reducer;

    var _a$2;
    var initialState$2 = {
        user: null,
        isAuthorized: false
    };
    var userSlice = createSlice({
        name: 'user',
        initialState: initialState$2,
        reducers: {
            setUser: function (state, action) {
                state.user = action.payload;
            },
            setAuthorized: function (state, action) {
                state.isAuthorized = action.payload;
            },
        },
    });
    // Action creators are generated for each case reducer function
    var setUser = (_a$2 = userSlice.actions, _a$2.setUser), setAuthorized = _a$2.setAuthorized;
    var UserSlice = userSlice.reducer;

    var _a$1;
    var initialState$1 = {
        room: null,
        rid: null
    };
    var roomSlice = createSlice({
        name: 'room',
        initialState: initialState$1,
        reducers: {
            setRoom: function (state, action) {
                state.room = action.payload;
                state.rid = action.payload._id;
            },
            clearRoom: function (state) {
                state.room = null;
                state.rid = null;
            },
        },
    });
    var setRoom = (_a$1 = roomSlice.actions, _a$1.setRoom), clearRoom = _a$1.clearRoom;
    var RoomSlice = roomSlice.reducer;

    var _a;
    var uploaderAdapter = createEntityAdapter({
        selectId: function (item) { return item.id; },
        sortComparer: function (a, b) { return compareAsc(new Date(a.ts), new Date(b.ts)); }
    });
    var initialState = uploaderAdapter.getInitialState();
    var uploaderSlice = createSlice({
        name: 'uploaders',
        initialState: initialState,
        reducers: {
            addUploaders: uploaderAdapter.addMany,
            addUploader: uploaderAdapter.addOne,
            upsertUploader: uploaderAdapter.upsertOne,
            removeAll: uploaderAdapter.removeAll,
            removeUploader: uploaderAdapter.removeOne,
            updateUploader: uploaderAdapter.updateOne
        }
    });
    (_a = uploaderSlice.actions, _a.addUploaders); _a.addUploader; var upsertUploader = _a.upsertUploader; _a.removeAll; var removeUploader = _a.removeUploader, updateUploader = _a.updateUploader;
    var uploaderSelectors = uploaderAdapter.getSelectors(function (state) { return state.uploaders; });
    var UploaderSlice = uploaderSlice.reducer;

    var store = configureStore({
        reducer: {
            messages: MessagesSlice,
            user: UserSlice,
            room: RoomSlice,
            uploaders: UploaderSlice
        },
    });

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign$6 = function() {
        __assign$6 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$6.apply(this, arguments);
    };

    function __awaiter$5(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$5(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var sdk = {};

    var settings$2 = {};

    Object.defineProperty(settings$2, "__esModule", { value: true });
    // Login settings - LDAP needs to be explicitly enabled
    settings$2.username = "window".ROCKETCHAT_USER || 'bot';
    settings$2.password = "window".ROCKETCHAT_PASSWORD || 'pass';
    settings$2.ldap = ("window".ROCKETCHAT_AUTH === 'ldap');
    // Connection settings - Enable SSL by default if Rocket.Chat URL contains https
    settings$2.host = "window".ROCKETCHAT_URL || 'localhost:3000';
    settings$2.useSsl = ("window".ROCKETCHAT_USE_SSL)
        ? (("window".ROCKETCHAT_USE_SSL || '').toString().toLowerCase() === 'true')
        : (("window".ROCKETCHAT_URL || '').toString().toLowerCase().startsWith('https'));
    settings$2.timeout = 20 * 1000; // 20 seconds
    // Respond settings - reactive callback filters for .respondToMessages
    settings$2.rooms = ("window".ROCKETCHAT_ROOM)
        ? ("window".ROCKETCHAT_ROOM || '').split(',').map(function (room) { return room.trim(); })
        : [];
    settings$2.allPublic = ("window".LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true';
    settings$2.dm = ("window".RESPOND_TO_DM || 'false').toLowerCase() === 'true';
    settings$2.livechat = ("window".RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true';
    settings$2.edited = ("window".RESPOND_TO_EDITED || 'false').toLowerCase() === 'true';
    // Message attribute settings
    settings$2.integrationId = "window".INTEGRATION_ID || 'js.SDK';
    // Cache settings
    settings$2.roomCacheMaxSize = parseInt("window".ROOM_CACHE_SIZE || '10', 10);
    settings$2.roomCacheMaxAge = 1000 * parseInt("window".ROOM_CACHE_MAX_AGE || '300', 10);
    settings$2.dmCacheMaxSize = parseInt("window".DM_ROOM_CACHE_SIZE || '10', 10);
    settings$2.dmCacheMaxAge = 1000 * parseInt("window".DM_ROOM_CACHE_MAX_AGE || '100', 10);
    // Livechat settings
    settings$2.token = "window".LIVECHAT_TOKEN || '';
    settings$2.rid = "window".LIVECHAT_ROOM || '';
    settings$2.department = "window".LIVECHAT_DEPARTMENT || '';

    var Livechat$1 = {};

    var Livechat = {};

    var api$1 = {};

    var log = {};

    /**
     * @module log
     * Basic log handling with ability to override when used within another module.
     */
    var __read$3 = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread$2 = (commonjsGlobal && commonjsGlobal.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$3(arguments[i]));
        return ar;
    };
    Object.defineProperty(log, "__esModule", { value: true });
    /** Temp logging, should override form adapter's log */
    var InternalLog = /** @class */ (function () {
        function InternalLog() {
        }
        InternalLog.prototype.debug = function () {
            // console.log(...args)
        };
        InternalLog.prototype.info = function () {
            // console.log(...args)
        };
        InternalLog.prototype.warning = function () {
            // console.warn(...args)
        };
        InternalLog.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this.warning.apply(this, __spread$2(args));
        };
        InternalLog.prototype.error = function () {
            // console.error(...args)
        };
        return InternalLog;
    }());
    /** Default basic console logging */
    log.logger = new InternalLog();
    /** Substitute logging handler */
    function replaceLog(externalLog) {
        log.logger = externalLog;
    }
    log.replaceLog = replaceLog;
    /** Null all log outputs */
    function silence() {
        replaceLog({
            debug: function () { return null; },
            info: function () { return null; },
            warn: function () { return null; },
            warning: function () { return null; },
            error: function () { return null; }
        });
    }
    log.silence = silence;

    var message = {};

    var __rest$5 = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    Object.defineProperty(message, "__esModule", { value: true });
    /**
     * Rocket.Chat message class.
     * Sets integration param to allow tracing source of automated sends.
     * @param content Accepts message text or a preformed message object
     * @todo Potential for SDK usage that isn't bots, bot prop should be optional?
     */
    var Message$1 = /** @class */ (function () {
        function Message(content, _a) {
            var integrationId = _a.integrationId, others = __rest$5(_a, ["integrationId"]);
            if (typeof content === 'string') {
                Object.assign(this, { msg: content }, others);
            }
            else {
                Object.assign(this, content, others);
            }
            if (integrationId) {
                this.bot = { i: integrationId };
            }
        }
        return Message;
    }());
    message.Message = Message$1;

    var lib$1 = {};

    function EventEmitter$1() {
        this._listeners = {};
    }

    EventEmitter$1.prototype.on = function _on(type, listener) {
        if (!Array.isArray(this._listeners[type])) {
            this._listeners[type] = [];
        }

        if (this._listeners[type].indexOf(listener) === -1) {
            this._listeners[type].push(listener);
        }

        return this;
    };

    EventEmitter$1.prototype.once = function _once(type, listener) {
        var self = this;

        function __once() {
            for (var args = [], i = 0; i < arguments.length; i += 1) {
                args[i] = arguments[i];
            }

            self.off(type, __once);
            listener.apply(self, args);
        }

        __once.listener = listener;

        return this.on(type, __once);
    };

    EventEmitter$1.prototype.off = function _off(type, listener) {
        if (!Array.isArray(this._listeners[type])) {
            return this;
        }

        if (typeof listener === 'undefined') {
            this._listeners[type] = [];
            return this;
        }

        var index = this._listeners[type].indexOf(listener);

        if (index === -1) {
            for (var i = 0; i < this._listeners[type].length; i += 1) {
                if (this._listeners[type][i].listener === listener) {
                    index = i;
                    break;
                }
            }
        }

        this._listeners[type].splice(index, 1);
        return this;
    };

    EventEmitter$1.prototype.emit = function _emit(type) {
        if (!Array.isArray(this._listeners[type])) {
            return this;
        }

        for (var args = [], i = 1; i < arguments.length; i += 1) {
            args[i - 1] = arguments[i];
        }

        this._listeners[type].forEach(function __emit(listener) {
            listener.apply(this, args);
        }, this);

        return this;
    };

    lib$1.EventEmitter = EventEmitter$1;

    (function (exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var log_1 = log;
    var message_1 = message;
    var tiny_events_1 = lib$1;
    var Client = /** @class */ (function () {
        function Client(_a) {
            var _b = _a.host, host = _b === void 0 ? 'http://localhost:3000' : _b;
            this._headers = {};
            this.host = host;
        }
        Object.defineProperty(Client.prototype, "headers", {
            get: function () {
                return __assign({ 'Content-Type': 'application/json' }, this._headers);
            },
            set: function (obj) {
                this._headers = obj;
            },
            enumerable: true,
            configurable: true
        });
        Client.prototype.getHeaders = function (options) {
            return options && options.customHeaders ?
                options.customHeaders :
                this.headers;
        };
        Client.prototype.getBody = function (data) {
            return data instanceof FormData ?
                data :
                JSON.stringify(data);
        };
        Client.prototype.get = function (url, data, options) {
            return fetch(this.host + "/api/v1/" + encodeURI(url) + "?" + this.getParams(data), {
                method: 'GET',
                headers: this.getHeaders(options)
            }).then(this.handle);
        };
        Client.prototype.post = function (url, data, options) {
            return fetch(this.host + "/api/v1/" + encodeURI(url), {
                method: 'POST',
                body: this.getBody(data),
                headers: this.getHeaders(options)
            }).then(this.handle);
        };
        Client.prototype.put = function (url, data, options) {
            return fetch(this.host + "/api/v1/" + encodeURI(url), {
                method: 'PUT',
                body: this.getBody(data),
                headers: this.getHeaders(options)
            }).then(this.handle);
        };
        Client.prototype.delete = function (url, data, options) {
            return fetch(this.host + "/api/v1/" + encodeURI(url), {
                method: 'DELETE',
                body: this.getBody(data),
                headers: this.getHeaders(options)
            }).then(this.handle);
        };
        Client.prototype.handle = function (r) {
            return __awaiter(this, void 0, void 0, function () {
                var status, data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            status = r.status;
                            return [4 /*yield*/, r.json()];
                        case 1:
                            data = _a.sent();
                            return [2 /*return*/, { status: status, data: data }];
                    }
                });
            });
        };
        Client.prototype.getParams = function (data) {
            return Object.keys(data).map(function (k) {
                return encodeURIComponent(k) + '=' + (typeof data[k] === 'object' ? encodeURIComponent(JSON.stringify(data[k])) : encodeURIComponent(data[k]));
            }).join('&');
        };
        return Client;
    }());
    exports.regExpSuccess = /(?!([45][0-9][0-9]))\d{3}/;
    /**
        * @module API
        * Provides a base client for handling requests with generic Rocket.Chat's REST API
        */
    var Api = /** @class */ (function (_super) {
        __extends(Api, _super);
        function Api(_a) {
            var client = _a.client, host = _a.host, _b = _a.logger; _b === void 0 ? log_1.logger : _b;
            var _this = _super.call(this) || this;
            _this.userId = '';
            _this.currentLogin = null;
            /**
                * Do a request to an API endpoint.
                * If it needs a token, login first (with defaults) to set auth headers.
                * @param method   Request method GET | POST | PUT | DEL
                * @param endpoint The API endpoint (including version) e.g. `chat.update`
                * @param data     Payload for POST request to endpoint
                * @param auth     Require auth headers for endpoint, default true
                * @param ignore   Allows certain matching error messages to not count as errors
                */
            _this.request = function (method, endpoint, data, auth, ignore, options) {
                if (data === void 0) { data = {}; }
                if (auth === void 0) { auth = true; }
                return __awaiter(_this, void 0, void 0, function () {
                    var result, _a, hasDataInsideResult, err_1;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                this.logger && this.logger.debug("[API] " + method + " " + endpoint + ": " + JSON.stringify(data));
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 11, , 12]);
                                if (auth && !this.loggedIn()) {
                                    throw new Error('');
                                }
                                result = void 0;
                                _a = method;
                                switch (_a) {
                                    case 'GET': return [3 /*break*/, 2];
                                    case 'PUT': return [3 /*break*/, 4];
                                    case 'DELETE': return [3 /*break*/, 6];
                                    case 'POST': return [3 /*break*/, 8];
                                }
                                return [3 /*break*/, 8];
                            case 2: return [4 /*yield*/, this.client.get(endpoint, data, options)];
                            case 3:
                                result = _b.sent();
                                return [3 /*break*/, 10];
                            case 4: return [4 /*yield*/, this.client.put(endpoint, data, options)];
                            case 5:
                                result = _b.sent();
                                return [3 /*break*/, 10];
                            case 6: return [4 /*yield*/, this.client.delete(endpoint, data, options)];
                            case 7:
                                result = _b.sent();
                                return [3 /*break*/, 10];
                            case 8: return [4 /*yield*/, this.client.post(endpoint, data, options)];
                            case 9:
                                result = _b.sent();
                                return [3 /*break*/, 10];
                            case 10:
                                if (!result)
                                    throw new Error("API " + method + " " + endpoint + " result undefined");
                                if (!this.success(result, ignore))
                                    throw result;
                                this.logger && this.logger.debug("[API] " + method + " " + endpoint + " result " + result.status);
                                hasDataInsideResult = result && !result.data;
                                return [2 /*return*/, (method === 'DELETE') && hasDataInsideResult ? result : result.data];
                            case 11:
                                err_1 = _b.sent();
                                this.logger && this.logger.error("[API] POST error(" + endpoint + "): " + JSON.stringify(err_1));
                                throw err_1;
                            case 12: return [2 /*return*/];
                        }
                    });
                });
            };
            /** Do a POST request to an API endpoint. */
            _this.post = function (endpoint, data, auth, ignore, options) {
                if (options === void 0) { options = {}; }
                return _this.request('POST', endpoint, data, auth, ignore, options);
            };
            /** Do a GET request to an API endpoint. */
            _this.get = function (endpoint, data, auth, ignore, options) {
                if (options === void 0) { options = {}; }
                return _this.request('GET', endpoint, data, auth, ignore, options);
            };
            /** Do a PUT request to an API endpoint. */
            _this.put = function (endpoint, data, auth, ignore, options) {
                if (options === void 0) { options = {}; }
                return _this.request('PUT', endpoint, data, auth, ignore, options);
            };
            /** Do a DELETE request to an API endpoint. */
            _this.del = function (endpoint, data, auth, ignore, options) {
                if (options === void 0) { options = {}; }
                return _this.request('DELETE', endpoint, data, auth, ignore, options);
            };
            _this.client = client || new Client({ host: host });
            _this.logger = log_1.logger;
            return _this;
        }
        Object.defineProperty(Api.prototype, "username", {
            get: function () {
                return this.currentLogin && this.currentLogin.username;
            },
            enumerable: true,
            configurable: true
        });
        Api.prototype.loggedIn = function () {
            return Object.keys(this.currentLogin || {}).every(function (e) { return e; });
        };
        /** Check result data for success, allowing override to ignore some errors */
        Api.prototype.success = function (result, ignore) {
            return (typeof result.status === 'undefined' ||
                (result.status && exports.regExpSuccess.test(result.status)) ||
                (result.status && ignore && ignore.test(result.status))) ? true : false;
        };
        Api.prototype.login = function (credentials, args) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.post('login', __assign({}, credentials, args))];
                        case 1:
                            data = (_a.sent()).data;
                            this.userId = data.userId;
                            this.currentLogin = {
                                username: data.me.username,
                                userId: data.userId,
                                authToken: data.authToken,
                                result: data
                            };
                            this.client.headers = {
                                'X-Auth-Token': data.authToken,
                                'X-User-Id': data.userId
                            };
                            return [2 /*return*/, data];
                    }
                });
            });
        };
        Api.prototype.logout = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.currentLogin) {
                                return [2 /*return*/, null];
                            }
                            return [4 /*yield*/, this.post('logout', {}, true)];
                        case 1:
                            result = _a.sent();
                            this.userId = '';
                            this.currentLogin = null;
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Structure message content, optionally addressing to room ID.
         * Accepts message text string or a structured message object.
         */
        Api.prototype.prepareMessage = function (content, rid, args) {
            return new message_1.Message(content, __assign({ rid: rid, roomId: rid }, args));
        };
        return Api;
    }(tiny_events_1.EventEmitter));
    exports.default = Api;

    }(api$1));

    /**
     * @module ApiLivechat
     * Provides a client for making requests with Livechat Rocket.Chat's REST API
     */
    var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$5 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$5 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$5.apply(this, arguments);
    };
    var __awaiter$4 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$4 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(Livechat, "__esModule", { value: true });
    var api_1 = __importDefault$5(api$1);
    var ApiLivechat = /** @class */ (function (_super) {
        __extends$5(ApiLivechat, _super);
        function ApiLivechat() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.credentials = {};
            return _this;
        }
        ApiLivechat.prototype.login = function (guest) { return this.grantVisitor(guest); };
        ApiLivechat.prototype.config = function (params) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get('livechat/config', params, false)];
                    case 1: return [2 /*return*/, (_a.sent()).config];
                }
            }); });
        };
        ApiLivechat.prototype.room = function (params) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get('livechat/room', __assign$5({ token: this.credentials.token }, params), false)];
                    case 1: return [2 /*return*/, (_a.sent()).room];
                }
            }); });
        };
        ApiLivechat.prototype.closeChat = function (_a) {
            var rid = _a.rid;
            return this.post('livechat/room.close', { rid: rid, token: this.credentials.token }, false);
        };
        ApiLivechat.prototype.shareScreen = function (_a) {
            var rid = _a.rid, messageType = _a.messageType;
            return this.post('livechat/room.shareScreen', { rid: rid, token: this.credentials.token, messageType: messageType }, false);
        };
        ApiLivechat.prototype.transferChat = function (_a) {
            var rid = _a.rid, department = _a.department;
            return (this.post('livechat/room.transfer', { rid: rid, token: this.credentials.token, department: department }, false));
        };
        ApiLivechat.prototype.chatSurvey = function (survey) { return (this.post('livechat/room.survey', { rid: survey.rid, token: this.credentials.token, data: survey.data }, false)); };
        ApiLivechat.prototype.visitor = function () { return this.get("livechat/visitor/" + this.credentials.token); };
        ApiLivechat.prototype.grantVisitor = function (guest) {
            return __awaiter$4(this, void 0, void 0, function () {
                var visitor;
                return __generator$4(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.post('livechat/visitor', guest, false)];
                        case 1:
                            visitor = (_a.sent()).visitor;
                            this.credentials = {
                                token: visitor.token
                            };
                            return [2 /*return*/, visitor];
                    }
                });
            });
        };
        ApiLivechat.prototype.deleteVisitor = function () {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.del("livechat/visitor/" + this.credentials.token)];
                    case 1: return [2 /*return*/, (_a.sent()).visitor];
                }
            }); });
        };
        ApiLivechat.prototype.updateVisitorStatus = function (status) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post("livechat/visitor.status", { token: this.credentials.token, status: status })];
                    case 1: return [2 /*return*/, (_a.sent()).status];
                }
            }); });
        };
        ApiLivechat.prototype.updateCallStatus = function (callStatus, rid, callId) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post("livechat/visitor.callStatus", { token: this.credentials.token, callStatus: callStatus, rid: rid, callId: callId })];
                    case 1: return [2 /*return*/, (_a.sent()).callStatus];
                }
            }); });
        };
        ApiLivechat.prototype.nextAgent = function (department) {
            if (department === void 0) { department = ''; }
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get("livechat/agent.next/" + this.credentials.token, { department: department })];
                    case 1: return [2 /*return*/, (_a.sent()).agent];
                }
            }); });
        };
        ApiLivechat.prototype.agent = function (_a) {
            var rid = _a.rid;
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.get("livechat/agent.info/" + rid + "/" + this.credentials.token)];
                    case 1: return [2 /*return*/, (_b.sent()).agent];
                }
            }); });
        };
        ApiLivechat.prototype.message = function (id, params) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get("livechat/message/" + id, __assign$5({ token: this.credentials.token }, params))];
                    case 1: return [2 /*return*/, (_a.sent()).message];
                }
            }); });
        };
        ApiLivechat.prototype.sendMessage = function (message) { return (this.post('livechat/message', __assign$5({}, message, { token: this.credentials.token }), false)); };
        ApiLivechat.prototype.editMessage = function (id, message) { return (this.put("livechat/message/" + id, message, false)); };
        ApiLivechat.prototype.deleteMessage = function (id, _a) {
            var rid = _a.rid;
            return (this.del("livechat/message/" + id, { rid: rid, token: this.credentials.token }, false));
        };
        ApiLivechat.prototype.loadMessages = function (rid, params) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get("livechat/messages.history/" + rid, __assign$5({}, params, { token: this.credentials.token }), false)];
                    case 1: return [2 /*return*/, (_a.sent()).messages];
                }
            }); });
        };
        ApiLivechat.prototype.sendOfflineMessage = function (message) {
            return __awaiter$4(this, void 0, void 0, function () { return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('livechat/offline.message', __assign$5({}, message), false)];
                    case 1: return [2 /*return*/, (_a.sent()).message];
                }
            }); });
        };
        ApiLivechat.prototype.sendVisitorNavigation = function (page) { return (this.post('livechat/page.visited', __assign$5({}, page), false)); };
        ApiLivechat.prototype.requestTranscript = function (email, _a) {
            var rid = _a.rid;
            return (this.post('livechat/transcript', { token: this.credentials.token, rid: rid, email: email }, false));
        };
        ApiLivechat.prototype.videoCall = function (_a) {
            var rid = _a.rid;
            return this.get("livechat/video.call/" + this.credentials.token, { rid: rid }, false);
        };
        ApiLivechat.prototype.sendCustomField = function (field) { return this.post('livechat/custom.field', field, false); };
        ApiLivechat.prototype.sendCustomFields = function (fields) { return this.post('livechat/custom.fields', fields, false); };
        ApiLivechat.prototype.uploadFile = function (params) {
            var formData = new FormData();
            var headersNeededForUpload = {
                'x-visitor-token': this.credentials.token
            };
            formData.append('file', params.file);
            return this.post("livechat/upload/" + params.rid, formData, false, undefined, { customHeaders: headersNeededForUpload });
        };
        return ApiLivechat;
    }(api_1.default));
    Livechat.default = ApiLivechat;

    var drivers = {};

    (function (exports) {
    /**
     * @module Socket
     * Provides high-level helpers for DDP connection, method calls, subscriptions.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    (function (Protocols) {
        Protocols["MQTT"] = "mqtt";
        Protocols["DDP"] = "ddp";
    })(exports.Protocols || (exports.Protocols = {}));

    }(drivers));

    var ddp = {};

    var browser = WebSocket;

    var interfaces = {};

    Object.defineProperty(interfaces, "__esModule", { value: true });
    /** Password login credential type guard */
    function isLoginPass(params) {
        return (params.user &&
            params.password &&
            params.user.username !== undefined &&
            params.password.digest !== undefined);
    }
    interfaces.isLoginPass = isLoginPass;
    /** Password login credential type guard */
    function isLoginOAuth(params) {
        return (params.oath &&
            params.credentialToken !== undefined &&
            params.credentialSecret !== undefined);
    }
    interfaces.isLoginOAuth = isLoginOAuth;
    /** Password login credential type guard */
    function isLoginAuthenticated(params) {
        return (params.resume !== undefined);
    }
    interfaces.isLoginAuthenticated = isLoginAuthenticated;
    /** Password login credential type guard */
    function isLoginResult(params) {
        return (params.token !== undefined);
    }
    interfaces.isLoginResult = isLoginResult;

    var util = {};

    Object.defineProperty(util, "__esModule", { value: true });
    /** Delay invocation of a function until some time after it was last called */
    function debounce$1(func, waitMilliseconds, immediate) {
        if (waitMilliseconds === void 0) { waitMilliseconds = 100; }
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var self = this;
            var doLater = function () {
                timeout = undefined;
                if (!immediate)
                    func.apply(self, args);
            };
            var callNow = immediate && timeout === undefined;
            if (timeout)
                clearTimeout(timeout);
            timeout = setTimeout(doLater, waitMilliseconds);
            if (callNow)
                func.apply(self, args);
        };
    }
    util.debounce = debounce$1;
    /** Convert a http/s protocol address to a websocket URL */
    function hostToWS(host, ssl) {
        if (ssl === void 0) { ssl = false; }
        host = host.replace(/^(https?:\/\/)?/, '');
        return "ws" + (ssl ? 's' : '') + "://" + host;
    }
    util.hostToWS = hostToWS;

    var sha256 = {exports: {}};

    /**
     * [js-sha256]{@link https://github.com/emn178/js-sha256}
     *
     * @version 0.9.0
     * @author Chen, Yi-Cyuan [emn178@gmail.com]
     * @copyright Chen, Yi-Cyuan 2014-2017
     * @license MIT
     */

    (function (module) {
    /*jslint bitwise: true */
    (function () {

      var ERROR = 'input is invalid type';
      var WINDOW = typeof window === 'object';
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === 'object';
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && 'object' === 'object' && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
      var HEX_CHARS = '0123456789abcdef'.split('');
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
      ];
      var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

      var blocks = [];

      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function (obj) {
          return Object.prototype.toString.call(obj) === '[object Array]';
        };
      }

      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function (obj) {
          return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }

      var createOutputMethod = function (outputType, is224) {
        return function (message) {
          return new Sha256(is224, true).update(message)[outputType]();
        };
      };

      var createMethod = function (is224) {
        var method = createOutputMethod('hex', is224);
        if (NODE_JS) {
          method = nodeWrap(method, is224);
        }
        method.create = function () {
          return new Sha256(is224);
        };
        method.update = function (message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type, is224);
        }
        return method;
      };

      var nodeWrap = function (method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? 'sha224' : 'sha256';
        var nodeMethod = function (message) {
          if (typeof message === 'string') {
            return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
          } else {
            if (message === null || message === undefined) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) ||
            message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };

      var createHmacOutputMethod = function (outputType, is224) {
        return function (key, message) {
          return new HmacSha256(key, is224, true).update(message)[outputType]();
        };
      };

      var createHmacMethod = function (is224) {
        var method = createHmacOutputMethod('hex', is224);
        method.create = function (key) {
          return new HmacSha256(key, is224);
        };
        method.update = function (key, message) {
          return method.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type, is224);
        }
        return method;
      };

      function Sha256(is224, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
            blocks[4] = blocks[5] = blocks[6] = blocks[7] =
            blocks[8] = blocks[9] = blocks[10] = blocks[11] =
            blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }

        if (is224) {
          this.h0 = 0xc1059ed8;
          this.h1 = 0x367cd507;
          this.h2 = 0x3070dd17;
          this.h3 = 0xf70e5939;
          this.h4 = 0xffc00b31;
          this.h5 = 0x68581511;
          this.h6 = 0x64f98fa7;
          this.h7 = 0xbefa4fa4;
        } else { // 256
          this.h0 = 0x6a09e667;
          this.h1 = 0xbb67ae85;
          this.h2 = 0x3c6ef372;
          this.h3 = 0xa54ff53a;
          this.h4 = 0x510e527f;
          this.h5 = 0x9b05688c;
          this.h6 = 0x1f83d9ab;
          this.h7 = 0x5be0cd19;
        }

        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is224;
      }

      Sha256.prototype.update = function (message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== 'string') {
          if (type === 'object') {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks = this.blocks;

        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks[0] = this.block;
            blocks[16] = blocks[1] = blocks[2] = blocks[3] =
              blocks[4] = blocks[5] = blocks[6] = blocks[7] =
              blocks[8] = blocks[9] = blocks[10] = blocks[11] =
              blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          }

          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 0x80) {
                blocks[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 0x800) {
                blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
              } else if (code < 0xd800 || code >= 0xe000) {
                blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
              } else {
                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
              }
            }
          }

          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };

      Sha256.prototype.finalize = function () {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i = this.lastByteIndex;
        blocks[16] = this.block;
        blocks[i >> 2] |= EXTRA[i & 3];
        this.block = blocks[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks[0] = this.block;
          blocks[16] = blocks[1] = blocks[2] = blocks[3] =
            blocks[4] = blocks[5] = blocks[6] = blocks[7] =
            blocks[8] = blocks[9] = blocks[10] = blocks[11] =
            blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }
        blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks[15] = this.bytes << 3;
        this.hash();
      };

      Sha256.prototype.hash = function () {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
          h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

        for (j = 16; j < 64; ++j) {
          // rightrotate
          t1 = blocks[j - 15];
          s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
          t1 = blocks[j - 2];
          s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
          blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
        }

        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
            s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
            ab = a & b;
            maj = ab ^ (a & c) ^ bc;
            ch = (e & f) ^ (~e & g);
            t1 = h + s1 + ch + K[j] + blocks[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
          s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
          da = d & a;
          maj = da ^ (d & b) ^ ab;
          ch = (h & e) ^ (~h & f);
          t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
          s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
          cd = c & d;
          maj = cd ^ (c & a) ^ da;
          ch = (g & h) ^ (~g & e);
          t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
          t2 = s0 + maj;
          f = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
          s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
          bc = b & c;
          maj = bc ^ (b & d) ^ cd;
          ch = (f & g) ^ (~f & h);
          t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }

        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };

      Sha256.prototype.hex = function () {
        this.finalize();

        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
          h6 = this.h6, h7 = this.h7;

        var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
          HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
          HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
          HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
          HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
          HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
          HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
          HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
          HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
          HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
          HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
          HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
          HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
          HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
          HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
          HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
          HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
          HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
          HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
          HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
          HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
          HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
          HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
          HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
          HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
          HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
          HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
          HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
        if (!this.is224) {
          hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
            HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
            HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
            HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
        }
        return hex;
      };

      Sha256.prototype.toString = Sha256.prototype.hex;

      Sha256.prototype.digest = function () {
        this.finalize();

        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
          h6 = this.h6, h7 = this.h7;

        var arr = [
          (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
          (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
          (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
          (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
          (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
          (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
          (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
        ];
        if (!this.is224) {
          arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
        }
        return arr;
      };

      Sha256.prototype.array = Sha256.prototype.digest;

      Sha256.prototype.arrayBuffer = function () {
        this.finalize();

        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };

      function HmacSha256(key, is224, sharedMemory) {
        var i, type = typeof key;
        if (type === 'string') {
          var bytes = [], length = key.length, index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 0x80) {
              bytes[index++] = code;
            } else if (code < 0x800) {
              bytes[index++] = (0xc0 | (code >> 6));
              bytes[index++] = (0x80 | (code & 0x3f));
            } else if (code < 0xd800 || code >= 0xe000) {
              bytes[index++] = (0xe0 | (code >> 12));
              bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
              bytes[index++] = (0x80 | (code & 0x3f));
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
              bytes[index++] = (0xf0 | (code >> 18));
              bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
              bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
              bytes[index++] = (0x80 | (code & 0x3f));
            }
          }
          key = bytes;
        } else {
          if (type === 'object') {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }

        if (key.length > 64) {
          key = (new Sha256(is224, true)).update(key).array();
        }

        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 0x5c ^ b;
          iKeyPad[i] = 0x36 ^ b;
        }

        Sha256.call(this, is224, sharedMemory);

        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();

      HmacSha256.prototype.finalize = function () {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };

      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);

      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
      }
    })();
    }(sha256));

    /**
     * @module DDPDriver
     * Handles low-level websocket ddp connections and event subscriptions
     */
    var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$4 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$4 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$4.apply(this, arguments);
    };
    var __awaiter$3 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$3 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$4 = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var __read$2 = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread$1 = (commonjsGlobal && commonjsGlobal.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$2(arguments[i]));
        return ar;
    };
    var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(ddp, "__esModule", { value: true });
    var universal_websocket_client_1 = __importDefault$4(browser);
    var tiny_events_1 = lib$1;
    var log_1$3 = log;
    tiny_events_1.EventEmitter.prototype.removeAllListeners = function (event) {
        if (event) {
            this._listeners[event] = [];
        }
        else {
            this._listeners = {};
        }
        return [];
    };
    var interfaces_1 = interfaces;
    var util_1 = util;
    var js_sha256_1 = sha256.exports;
    /** Websocket handler class, manages connections and subscriptions by DDP */
    var Socket = /** @class */ (function (_super) {
        __extends$4(Socket, _super);
        /** Create a websocket handler */
        function Socket(options, resume) {
            if (resume === void 0) { resume = null; }
            var _this = _super.call(this) || this;
            _this.resume = resume;
            _this.sent = 0;
            _this.lastPing = Date.now();
            _this.subscriptions = {};
            _this.handlers = [];
            /**
             * Open websocket connection, with optional retry interval.
             * Stores connection, setting up handlers for open/close/message events.
             * Resumes login if given token.
             */
            _this.open = function (ms) {
                if (ms === void 0) { ms = _this.config.reopen; }
                return new Promise(function (resolve, reject) { return __awaiter$3(_this, void 0, void 0, function () {
                    var connection;
                    var _this = this;
                    return __generator$3(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.lastPing = Date.now();
                                return [4 /*yield*/, this.close()];
                            case 1:
                                _a.sent();
                                if (this.reopenInterval)
                                    clearInterval(this.reopenInterval);
                                this.reopenInterval = setInterval(function () {
                                    return !_this.alive() && _this.reopen();
                                }, ms);
                                try {
                                    connection = new universal_websocket_client_1.default(this.host);
                                    connection.onerror = reject;
                                }
                                catch (err) {
                                    this.logger.error(err);
                                    return [2 /*return*/, reject(err)];
                                }
                                this.connection = connection;
                                this.connection.onmessage = this.onMessage.bind(this);
                                this.connection.onclose = this.onClose.bind(this);
                                this.connection.onopen = this.onOpen.bind(this, resolve);
                                return [2 /*return*/];
                        }
                    });
                }); });
            };
            /** Send handshake message to confirm connection, start pinging. */
            _this.onOpen = function (callback) { return __awaiter$3(_this, void 0, void 0, function () {
                var connected;
                var _this = this;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.send({
                                msg: 'connect',
                                version: '1',
                                support: ['1', 'pre2', 'pre1']
                            })];
                        case 1:
                            connected = _a.sent();
                            this.session = connected.session;
                            this.ping().catch(function (err) { return _this.logger.error("[ddp] Unable to ping server: " + err.message); });
                            this.emit('open');
                            if (!this.resume) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.login(this.resume)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [2 /*return*/, callback(this.connection)];
                    }
                });
            }); };
            /** Emit close event so it can be used for promise resolve in close() */
            _this.onClose = function (e) {
                try {
                    _this.emit('close', e);
                    if (e.code !== 1000) {
                        return _this.reopen();
                    }
                    else {
                        if (_this.reopenInterval)
                            clearInterval(_this.reopenInterval);
                        _this.openTimeout && clearTimeout(_this.openTimeout);
                        _this.pingTimeout && clearTimeout(_this.pingTimeout);
                        delete _this.connection;
                    }
                    _this.logger.info("[ddp] Close (" + e.code + ") " + e.reason);
                }
                catch (error) {
                    _this.logger.error(error);
                }
            };
            /**
             * Find and call matching handlers for incoming message data.
             * Handlers match on collection, id and/or msg attribute in that order.
             * Any matched handlers are removed once called.
             * All collection events are emitted with their `msg` as the event name.
             */
            _this.onMessage = function (e) {
                _this.lastPing = Date.now();
                void _this.ping();
                var data = (e.data) ? JSON.parse(e.data) : undefined;
                _this.logger.debug(data); // 👈  very useful for debugging missing responses
                if (!data)
                    return _this.logger.error("[ddp] JSON parse error: " + e.message);
                _this.logger.debug("[ddp] messages received: " + e.data);
                if (data.collection)
                    _this.emit(data.collection, data);
                if (data.msg)
                    _this.emit(data.msg, data);
            };
            /** Disconnect the DDP from server and clear all subscriptions. */
            _this.close = function () { return __awaiter$3(_this, void 0, void 0, function () {
                var _this = this;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.connected) return [3 /*break*/, 2];
                            this.unsubscribeAll().catch(function (e) { return _this.logger.debug(e); });
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    if (_this.connection) {
                                        _this.once('close', resolve);
                                        _this.connection.close(1000, 'disconnect');
                                        return;
                                    }
                                })
                                    .catch(this.logger.error)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/, Promise.resolve()];
                    }
                });
            }); };
            /** Clear connection and try to connect again. */
            _this.reopen = function () { return __awaiter$3(_this, void 0, void 0, function () {
                var _this = this;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.openTimeout)
                                return [2 /*return*/];
                            return [4 /*yield*/, this.close()];
                        case 1:
                            _a.sent();
                            this.openTimeout = setTimeout(function () { return __awaiter$3(_this, void 0, void 0, function () {
                                var _this = this;
                                return __generator$3(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            delete this.openTimeout;
                                            return [4 /*yield*/, this.open()
                                                    .catch(function (err) { return _this.logger.error("[ddp] Reopen error: " + err.message); })];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, this.config.reopen);
                            return [2 /*return*/];
                    }
                });
            }); };
            /**
             * Send an object to the server via Socket. Adds handler to collection to
             * allow awaiting response matching an expected object. Most responses are
             * identified by their message event name and the ID they were sent with, but
             * some responses don't return the ID fallback to just matching on event name.
             * Data often includes an error attribute if something went wrong, but certain
             * types of calls send back a different `msg` value instead, e.g. `nosub`.
             * @param obj       Object to be sent
             * @param msg       The `data.msg` value to wait for in response
             * @param errorMsg  An alternate `data.msg` value indicating an error response
             */
            _this.send = function (obj) { return __awaiter$3(_this, void 0, void 0, function () {
                var _this = this;
                return __generator$3(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            if (!_this.connection)
                                throw new Error('[ddp] sending without open connection');
                            var id = obj.id || "ddp-" + _this.sent;
                            _this.sent += 1;
                            var data = __assign$4({}, obj, (/connect|ping|pong/.test(obj.msg) ? {} : { id: id }));
                            var stringdata = JSON.stringify(data);
                            _this.logger.debug("[ddp] sending message: " + stringdata);
                            _this.connection.send(stringdata);
                            _this.once('disconnected', reject);
                            var listener = (data.msg === 'ping' && 'pong') || (data.msg === 'connect' && 'connected') || data.id;
                            if (!listener) {
                                return resolve();
                            }
                            _this.once(listener, function (result) {
                                _this.off('disconnect', reject);
                                return (result.error ? reject(result.error) : resolve(__assign$4({}, (/connect|ping|pong/.test(obj.msg) ? {} : { id: id }), result)));
                            });
                        })];
                });
            }); };
            /** Send ping, record time, re-open if nothing comes back, repeat */
            _this.ping = function () { return __awaiter$3(_this, void 0, void 0, function () {
                var _this = this;
                return __generator$3(this, function (_a) {
                    this.pingTimeout && clearTimeout(this.pingTimeout);
                    this.pingTimeout = setTimeout(function () {
                        _this.send({ msg: 'ping' })
                            .then(function () {
                            return _this.ping();
                        })
                            .catch(function () { return _this.reopen(); });
                    }, this.config.ping);
                    return [2 /*return*/];
                });
            }); };
            /** Check if ping-pong to server is within tolerance of 1 missed ping */
            _this.alive = function () {
                if (!_this.lastPing)
                    return false;
                return (Date.now() - _this.lastPing <= _this.config.ping * 2);
            };
            /**
             * Calls a method on the server and returns a promise resolved
             * with the result of the method.
             * @param method    The name of the method to be called
             * @param params    An array with the parameters to be sent
             */
            _this.call = function (method) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return __awaiter$3(_this, void 0, void 0, function () {
                    var response;
                    var _this = this;
                    return __generator$3(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.send({ msg: 'method', method: method, params: params })
                                    .catch(function (err) {
                                    _this.logger.error("[ddp] Call error: " + err.message);
                                    throw err;
                                })];
                            case 1:
                                response = _a.sent();
                                return [2 /*return*/, (response.result) ? response.result : response];
                        }
                    });
                });
            };
            /**
             * Login to server and resubscribe to all subs, resolve with user information.
             * @param credentials User credentials (username/password, oauth or token)
             */
            _this.login = function (credentials) { return __awaiter$3(_this, void 0, void 0, function () {
                var params, _a;
                return __generator$3(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            params = this.loginParams(credentials);
                            _a = this;
                            return [4 /*yield*/, this.call('login', params)];
                        case 1:
                            _a.resume = (_b.sent());
                            return [4 /*yield*/, this.subscribeAll()];
                        case 2:
                            _b.sent();
                            this.emit('login', this.resume);
                            return [2 /*return*/, this.resume];
                    }
                });
            }); };
            /** Take variety of login credentials object types for accepted params */
            _this.loginParams = function (credentials) {
                if (interfaces_1.isLoginPass(credentials) ||
                    interfaces_1.isLoginOAuth(credentials) ||
                    interfaces_1.isLoginAuthenticated(credentials)) {
                    return credentials;
                }
                if (interfaces_1.isLoginResult(credentials)) {
                    var params_1 = {
                        resume: credentials.token
                    };
                    return params_1;
                }
                var params = {
                    user: { username: credentials.username },
                    password: {
                        digest: js_sha256_1.sha256(credentials.password),
                        algorithm: 'sha-256'
                    }
                };
                return params;
            };
            /** Logout the current User from the server via Socket. */
            _this.logout = function () {
                _this.resume = null;
                return _this.unsubscribeAll()
                    .then(function () { return _this.call('logout'); });
            };
            /** Register a callback to trigger on message events in subscription */
            _this.onEvent = function (id, callback) {
                _this.on(id, callback);
            };
            /**
             * Subscribe to a stream on server via socket and returns a promise resolved
             * with the subscription object when the subscription is ready.
             * @param name      Stream name to subscribe to
             * @param params    Params sent to the subscription request
             */
            _this.subscribe = function (name, params, callback) {
                _this.logger.info("[ddp] Subscribe to " + name + ", param: " + JSON.stringify(params));
                return _this.send({ msg: 'sub', name: name, params: params })
                    .then(function (result) {
                    var id = (result.subs) ? result.subs[0] : undefined;
                    var unsubscribe = _this.unsubscribe.bind(_this, id);
                    var onEvent = _this.onEvent.bind(_this, name);
                    var subscription = { id: id, name: name, params: params, unsubscribe: unsubscribe, onEvent: onEvent };
                    if (callback)
                        subscription.onEvent(callback);
                    _this.subscriptions[id] = subscription;
                    return subscription;
                })
                    .catch(function (err) {
                    _this.logger.error("[ddp] Subscribe error: " + err.message);
                    throw err;
                });
            };
            /** Subscribe to all pre-configured streams (e.g. on login resume) */
            _this.subscribeAll = function () {
                var subscriptions = Object.keys(_this.subscriptions || {}).map(function (key) {
                    var _a = _this.subscriptions[key], name = _a.name, params = _a.params;
                    return _this.subscribe(name, params);
                });
                return Promise.all(subscriptions);
            };
            /** Unsubscribe to server stream, resolve with unsubscribe request result */
            _this.unsubscribe = function (id) {
                if (!_this.subscriptions[id])
                    return Promise.reject(id);
                delete _this.subscriptions[id];
                return _this.send({ msg: 'unsub', id: id })
                    .then(function (data) { return data.result || data.subs; })
                    .catch(function (err) {
                    if (!err.msg && err.msg !== 'nosub') {
                        _this.logger.error("[ddp] Unsubscribe error: " + err.message);
                        throw err;
                    }
                });
            };
            /** Unsubscribe from all active subscriptions and reset collection */
            _this.unsubscribeAll = function () {
                var unsubAll = Object.keys(_this.subscriptions).map(function (id) {
                    return _this.subscriptions[id].unsubscribe();
                });
                return Promise.all(unsubAll)
                    .then(function () { return _this.subscriptions = {}; });
            };
            _this.logger = options.logger || log_1$3.logger;
            _this.config = {
                host: options.host || 'http://localhost:3000',
                useSsl: options.useSsl || false,
                reopen: options.reopen || 10000,
                ping: options.timeout || 30000
            };
            _this.host = util_1.hostToWS(_this.config.host, _this.config.useSsl) + "/websocket";
            _this.on('ping', function () {
                _this.send({ msg: 'pong' }).then(_this.logger.debug, _this.logger.error);
            });
            _this.on('result', function (data) { return _this.emit(data.id, { id: data.id, result: data.result, error: data.error }); });
            _this.on('ready', function (data) { return _this.emit(data.subs[0], data); });
            return _this;
        }
        Object.defineProperty(Socket.prototype, "connected", {
            /** Check if websocket connected and ready. */
            get: function () {
                return !!(this.connection &&
                    this.connection.readyState === 1 &&
                    this.alive());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Socket.prototype, "loggedIn", {
            /** Check if connected and logged in */
            get: function () {
                return (this.connected && !!this.resume);
            },
            enumerable: true,
            configurable: true
        });
        return Socket;
    }(tiny_events_1.EventEmitter));
    ddp.Socket = Socket;
    var DDPDriver = /** @class */ (function (_super) {
        __extends$4(DDPDriver, _super);
        function DDPDriver(_a) {
            if (_a === void 0) { _a = {}; }
            var _b = _a.host, host = _b === void 0 ? 'localhost:3000' : _b; _a.integrationId; var config = _a.config, _c = _a.logger, logger = _c === void 0 ? log_1$3.logger : _c, moreConfigs = __rest$4(_a, ["host", "integrationId", "config", "logger"]);
            var _this = _super.call(this) || this;
            /**
             * Websocket subscriptions, exported for direct polling by adapters
             * Variable not initialised until `prepMeteorSubscriptions` called.
             * @deprecated Use `ddp.Socket` instance subscriptions instead.
             */
            _this.subscriptions = {};
            /** Current user object populated from resolved login */
            _this.userId = '';
            /** Array of joined room IDs (for reactive queries) */
            _this.joinedIds = [];
            /**
             * Initialise socket instance with given options or defaults.
             * Proxies the DDP module socket connection. Resolves with socket when open.
             * Accepts callback following error-first-pattern.
             * Error returned or promise rejected on timeout.
             * @example <caption>Using promise</caption>
             *  import { driver } from '@rocket.chat/sdk'
             *  driver.connect()
             *    .then(() => console.log('connected'))
             *    .catch((err) => console.error(err))
             */
            _this.connect = function (c) {
                if (c === void 0) { c = {}; }
                if (_this.connected) {
                    return Promise.resolve(_this);
                }
                var config = __assign$4({}, _this.config, c); // override defaults
                return new Promise(function (resolve, reject) {
                    _this.logger.info('[driver] Connecting', config);
                    _this.subscriptions = _this.ddp.subscriptions;
                    _this.ddp.open().catch(function (err) {
                        _this.logger.error("[driver] Failed to connect: " + err.message);
                        reject(err);
                    });
                    _this.ddp.on('open', function () { return _this.emit('connected'); }); // echo ddp event
                    var cancelled = false;
                    var rejectionTimeout = setTimeout(function () {
                        _this.logger.info("[driver] Timeout (" + config.timeout + ")");
                        var err = new Error('Socket connection timeout');
                        cancelled = true;
                        _this.ddp.removeAllListeners('connected');
                        reject(err);
                    }, config.timeout);
                    // if to avoid condition where timeout happens before listener to 'connected' is added
                    // and this listener is not removed (because it was added after the removal)
                    if (!cancelled) {
                        _this.once('connected', function () {
                            _this.logger.info('[driver] Connected');
                            if (cancelled)
                                return _this.ddp.close(); // cancel if already rejected
                            clearTimeout(rejectionTimeout);
                            resolve(_this);
                        });
                    }
                });
            };
            _this.disconnect = function () {
                return _this.ddp.close();
            };
            _this.subscribe = function (topic, eventname) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                _this.logger.info("[DDP driver] Subscribing to " + topic + " | " + JSON.stringify(args));
                return _this.ddp.subscribe(topic, [eventname, { 'useCollection': false, 'args': args }]);
            };
            _this.subscribeNotifyAll = function () {
                var topic = 'stream-notify-all';
                return Promise.all([
                    'roles-change',
                    'updateEmojiCustom',
                    'deleteEmojiCustom',
                    'updateAvatar',
                    'public-settings-changed',
                    'permissions-changed'
                ].map(function (event) { return _this.subscribe(topic, event, false); }));
            };
            _this.subscribeLoggedNotify = function () {
                var topic = 'stream-notify-logged';
                return Promise.all([
                    'Users:NameChanged',
                    'Users:Deleted',
                    'updateAvatar',
                    'updateEmojiCustom',
                    'deleteEmojiCustom',
                    'roles-change'
                ].map(function (event) { return _this.subscribe(topic, event, false); }));
            };
            _this.subscribeNotifyUser = function () {
                var topic = 'stream-notify-user';
                return Promise.all([
                    'message',
                    'otr',
                    'webrtc',
                    'notification',
                    'rooms-changed',
                    'subscriptions-changed',
                    'uiInteraction'
                ].map(function (event) { return _this.subscribe(topic, _this.userId + "/" + event, false); }));
            };
            _this.subscribeRoom = function (rid) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var topic = 'stream-notify-room';
                return Promise.all([
                    _this.subscribe.apply(_this, __spread$1(['stream-room-messages', rid], args)),
                    _this.subscribe.apply(_this, __spread$1([topic, rid + "/typing"], args)),
                    _this.subscribe.apply(_this, __spread$1([topic, rid + "/deleteMessage"], args))
                ]);
            };
            /** Login to Rocket.Chat via DDP */
            _this.login = function (credentials, args) { return __awaiter$3(_this, void 0, void 0, function () {
                var login;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(!this.ddp || !this.ddp.connected)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.connect()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            this.logger.info("[DDP driver] Login with " + JSON.stringify(credentials));
                            return [4 /*yield*/, this.ddp.login(credentials)];
                        case 3:
                            login = _a.sent();
                            this.userId = login.id;
                            return [2 /*return*/, login];
                    }
                });
            }); };
            _this.logout = function () { return __awaiter$3(_this, void 0, void 0, function () {
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.ddp && this.ddp.connected)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.ddp.logout()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/];
                    }
                });
            }); };
            /** Unsubscribe from Meteor stream. Proxy for socket unsubscribe. */
            _this.unsubscribe = function (subscription) {
                return _this.ddp.unsubscribe(subscription.id);
            };
            /** Unsubscribe from all subscriptions. Proxy for socket unsubscribeAll */
            _this.unsubscribeAll = function () {
                return _this.ddp.unsubscribeAll();
            };
            _this.onStreamData = function (event, cb) {
                function listener(message) {
                    cb((message));
                }
                return Promise.resolve(_this.ddp.on(event, listener))
                    .then(function () { return ({
                    stop: function () { return _this.ddp.off(event, listener); }
                }); });
            };
            _this.onMessage = function (cb) {
                _this.ddp.on('stream-room-messages', function (_a) {
                    var _b = __read$2(_a.fields.args, 1), message = _b[0];
                    return cb(_this.ejsonMessage(message));
                });
            };
            _this.onTyping = function (cb) {
                return _this.ddp.on('stream-notify-room', function (_a) {
                    var _b = __read$2(_a.fields.args, 2), username = _b[0], isTyping = _b[1];
                    cb(username, isTyping);
                });
            };
            _this.notifyVisitorTyping = function (rid, username, typing, token) {
                return _this.ddp.call('stream-notify-room', rid + "/typing", username, typing, { token: token });
            };
            _this.notifyCallDeclined = function (rid) {
                return _this.ddp.call('stream-notify-room', rid + "/webrtc", 'callStatus', { callStatus: 'declined' });
            };
            _this.ejsonMessage = function (message) {
                if (message.ts) {
                    message.ts = new Date(message.ts.$date);
                }
                return message;
            };
            _this.methodCall = function (method) {
                var _a;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return (_a = _this.ddp).call.apply(_a, __spread$1([method], args));
            };
            _this.config = __assign$4({}, config, moreConfigs, { host: host.replace(/(^\w+:|^)\/\//, ''), timeout: 20000 });
            _this.ddp = new Socket(__assign$4({}, _this.config, { logger: logger }));
            _this.logger = logger;
            return _this;
        }
        Object.defineProperty(DDPDriver.prototype, "connected", {
            get: function () {
                return !!this.ddp.connected;
            },
            enumerable: true,
            configurable: true
        });
        return DDPDriver;
    }(tiny_events_1.EventEmitter));
    ddp.DDPDriver = DDPDriver;

    var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$3 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$3 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$3.apply(this, arguments);
    };
    var __awaiter$2 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$2 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$3 = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var __read$1 = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };
    Object.defineProperty(Livechat$1, "__esModule", { value: true });
    /**
        * @module LivechatDriver
        * Provides high-level helpers for Livechat connection, method calls, subscriptions.
        */
    var Livechat_1$1 = __importDefault$3(Livechat);
    var drivers_1$1 = drivers;
    var log_1$2 = log;
    var LivechatClient = /** @class */ (function (_super) {
        __extends$3(LivechatClient, _super);
        function LivechatClient(_a) {
            var logger = _a.logger; _a.allPublic; _a.rooms; _a.integrationId; var _b = _a.protocol, protocol = _b === void 0 ? drivers_1$1.Protocols.DDP : _b, config = __rest$3(_a, ["logger", "allPublic", "rooms", "integrationId", "protocol"]);
            var _this = _super.call(this, __assign$3({ logger: logger }, config)) || this;
            _this.livechatStream = 'stream-livechat-room';
            _this.userId = '';
            _this.logger = log_1$2.logger;
            _this.socket = Promise.resolve();
            _this.import(protocol, config);
            return _this;
        }
        LivechatClient.prototype.import = function (protocol, config) {
            var _this = this;
            switch (protocol) {
                // case Protocols.MQTT:
                //   this.socket = import(/* webpackChunkName: 'mqtttest' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ logger: this.logger, ...config }))
                //   break
                case drivers_1$1.Protocols.DDP:
                    this.socket = Promise.resolve().then(function () { return __importStar$2(ddp); }).then(function (_a) {
                        var DDPDriver = _a.DDPDriver;
                        return new DDPDriver(__assign$3({ logger: _this.logger }, config));
                    });
                    break;
                default:
                    throw new Error("Invalid Protocol: " + protocol + ", valids: " + Object.keys(drivers_1$1.Protocols).join());
            }
        };
        LivechatClient.prototype.connect = function (options, callback) {
            return __awaiter$2(this, void 0, void 0, function () {
                var _this = this;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).connect(options).then(function () { return (_this.setUpConnection()); })];
                    }
                });
            });
        };
        LivechatClient.prototype.disconnect = function () {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).disconnect()];
                }
            }); });
        };
        LivechatClient.prototype.unsubscribe = function (subscription) {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).unsubscribe(subscription)];
                }
            }); });
        };
        LivechatClient.prototype.unsubscribeAll = function () {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).unsubscribeAll()];
                }
            }); });
        };
        LivechatClient.prototype.subscribeNotifyAll = function () {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyAll()];
                }
            }); });
        };
        LivechatClient.prototype.subscribeLoggedNotify = function () {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).subscribeLoggedNotify()];
                }
            }); });
        };
        LivechatClient.prototype.subscribeNotifyUser = function () {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyUser()];
                }
            }); });
        };
        LivechatClient.prototype.onMessage = function (cb) {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).onMessage(cb)];
                }
            }); });
        };
        LivechatClient.prototype.onTyping = function (cb) {
            return __awaiter$2(this, void 0, void 0, function () { return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).onTyping(cb)];
                }
            }); });
        };
        LivechatClient.prototype.onAgentChange = function (rid, cb) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
                                    var _b = __read$1(_a.fields.args, 1), _c = _b[0], type = _c.type, data = _c.data;
                                    if (type === 'agentData') {
                                        cb(data);
                                    }
                                })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        LivechatClient.prototype.onAgentStatusChange = function (rid, cb) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
                                    var _b = __read$1(_a.fields.args, 1), _c = _b[0], type = _c.type, status = _c.status;
                                    if (type === 'agentStatus') {
                                        cb(status);
                                    }
                                })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        LivechatClient.prototype.onQueuePositionChange = function (rid, cb) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
                                    var _b = __read$1(_a.fields.args, 1), _c = _b[0], type = _c.type, data = _c.data;
                                    if (type === 'queueData') {
                                        cb(data);
                                    }
                                })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        LivechatClient.prototype.onVisitorChange = function (rid, cb) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
                                    var _b = __read$1(_a.fields.args, 1), _c = _b[0], type = _c.type, visitor = _c.visitor;
                                    if (type === 'visitorData') {
                                        cb(visitor);
                                    }
                                })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        LivechatClient.prototype.notifyVisitorTyping = function (rid, username, typing) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).notifyVisitorTyping(rid, username, typing, this.credentials.token)];
                    }
                });
            });
        };
        LivechatClient.prototype.notifyCallDeclined = function (rid) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).notifyCallDeclined(rid)];
                    }
                });
            });
        };
        LivechatClient.prototype.subscribe = function (topic, eventName) {
            return __awaiter$2(this, void 0, void 0, function () {
                var token;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            token = this.credentials.token;
                            return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).subscribe(topic, eventName, { token: token, visitorToken: token })];
                    }
                });
            });
        };
        LivechatClient.prototype.subscribeRoom = function (rid) {
            return __awaiter$2(this, void 0, void 0, function () {
                var token;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            token = this.credentials.token;
                            return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).subscribeRoom(rid, { token: token, visitorToken: token })];
                    }
                });
            });
        };
        LivechatClient.prototype.onStreamData = function (event, cb) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).onStreamData(event, cb)];
                    }
                });
            });
        };
        LivechatClient.prototype.setUpConnection = function () {
            return __awaiter$2(this, void 0, void 0, function () {
                var token;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            token = this.credentials.token;
                            return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).methodCall('livechat:setUpConnection', { token: token })];
                    }
                });
            });
        };
        return LivechatClient;
    }(Livechat_1$1.default));
    Livechat$1.default = LivechatClient;

    var Bot = {};

    var Rocketchat$1 = {};

    var RocketChat = {};

    (function (exports) {
    /**
        * @module ApiRocketChat
        * Provides a client for handling requests with Rocket.Chat's REST API
        */
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var api_1 = __importDefault(api$1);
    /** Defaults for user queries */
    exports.userFields = { name: 1, username: 1, status: 1, type: 1 };
    /** Query helpers for user collection requests */
    var ApiRocketChat = /** @class */ (function (_super) {
        __extends(ApiRocketChat, _super);
        function ApiRocketChat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ApiRocketChat.prototype, "users", {
            get: function () {
                var self = this;
                return {
                    all: function (fields) {
                        if (fields === void 0) { fields = exports.userFields; }
                        return self.get('users.list', { fields: fields }).then(function (r) { return r.users; });
                    },
                    allNames: function () { return self.get('users.list', { fields: { 'username': 1 } }).then(function (r) { return r.users.map(function (u) { return u.username; }); }); },
                    allIDs: function () { return self.get('users.list', { fields: { '_id': 1 } }).then(function (r) { return r.users.map(function (u) { return u._id; }); }); },
                    online: function (fields) {
                        if (fields === void 0) { fields = exports.userFields; }
                        return self.get('users.list', { fields: fields, query: { 'status': { $ne: 'offline' } } }).then(function (r) { return r.users; });
                    },
                    onlineNames: function () { return self.get('users.list', { fields: { 'username': 1 }, query: { 'status': { $ne: 'offline' } } }).then(function (r) { return r.users.map(function (u) { return u.username; }); }); },
                    onlineIds: function () { return self.get('users.list', { fields: { '_id': 1 }, query: { 'status': { $ne: 'offline' } } }).then(function (r) { return r.users.map(function (u) { return u._id; }); }); },
                    info: function (username) {
                        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, self.get('users.info', { username: username }, true)];
                                case 1: return [2 /*return*/, (_a.sent()).user];
                            }
                        }); });
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApiRocketChat.prototype, "rooms", {
            get: function () {
                var self = this;
                return {
                    info: function (_a) {
                        var rid = _a.rid;
                        return self.get('rooms.info', { rid: rid }, true);
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        // editMessage(message: IMessage) chat.update
        ApiRocketChat.prototype.joinRoom = function (_a) {
            var rid = _a.rid;
            return this.post('channels.join', { roomId: rid }, true);
        };
        ApiRocketChat.prototype.info = function () {
            return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get('info', {}, true)];
                    case 1: return [2 /*return*/, (_a.sent()).info];
                }
            }); });
        };
        /**
         * Send a prepared message object (with pre-defined room ID).
         * Usually prepared and called by sendMessageByRoomId or sendMessageByRoom.
         */
        ApiRocketChat.prototype.sendMessage = function (message, rid) {
            return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('chat.sendMessage', { message: this.prepareMessage(message, rid) }, true)];
                    case 1: return [2 /*return*/, (_a.sent()).message];
                }
            }); });
        };
        ApiRocketChat.prototype.getRoomIdByNameOrId = function (name) { return this.get('chat.getRoomIdByNameOrId', { name: name }, true); };
        ApiRocketChat.prototype.getRoomNameById = function (rid) { return this.getRoomName(rid); };
        ApiRocketChat.prototype.getRoomName = function (rid) {
            return __awaiter(this, void 0, void 0, function () {
                var room;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.get('chat.getRoomNameById', { rid: rid }, true)];
                        case 1:
                            room = _a.sent();
                            return [2 /*return*/, room.name];
                    }
                });
            });
        };
        ApiRocketChat.prototype.getRoomId = function (name) { return this.get('chat.find', { name: name }, true); };
        ApiRocketChat.prototype.createDirectMessage = function (username) {
            return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('im.create', { username: username }, true)];
                    case 1: return [2 /*return*/, (_a.sent()).room];
                }
            }); });
        };
        /**
         * Edit an existing message, replacing any attributes with those provided.
         * The given message object should have the ID of an existing message.
         */
        ApiRocketChat.prototype.editMessage = function (message) {
            return this.post('chat.update', { roomId: message.rid, msgId: message._id, text: message.msg });
        };
        /**
         * Send a reaction to an existing message. Simple proxy for method call.
         * @param emoji     Accepts string like `:thumbsup:` to add 👍 reaction
         * @param messageId ID for a previously sent message
         */
        ApiRocketChat.prototype.setReaction = function (emoji, messageId) { return this.post('chat.react', { emoji: emoji, messageId: messageId }, true); };
        // TODO fix this methods
        ApiRocketChat.prototype.loadHistory = function (rid, lastUpdate) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.get('chat.syncMessages', { roomId: rid, lastUpdate: lastUpdate.toISOString() }, true)];
                        case 1: return [2 /*return*/, (_a.sent()).result];
                    }
                });
            });
        };
        /** Exit a room the bot has joined */
        ApiRocketChat.prototype.leaveRoom = function (rid) {
            return this.post('rooms.leave', { rid: rid }).then(function () { return rid; });
        };
        /** Get information about a public group */
        ApiRocketChat.prototype.channelInfo = function (query) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.get('channels.info', query, true)];
                        case 1: return [2 /*return*/, (_a.sent()).channel];
                    }
                });
            });
        };
        /** Get information about a private group */
        ApiRocketChat.prototype.privateInfo = function (query) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.get('groups.info', query, true)];
                        case 1: return [2 /*return*/, (_a.sent()).group];
                    }
                });
            });
        };
        return ApiRocketChat;
    }(api_1.default));
    exports.default = ApiRocketChat;

    }(RocketChat));

    var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$2 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };
    var __awaiter$1 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$1 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$2 = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var __read = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (commonjsGlobal && commonjsGlobal.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };
    Object.defineProperty(Rocketchat$1, "__esModule", { value: true });
    var drivers_1 = drivers;
    var RocketChat_1 = __importDefault$2(RocketChat);
    var log_1$1 = log;
    var RocketChatClient = /** @class */ (function (_super) {
        __extends$2(RocketChatClient, _super);
        function RocketChatClient(_a) {
            var logger = _a.logger; _a.allPublic; _a.rooms; _a.integrationId; var _b = _a.protocol, protocol = _b === void 0 ? drivers_1.Protocols.DDP : _b, config = __rest$2(_a, ["logger", "allPublic", "rooms", "integrationId", "protocol"]);
            var _this = _super.call(this, __assign$2({}, config, { logger: logger })) || this;
            _this.userId = '';
            _this.logger = log_1$1.logger;
            _this.logger = logger;
            switch (protocol) {
                // case Protocols.MQTT:
                //   this.socket = import(/* webpackChunkName: 'mqtt' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ ...config, logger }))
                //   break
                case drivers_1.Protocols.DDP:
                    _this.socket = Promise.resolve().then(function () { return __importStar$1(ddp); }).then(function (_a) {
                        var DDPDriver = _a.DDPDriver;
                        return new DDPDriver(__assign$2({}, config, { logger: logger }));
                    });
                    break;
                default:
                    throw new Error("Invalid Protocol: " + protocol + ", valids: " + Object.keys(drivers_1.Protocols).join());
            }
            return _this;
        }
        RocketChatClient.prototype.resume = function (_a) {
            var token = _a.token;
            return __awaiter$1(this, void 0, void 0, function () {
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_b.sent()).login({ token: token }, {})];
                    }
                });
            });
        };
        RocketChatClient.prototype.login = function (credentials) {
            return __awaiter$1(this, void 0, void 0, function () {
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, _super.prototype.login.call(this, credentials)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, this.currentLogin && this.resume({ token: this.currentLogin.authToken })];
                    }
                });
            });
        };
        RocketChatClient.prototype.connect = function (options) {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).connect(options)];
                }
            }); });
        };
        RocketChatClient.prototype.disconnect = function () {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).disconnect()];
                }
            }); });
        };
        RocketChatClient.prototype.onStreamData = function (event, cb) {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).onStreamData(event, cb)];
                }
            }); });
        };
        RocketChatClient.prototype.subscribe = function (topic) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return __awaiter$1(this, void 0, void 0, function () {
                var _a;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a = (_b.sent())).subscribe.apply(_a, __spread([topic], args))];
                    }
                });
            });
        };
        RocketChatClient.prototype.unsubscribe = function (subscription) {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).unsubscribe(subscription)];
                }
            }); });
        };
        RocketChatClient.prototype.unsubscribeAll = function () {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).unsubscribeAll()];
                }
            }); });
        };
        RocketChatClient.prototype.subscribeRoom = function (rid) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return __awaiter$1(this, void 0, void 0, function () {
                var _a;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a = (_b.sent())).subscribeRoom.apply(_a, __spread([rid], args))];
                    }
                });
            });
        };
        RocketChatClient.prototype.subscribeNotifyAll = function () {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyAll()];
                }
            }); });
        };
        RocketChatClient.prototype.subscribeLoggedNotify = function () {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).subscribeLoggedNotify()];
                }
            }); });
        };
        RocketChatClient.prototype.subscribeNotifyUser = function () {
            return __awaiter$1(this, void 0, void 0, function () { return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.socket];
                    case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyUser()];
                }
            }); });
        };
        Object.defineProperty(RocketChatClient.prototype, "url", {
            get: function () {
                return this.socket.then(function (socket) { return socket.config.host; });
            },
            enumerable: true,
            configurable: true
        });
        RocketChatClient.prototype.onMessage = function (cb) {
            return __awaiter$1(this, void 0, void 0, function () {
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a.sent()).onMessage(cb)];
                    }
                });
            });
        };
        RocketChatClient.prototype.methodCall = function (method) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return __awaiter$1(this, void 0, void 0, function () {
                var _a;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.socket];
                        case 1: return [2 /*return*/, (_a = (_b.sent())).methodCall.apply(_a, __spread([method], args))];
                    }
                });
            });
        };
        return RocketChatClient;
    }(RocketChat_1.default));
    Rocketchat$1.default = RocketChatClient;

    var mem$1 = {exports: {}};

    var mimicFn$2 = {exports: {}};

    const mimicFn$1 = (to, from) => {
    	for (const prop of Reflect.ownKeys(from)) {
    		Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    	}

    	return to;
    };

    mimicFn$2.exports = mimicFn$1;
    // TODO: Remove this for the next major release
    mimicFn$2.exports.default = mimicFn$1;

    var pIsPromise = {exports: {}};

    const isPromise$1 = input => (
    	input instanceof Promise ||
    	(
    		input !== null &&
    		typeof input === 'object' &&
    		typeof input.then === 'function' &&
    		typeof input.catch === 'function'
    	)
    );

    pIsPromise.exports = isPromise$1;
    // TODO: Remove this for the next major release
    pIsPromise.exports.default = isPromise$1;

    var dist = {exports: {}};

    var pDefer = () => {
    	const ret = {};

    	ret.promise = new Promise((resolve, reject) => {
    		ret.resolve = resolve;
    		ret.reject = reject;
    	});

    	return ret;
    };

    (function (module, exports) {
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    const p_defer_1 = __importDefault(pDefer);
    function mapAgeCleaner(map, property = 'maxAge') {
        let processingKey;
        let processingTimer;
        let processingDeferred;
        const cleanup = () => __awaiter(this, void 0, void 0, function* () {
            if (processingKey !== undefined) {
                // If we are already processing an item, we can safely exit
                return;
            }
            const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {
                processingDeferred = p_defer_1.default();
                const delay = item[1][property] - Date.now();
                if (delay <= 0) {
                    // Remove the item immediately if the delay is equal to or below 0
                    map.delete(item[0]);
                    processingDeferred.resolve();
                    return;
                }
                // Keep track of the current processed key
                processingKey = item[0];
                processingTimer = setTimeout(() => {
                    // Remove the item when the timeout fires
                    map.delete(item[0]);
                    if (processingDeferred) {
                        processingDeferred.resolve();
                    }
                }, delay);
                // tslint:disable-next-line:strict-type-predicates
                if (typeof processingTimer.unref === 'function') {
                    // Don't hold up the process from exiting
                    processingTimer.unref();
                }
                return processingDeferred.promise;
            });
            try {
                for (const entry of map) {
                    yield setupTimer(entry);
                }
            }
            catch (_a) {
                // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing
            }
            processingKey = undefined;
        });
        const reset = () => {
            processingKey = undefined;
            if (processingTimer !== undefined) {
                clearTimeout(processingTimer);
                processingTimer = undefined;
            }
            if (processingDeferred !== undefined) { // tslint:disable-line:early-exit
                processingDeferred.reject(undefined);
                processingDeferred = undefined;
            }
        };
        const originalSet = map.set.bind(map);
        map.set = (key, value) => {
            if (map.has(key)) {
                // If the key already exist, remove it so we can add it back at the end of the map.
                map.delete(key);
            }
            // Call the original `map.set`
            const result = originalSet(key, value);
            // If we are already processing a key and the key added is the current processed key, stop processing it
            if (processingKey && processingKey === key) {
                reset();
            }
            // Always run the cleanup method in case it wasn't started yet
            cleanup(); // tslint:disable-line:no-floating-promises
            return result;
        };
        cleanup(); // tslint:disable-line:no-floating-promises
        return map;
    }
    exports.default = mapAgeCleaner;
    // Add support for CJS
    module.exports = mapAgeCleaner;
    module.exports.default = mapAgeCleaner;
    }(dist, dist.exports));

    const mimicFn = mimicFn$2.exports;
    const isPromise = pIsPromise.exports;
    const mapAgeCleaner = dist.exports;

    const cacheStore = new WeakMap();

    const defaultCacheKey = (...arguments_) => {
    	if (arguments_.length === 0) {
    		return '__defaultKey';
    	}

    	if (arguments_.length === 1) {
    		const [firstArgument] = arguments_;
    		if (
    			firstArgument === null ||
    			firstArgument === undefined ||
    			(typeof firstArgument !== 'function' && typeof firstArgument !== 'object')
    		) {
    			return firstArgument;
    		}
    	}

    	return JSON.stringify(arguments_);
    };

    const mem = (fn, options) => {
    	options = Object.assign({
    		cacheKey: defaultCacheKey,
    		cache: new Map(),
    		cachePromiseRejection: false
    	}, options);

    	if (typeof options.maxAge === 'number') {
    		mapAgeCleaner(options.cache);
    	}

    	const {cache} = options;
    	options.maxAge = options.maxAge || 0;

    	const setData = (key, data) => {
    		cache.set(key, {
    			data,
    			maxAge: Date.now() + options.maxAge
    		});
    	};

    	const memoized = function (...arguments_) {
    		const key = options.cacheKey(...arguments_);

    		if (cache.has(key)) {
    			return cache.get(key).data;
    		}

    		const cacheItem = fn.call(this, ...arguments_);

    		setData(key, cacheItem);

    		if (isPromise(cacheItem) && options.cachePromiseRejection === false) {
    			// Remove rejected promises from cache unless `cachePromiseRejection` is set to `true`
    			cacheItem.catch(() => cache.delete(key));
    		}

    		return cacheItem;
    	};

    	try {
    		// The below call will throw in some host environments
    		// See https://github.com/sindresorhus/mimic-fn/issues/10
    		mimicFn(memoized, fn);
    	} catch (_) {}

    	cacheStore.set(memoized, options.cache);

    	return memoized;
    };

    mem$1.exports = mem;
    // TODO: Remove this for the next major release
    mem$1.exports.default = mem;

    mem$1.exports.clear = fn => {
    	const cache = cacheStore.get(fn);

    	if (cache && typeof cache.clear === 'function') {
    		cache.clear();
    	}
    };

    var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$1 = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(Bot, "__esModule", { value: true });
    var log_1 = log;
    var Rocketchat_1$1 = __importDefault$1(Rocketchat$1);
    var mem_1 = __importDefault$1(mem$1.exports);
    var MY_MESSAGES = '__my_messages__';
    var TOPIC_MESSAGES = 'stream-room-messages';
    var BotClient = /** @class */ (function (_super) {
        __extends$1(BotClient, _super);
        function BotClient(_a) {
            var _b = _a.allPublic, allPublic = _b === void 0 ? false : _b, integrationId = _a.integrationId, _c = _a.cachedMethods, cachedMethods = _c === void 0 ? ['channelInfo', 'privateInfo', 'getRoomIdByNameOrId', 'getRoomId', 'getRoomName', 'getRoomNameById', 'getDirectMessageRoomId'] : _c, config = __rest$1(_a, ["allPublic", "integrationId", "cachedMethods"]);
            var _this = _super.call(this, __assign$1({}, config, { allPublic: allPublic })) || this;
            _this.lastReadTime = new Date(-8640000000000000);
            _this.joinedIds = [];
            _this.messages = null;
            _this.integrationId = integrationId;
            cachedMethods.forEach(function (name) {
                if (_this[name]) {
                    _this[name] = mem_1.default(_this[name].bind(_this), { maxAge: 60 * 60 * 1000 }).bind(_this);
                }
            });
            return _this;
        }
        /**
         * Initialise socket instance with given options or defaults.
         * Proxies the DDP module socket connection. Resolves with socket when open.
         * Accepts callback following error-first-pattern.
         * Error returned or promise rejected on timeout.
         * @example <caption>Use with callback</caption>
         *  import driver from '@rocket.chat/sdk/bot'
         *  driver.connect({}, (err) => {
         *    if (err) throw err
         *    else console.log('connected')
         *  })
         * @example <caption>Using promise</caption>
         *  import driver from '@rocket.chat/sdk/bot'
         *  driver.connect()
         *    .then(() => console.log('connected'))
         *    .catch((err) => console.error(err))
         */
        BotClient.prototype.connect = function (options, callback) {
            return __awaiter(this, void 0, void 0, function () {
                var result, _a, _b, error_1;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _c.trys.push([0, 4, , 5]);
                            return [4 /*yield*/, _super.prototype.connect.call(this, options)];
                        case 1:
                            result = _c.sent();
                            if (!callback) return [3 /*break*/, 3];
                            _a = callback;
                            _b = [null];
                            return [4 /*yield*/, this.socket];
                        case 2:
                            _a.apply(void 0, _b.concat([(_c.sent())]));
                            _c.label = 3;
                        case 3: return [2 /*return*/, result];
                        case 4:
                            error_1 = _c.sent();
                            if (callback) {
                                callback(error_1, this);
                            }
                            return [2 /*return*/, Promise.reject(error_1)];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        BotClient.prototype.unsubscribeAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    delete this.messages;
                    return [2 /*return*/, _super.prototype.unsubscribeAll.call(this)];
                });
            });
        };
        /** Begin subscription to user's "global" message stream. Will only allow one. */
        BotClient.prototype.subscribeToMessages = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!!this.messages) return [3 /*break*/, 2];
                            _a = this;
                            return [4 /*yield*/, this.subscribe(TOPIC_MESSAGES, MY_MESSAGES)];
                        case 1:
                            _a.messages = _b.sent();
                            _b.label = 2;
                        case 2: return [2 /*return*/, this.messages];
                    }
                });
            });
        };
        /**
         * Add callback for changes in the message stream, subscribing if not already.
         * This can be called directly for custom extensions, but for most usage (e.g.
         * for bots) the respondToMessages is more useful to only receive messages
         * matching configuration.
         *
         * @param callback Function called with every change in subscriptions.
         *  - Uses error-first callback pattern
         *  - Second argument is the changed message
         *  - Third argument is additional attributes, such as `roomType`
         */
        BotClient.prototype.reactToMessages = function (callback, debug) {
            return __awaiter(this, void 0, void 0, function () {
                var handler, _a;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            handler = function (e) {
                                try {
                                    var message = e.fields.args[0];
                                    if (!message || !message._id) {
                                        callback(new Error('Message handler fired on event without message or meta data'));
                                    }
                                    else {
                                        callback(null, message, {});
                                    }
                                }
                                catch (err) {
                                    _this.logger.error("[driver] Message handler err: " + err.message);
                                    callback(err);
                                }
                            };
                            _a = this;
                            return [4 /*yield*/, this.subscribeToMessages()];
                        case 1:
                            _a.messages = _b.sent();
                            this.messages.onEvent(handler);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Applies `reactToMessages` with some filtering of messages based on config.
         * If no rooms are joined at this point, it will attempt to join now based on
         * environment config, otherwise it might not receive any messages. It doesn't
         * matter that this happens asynchronously because joined rooms can change after
         * the subscription is set up.
         *
         * @param callback Function called after filters run on subscription events.
         *  - Uses error-first callback pattern
         *  - Second argument is the changed item
         *  - Third argument is additional attributes, such as `roomType`
         * @param options Sets filters for different event/message types.
         */
        BotClient.prototype.respondToMessages = function (callback, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var config, err_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            config = __assign$1({}, this.config, options);
                            if (!(!config.allPublic && this.joinedIds.length === 0 && config.rooms && config.rooms.length > 0)) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.joinRooms(config.rooms)];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            err_1 = _a.sent();
                            this.logger.error("[driver] Failed to join configured rooms (" + config.rooms.join(', ') + "): " + err_1.message);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/, this.reactToMessages(function (err, message, meta) { return __awaiter(_this, void 0, void 0, function () {
                                var room, isDM, isLC, error_2, currentReadTime;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (err) {
                                                log_1.logger.error("[driver] Unable to receive: " + err.message);
                                                return [2 /*return*/, callback(err)]; // bubble errors back to adapter
                                            }
                                            if (typeof message === 'undefined' /*|| typeof meta === 'undefined'*/) {
                                                log_1.logger.error("[driver] Message or meta undefined");
                                                return [2 /*return*/, callback(err)];
                                            }
                                            // Ignore bot's own messages
                                            if (message.u && message.u._id === this.userId)
                                                return [2 /*return*/];
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, this.rooms.info({ rid: message.rid })];
                                        case 2:
                                            room = _a.sent();
                                            isDM = room.t === 'd';
                                            if (isDM && !config.dm)
                                                return [2 /*return*/];
                                            isLC = room.t === 'l';
                                            if (isLC && !config.livechat)
                                                return [2 /*return*/];
                                            return [3 /*break*/, 4];
                                        case 3:
                                            error_2 = _a.sent();
                                            console.log(error_2);
                                            return [3 /*break*/, 4];
                                        case 4:
                                            currentReadTime = (message.ts) ? new Date(message.ts.$date) : new Date();
                                            // Ignore edited messages if configured to
                                            if (!config.edited && message.editedAt)
                                                return [2 /*return*/];
                                            // Ignore messages in stream that aren't new
                                            if (currentReadTime < this.lastReadTime)
                                                return [2 /*return*/];
                                            // At this point, message has passed checks and can be responded to
                                            // const username = (message.u) ? message.u.username : 'unknown'
                                            // this.logger.info(`[driver] Message ${message._id} from ${username}`)
                                            this.lastReadTime = currentReadTime;
                                            callback(null, message, meta);
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    }
                });
            });
        };
        /** Get ID for a room by name (or ID). */
        BotClient.prototype.getRoomId = function (name) {
            return this.getRoomIdByNameOrId(name);
        };
        /** Join the bot into a room by its name or ID */
        BotClient.prototype.joinRoom = function (_a) {
            var rid = _a.rid;
            return __awaiter(this, void 0, void 0, function () {
                var roomId, joinedIndex;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getRoomId(rid)];
                        case 1:
                            roomId = _b.sent();
                            joinedIndex = this.joinedIds.indexOf(rid);
                            if (joinedIndex !== -1) {
                                log_1.logger.error("[driver] Join room failed, already joined");
                                throw new Error("[driver] Join room failed, already joined");
                            }
                            return [4 /*yield*/, _super.prototype.joinRoom.call(this, { rid: roomId })];
                        case 2:
                            _b.sent();
                            this.joinedIds.push(roomId);
                            return [2 /*return*/, roomId];
                    }
                });
            });
        };
        /** Exit a room the bot has joined */
        BotClient.prototype.leaveRoom = function (room) {
            return __awaiter(this, void 0, void 0, function () {
                var roomId, joinedIndex;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.getRoomId(room)];
                        case 1:
                            roomId = _a.sent();
                            joinedIndex = this.joinedIds.indexOf(room);
                            if (joinedIndex === -1) {
                                this.logger.error("[driver] Leave room failed, bot has not joined " + room);
                                throw new Error("[driver] Leave room failed, bot has not joined " + room);
                            }
                            return [4 /*yield*/, this.leaveRoom(roomId)];
                        case 2:
                            _a.sent();
                            delete this.joinedIds[joinedIndex];
                            return [2 /*return*/, roomId];
                    }
                });
            });
        };
        /** Join a set of rooms by array of names or IDs */
        BotClient.prototype.joinRooms = function (rooms) {
            var _this = this;
            return Promise.all(rooms.map(function (rid) { return _this.joinRoom({ rid: rid }); }));
        };
        /**
         * Prepare and send string/s to specified room ID.
         * @param content Accepts message text string or array of strings.
         * @param roomId  ID of the target room to use in send.
         * @todo Returning one or many gets complicated with type checking not allowing
         *       use of a property because result may be array, when you know it's not.
         *       Solution would probably be to always return an array, even for single
         *       send. This would be a breaking change, should hold until major version.
         */
        BotClient.prototype.sendToRoomId = function (content, roomId) {
            var _this = this;
            if (Array.isArray(content)) {
                return Promise.all(content.map(function (text) {
                    return _this.sendMessage(text, roomId);
                }));
            }
            return this.sendMessage(content, roomId);
        };
        /**
         * Prepare and send string/s to specified room name (or ID).
         * @param content Accepts message text string or array of strings.
         * @param room    A name (or ID) to resolve as ID to use in send.
         */
        BotClient.prototype.sendToRoom = function (content, room) {
            var _this = this;
            return this.getRoomId(room)
                .then(function (roomId) { return _this.sendToRoomId(content, roomId); });
        };
        /**
         * Prepare and send string/s to a user in a DM.
         * @param content   Accepts message text string or array of strings.
         * @param username  Name to create (or get) DM for room ID to use in send.
         */
        BotClient.prototype.sendDirectToUser = function (content, username) {
            var _this = this;
            return this.getDirectMessageRoomId(username)
                .then(function (rid) { return _this.sendToRoomId(content, rid); });
        };
        /**
         * Get ID for a DM room by its recipient's name.
         * Will create a DM (with the bot) if it doesn't exist already.
         * @todo test why create resolves with object instead of simply ID
         */
        BotClient.prototype.getDirectMessageRoomId = function (username) {
            return this.createDirectMessage(username).then(function (DM) {
                return DM._id;
            });
        };
        return BotClient;
    }(Rocketchat_1$1.default));
    Bot.default = BotClient;

    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(sdk, "__esModule", { value: true });
    var settings$1 = __importStar(settings$2);
    sdk.settings = settings$1;
    var Livechat_1 = __importDefault(Livechat$1);
    sdk.Livechat = Livechat_1.default;
    var Bot_1 = __importDefault(Bot);
    sdk.Bot = Bot_1.default;
    var Rocketchat_1 = __importDefault(Rocketchat$1);
    var Rocketchat = sdk.Rocketchat = Rocketchat_1.default;

    /*! js-cookie v3.0.1 | MIT */
    /* eslint-disable no-var */
    function assign (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          target[key] = source[key];
        }
      }
      return target
    }
    /* eslint-enable no-var */

    /* eslint-disable no-var */
    var defaultConverter = {
      read: function (value) {
        if (value[0] === '"') {
          value = value.slice(1, -1);
        }
        return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
      },
      write: function (value) {
        return encodeURIComponent(value).replace(
          /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
          decodeURIComponent
        )
      }
    };
    /* eslint-enable no-var */

    /* eslint-disable no-var */

    function init (converter, defaultAttributes) {
      function set (key, value, attributes) {
        if (typeof document === 'undefined') {
          return
        }

        attributes = assign({}, defaultAttributes, attributes);

        if (typeof attributes.expires === 'number') {
          attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
        }
        if (attributes.expires) {
          attributes.expires = attributes.expires.toUTCString();
        }

        key = encodeURIComponent(key)
          .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
          .replace(/[()]/g, escape);

        var stringifiedAttributes = '';
        for (var attributeName in attributes) {
          if (!attributes[attributeName]) {
            continue
          }

          stringifiedAttributes += '; ' + attributeName;

          if (attributes[attributeName] === true) {
            continue
          }

          // Considers RFC 6265 section 5.2:
          // ...
          // 3.  If the remaining unparsed-attributes contains a %x3B (";")
          //     character:
          // Consume the characters of the unparsed-attributes up to,
          // not including, the first %x3B (";") character.
          // ...
          stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
        }

        return (document.cookie =
          key + '=' + converter.write(value, key) + stringifiedAttributes)
      }

      function get (key) {
        if (typeof document === 'undefined' || (arguments.length && !key)) {
          return
        }

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all.
        var cookies = document.cookie ? document.cookie.split('; ') : [];
        var jar = {};
        for (var i = 0; i < cookies.length; i++) {
          var parts = cookies[i].split('=');
          var value = parts.slice(1).join('=');

          try {
            var foundKey = decodeURIComponent(parts[0]);
            jar[foundKey] = converter.read(value, foundKey);

            if (key === foundKey) {
              break
            }
          } catch (e) {}
        }

        return key ? jar[key] : jar
      }

      return Object.create(
        {
          set: set,
          get: get,
          remove: function (key, attributes) {
            set(
              key,
              '',
              assign({}, attributes, {
                expires: -1
              })
            );
          },
          withAttributes: function (attributes) {
            return init(this.converter, assign({}, this.attributes, attributes))
          },
          withConverter: function (converter) {
            return init(assign({}, this.converter, converter), this.attributes)
          }
        },
        {
          attributes: { value: Object.freeze(defaultAttributes) },
          converter: { value: Object.freeze(converter) }
        }
      )
    }

    var api = init(defaultConverter, { path: '/' });

    var RC_USER_TOKEN_COOKIE = 'rc_token';
    var RC_USER_ID_COOKIE = 'rc_uid';
    var RC_USER_NAME_COOKIE = 'rc_username';

    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }

    // utils is a library of generic helper functions non-specific to axios

    const {toString} = Object.prototype;
    const {getPrototypeOf} = Object;

    const kindOf = (cache => thing => {
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));

    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type
    };

    const typeOfTest = type => thing => typeof thing === type;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     *
     * @returns {boolean} True if value is an Array, otherwise false
     */
    const {isArray} = Array;

    /**
     * Determine if a value is undefined
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    const isUndefined = typeOfTest('undefined');

    /**
     * Determine if a value is a Buffer
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    const isArrayBuffer = kindOfTest('ArrayBuffer');


    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      let result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a String, otherwise false
     */
    const isString = typeOfTest('string');

    /**
     * Determine if a value is a Function
     *
     * @param {*} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    const isFunction = typeOfTest('function');

    /**
     * Determine if a value is a Number
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Number, otherwise false
     */
    const isNumber = typeOfTest('number');

    /**
     * Determine if a value is an Object
     *
     * @param {*} thing The value to test
     *
     * @returns {boolean} True if value is an Object, otherwise false
     */
    const isObject$1 = (thing) => thing !== null && typeof thing === 'object';

    /**
     * Determine if a value is a Boolean
     *
     * @param {*} thing The value to test
     * @returns {boolean} True if value is a Boolean, otherwise false
     */
    const isBoolean = thing => thing === true || thing === false;

    /**
     * Determine if a value is a plain Object
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a plain Object, otherwise false
     */
    const isPlainObject$1 = (val) => {
      if (kindOf(val) !== 'object') {
        return false;
      }

      const prototype = getPrototypeOf(val);
      return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };

    /**
     * Determine if a value is a Date
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Date, otherwise false
     */
    const isDate$1 = kindOfTest('Date');

    /**
     * Determine if a value is a File
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a File, otherwise false
     */
    const isFile = kindOfTest('File');

    /**
     * Determine if a value is a Blob
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    const isBlob = kindOfTest('Blob');

    /**
     * Determine if a value is a FileList
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a File, otherwise false
     */
    const isFileList = kindOfTest('FileList');

    /**
     * Determine if a value is a Stream
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    const isStream = (val) => isObject$1(val) && isFunction(val.pipe);

    /**
     * Determine if a value is a FormData
     *
     * @param {*} thing The value to test
     *
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    const isFormData = (thing) => {
      const pattern = '[object FormData]';
      return thing && (
        (typeof FormData === 'function' && thing instanceof FormData) ||
        toString.call(thing) === pattern ||
        (isFunction(thing.toString) && thing.toString() === pattern)
      );
    };

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    const isURLSearchParams = kindOfTest('URLSearchParams');

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     *
     * @returns {String} The String freed of excess whitespace
     */
    const trim = (str) => str.trim ?
      str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     *
     * @param {Boolean} [allOwnKeys = false]
     * @returns {any}
     */
    function forEach(obj, fn, {allOwnKeys = false} = {}) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      let i;
      let l;

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;

        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }

    function findKey$1(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }

    const _global = (() => {
      /*eslint no-undef:0*/
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
    })();

    const isContextDefined = (context) => !isUndefined(context) && context !== _global;

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     *
     * @returns {Object} Result of all merge properties
     */
    function merge$1(/* obj1, obj2, obj3, ... */) {
      const {caseless} = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey$1(result, key) || key;
        if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
          result[targetKey] = merge$1(result[targetKey], val);
        } else if (isPlainObject$1(val)) {
          result[targetKey] = merge$1({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };

      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     *
     * @param {Boolean} [allOwnKeys]
     * @returns {Object} The resulting value of object a
     */
    const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, {allOwnKeys});
      return a;
    };

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     *
     * @returns {string} content value without BOM
     */
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    };

    /**
     * Inherit the prototype methods from one constructor into another
     * @param {function} constructor
     * @param {function} superConstructor
     * @param {object} [props]
     * @param {object} [descriptors]
     *
     * @returns {void}
     */
    const inherits = (constructor, superConstructor, props, descriptors) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, 'super', {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };

    /**
     * Resolve object with deep prototype chain to a flat object
     * @param {Object} sourceObj source object
     * @param {Object} [destObj]
     * @param {Function|Boolean} [filter]
     * @param {Function} [propFilter]
     *
     * @returns {Object}
     */
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};

      destObj = destObj || {};
      // eslint-disable-next-line no-eq-null,eqeqeq
      if (sourceObj == null) return destObj;

      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

      return destObj;
    };

    /**
     * Determines whether a string ends with the characters of a specified string
     *
     * @param {String} str
     * @param {String} searchString
     * @param {Number} [position= 0]
     *
     * @returns {boolean}
     */
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === undefined || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };


    /**
     * Returns new array from array like object or null if failed
     *
     * @param {*} [thing]
     *
     * @returns {?Array}
     */
    const toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };

    /**
     * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
     * thing passed in is an instance of Uint8Array
     *
     * @param {TypedArray}
     *
     * @returns {Array}
     */
    // eslint-disable-next-line func-names
    const isTypedArray = (TypedArray => {
      // eslint-disable-next-line func-names
      return thing => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

    /**
     * For each entry in the object, call the function with the key and value.
     *
     * @param {Object<any, any>} obj - The object to iterate over.
     * @param {Function} fn - The function to call for each entry.
     *
     * @returns {void}
     */
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];

      const iterator = generator.call(obj);

      let result;

      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };

    /**
     * It takes a regular expression and a string, and returns an array of all the matches
     *
     * @param {string} regExp - The regular expression to match against.
     * @param {string} str - The string to search.
     *
     * @returns {Array<boolean>}
     */
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];

      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }

      return arr;
    };

    /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
    const isHTMLForm = kindOfTest('HTMLFormElement');

    const toCamelCase = str => {
      return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };

    /* Creating a function that will check if an object has a property. */
    const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

    /**
     * Determine if a value is a RegExp object
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a RegExp object, otherwise false
     */
    const isRegExp = kindOfTest('RegExp');

    const reduceDescriptors = (obj, reducer) => {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};

      forEach(descriptors, (descriptor, name) => {
        if (reducer(descriptor, name, obj) !== false) {
          reducedDescriptors[name] = descriptor;
        }
      });

      Object.defineProperties(obj, reducedDescriptors);
    };

    /**
     * Makes all methods read-only
     * @param {Object} obj
     */

    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        // skip restricted props in strict mode
        if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
          return false;
        }

        const value = obj[name];

        if (!isFunction(value)) return;

        descriptor.enumerable = false;

        if ('writable' in descriptor) {
          descriptor.writable = false;
          return;
        }

        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error('Can not rewrite read-only method \'' + name + '\'');
          };
        }
      });
    };

    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};

      const define = (arr) => {
        arr.forEach(value => {
          obj[value] = true;
        });
      };

      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

      return obj;
    };

    const noop$2 = () => {};

    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };

    const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

    const DIGIT = '0123456789';

    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };

    const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = '';
      const {length} = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length|0];
      }

      return str;
    };

    /**
     * If the thing is a FormData object, return true, otherwise return false.
     *
     * @param {unknown} thing - The thing to check.
     *
     * @returns {boolean}
     */
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
    }

    const toJSONObject = (obj) => {
      const stack = new Array(10);

      const visit = (source, i) => {

        if (isObject$1(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }

          if(!('toJSON' in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};

            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });

            stack[i] = undefined;

            return target;
          }
        }

        return source;
      };

      return visit(obj, 0);
    };

    var utils = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject: isObject$1,
      isPlainObject: isPlainObject$1,
      isUndefined,
      isDate: isDate$1,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge: merge$1,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$2,
      toFiniteNumber,
      findKey: findKey$1,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [config] The config.
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     *
     * @returns {Error} The created error.
     */
    function AxiosError(message, code, config, request, response) {
      Error.call(this);

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = (new Error()).stack;
      }

      this.message = message;
      this.name = 'AxiosError';
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }

    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });

    const prototype$1 = AxiosError.prototype;
    const descriptors = {};

    [
      'ERR_BAD_OPTION_VALUE',
      'ERR_BAD_OPTION',
      'ECONNABORTED',
      'ETIMEDOUT',
      'ERR_NETWORK',
      'ERR_FR_TOO_MANY_REDIRECTS',
      'ERR_DEPRECATED',
      'ERR_BAD_RESPONSE',
      'ERR_BAD_REQUEST',
      'ERR_CANCELED',
      'ERR_NOT_SUPPORT',
      'ERR_INVALID_URL'
    // eslint-disable-next-line func-names
    ].forEach(code => {
      descriptors[code] = {value: code};
    });

    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

    // eslint-disable-next-line func-names
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);

      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, prop => {
        return prop !== 'isAxiosError';
      });

      AxiosError.call(axiosError, error.message, code, config, request, response);

      axiosError.cause = error;

      axiosError.name = error.name;

      customProps && Object.assign(axiosError, customProps);

      return axiosError;
    };

    // eslint-disable-next-line strict
    var httpAdapter = null;

    /**
     * Determines if the given thing is a array or js object.
     *
     * @param {string} thing - The object or array to be visited.
     *
     * @returns {boolean}
     */
    function isVisitable(thing) {
      return utils.isPlainObject(thing) || utils.isArray(thing);
    }

    /**
     * It removes the brackets from the end of a string
     *
     * @param {string} key - The key of the parameter.
     *
     * @returns {string} the key without the brackets.
     */
    function removeBrackets(key) {
      return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
    }

    /**
     * It takes a path, a key, and a boolean, and returns a string
     *
     * @param {string} path - The path to the current key.
     * @param {string} key - The key of the current object being iterated over.
     * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
     *
     * @returns {string} The path to the current key.
     */
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? '[' + token + ']' : token;
      }).join(dots ? '.' : '');
    }

    /**
     * If the array is an array and none of its elements are visitable, then it's a flat array.
     *
     * @param {Array<any>} arr - The array to check
     *
     * @returns {boolean}
     */
    function isFlatArray(arr) {
      return utils.isArray(arr) && !arr.some(isVisitable);
    }

    const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });

    /**
     * Convert a data object to FormData
     *
     * @param {Object} obj
     * @param {?Object} [formData]
     * @param {?Object} [options]
     * @param {Function} [options.visitor]
     * @param {Boolean} [options.metaTokens = true]
     * @param {Boolean} [options.dots = false]
     * @param {?Boolean} [options.indexes = false]
     *
     * @returns {Object}
     **/

    /**
     * It converts an object into a FormData object
     *
     * @param {Object<any, any>} obj - The object to convert to form data.
     * @param {string} formData - The FormData object to append to.
     * @param {Object<string, any>} options
     *
     * @returns
     */
    function toFormData(obj, formData, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError('target must be an object');
      }

      // eslint-disable-next-line no-param-reassign
      formData = formData || new (FormData)();

      // eslint-disable-next-line no-param-reassign
      options = utils.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !utils.isUndefined(source[option]);
      });

      const metaTokens = options.metaTokens;
      // eslint-disable-next-line no-use-before-define
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
      const useBlob = _Blob && utils.isSpecCompliantForm(formData);

      if (!utils.isFunction(visitor)) {
        throw new TypeError('visitor must be a function');
      }

      function convertValue(value) {
        if (value === null) return '';

        if (utils.isDate(value)) {
          return value.toISOString();
        }

        if (!useBlob && utils.isBlob(value)) {
          throw new AxiosError('Blob is not supported. Use a Buffer instead.');
        }

        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
        }

        return value;
      }

      /**
       * Default visitor.
       *
       * @param {*} value
       * @param {String|Number} key
       * @param {Array<String|Number>} path
       * @this {FormData}
       *
       * @returns {boolean} return true to visit the each prop of the value recursively
       */
      function defaultVisitor(value, key, path) {
        let arr = value;

        if (value && !path && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            key = metaTokens ? key : key.slice(0, -2);
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (
            (utils.isArray(value) && isFlatArray(value)) ||
            (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))
            )) {
            // eslint-disable-next-line no-param-reassign
            key = removeBrackets(key);

            arr.forEach(function each(el, index) {
              !(utils.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
                convertValue(el)
              );
            });
            return false;
          }
        }

        if (isVisitable(value)) {
          return true;
        }

        formData.append(renderKey(path, key, dots), convertValue(value));

        return false;
      }

      const stack = [];

      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });

      function build(value, path) {
        if (utils.isUndefined(value)) return;

        if (stack.indexOf(value) !== -1) {
          throw Error('Circular reference detected in ' + path.join('.'));
        }

        stack.push(value);

        utils.forEach(value, function each(el, key) {
          const result = !(utils.isUndefined(el) || el === null) && visitor.call(
            formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
          );

          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });

        stack.pop();
      }

      if (!utils.isObject(obj)) {
        throw new TypeError('data must be an object');
      }

      build(obj);

      return formData;
    }

    /**
     * It encodes a string by replacing all characters that are not in the unreserved set with
     * their percent-encoded equivalents
     *
     * @param {string} str - The string to encode.
     *
     * @returns {string} The encoded string.
     */
    function encode$1(str) {
      const charMap = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '~': '%7E',
        '%20': '+',
        '%00': '\x00'
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }

    /**
     * It takes a params object and converts it to a FormData object
     *
     * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
     * @param {Object<string, any>} options - The options object passed to the Axios constructor.
     *
     * @returns {void}
     */
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];

      params && toFormData(params, this, options);
    }

    const prototype = AxiosURLSearchParams.prototype;

    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };

    prototype.toString = function toString(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;

      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + '=' + _encode(pair[1]);
      }, '').join('&');
    };

    /**
     * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
     * URI encoded counterparts
     *
     * @param {string} val The value to be encoded.
     *
     * @returns {string} The encoded value.
     */
    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @param {?object} options
     *
     * @returns {string} The formatted url
     */
    function buildURL(url, params, options) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }
      
      const _encode = options && options.encode || encode;

      const serializeFn = options && options.serialize;

      let serializedParams;

      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils.isURLSearchParams(params) ?
          params.toString() :
          new AxiosURLSearchParams(params, options).toString(_encode);
      }

      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");

        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    }

    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }

      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }

      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }

      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }

      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    }

    var InterceptorManager$1 = InterceptorManager;

    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };

    var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

    var FormData$1 = FormData;

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     *
     * @returns {boolean}
     */
    const isStandardBrowserEnv = (() => {
      let product;
      if (typeof navigator !== 'undefined' && (
        (product = navigator.product) === 'ReactNative' ||
        product === 'NativeScript' ||
        product === 'NS')
      ) {
        return false;
      }

      return typeof window !== 'undefined' && typeof document !== 'undefined';
    })();

    /**
     * Determine if we're running in a standard browser webWorker environment
     *
     * Although the `isStandardBrowserEnv` method indicates that
     * `allows axios to run in a web worker`, the WebWorker will still be
     * filtered out due to its judgment standard
     * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
     * This leads to a problem when axios post `FormData` in webWorker
     */
     const isStandardBrowserWebWorkerEnv = (() => {
      return (
        typeof WorkerGlobalScope !== 'undefined' &&
        // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope &&
        typeof self.importScripts === 'function'
      );
    })();


    var platform = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob
      },
      isStandardBrowserEnv,
      isStandardBrowserWebWorkerEnv,
      protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
    };

    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils.isBuffer(value)) {
            this.append(key, value.toString('base64'));
            return false;
          }

          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }

    /**
     * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
     *
     * @param {string} name - The name of the property to get.
     *
     * @returns An array of strings.
     */
    function parsePropPath(name) {
      // foo[x][y][z]
      // foo.x.y.z
      // foo-x-y-z
      // foo x y z
      return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
        return match[0] === '[]' ? '' : match[1] || match[0];
      });
    }

    /**
     * Convert an array to an object.
     *
     * @param {Array<any>} arr - The array to convert to an object.
     *
     * @returns An object with the same keys and values as the array.
     */
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }

    /**
     * It takes a FormData object and returns a JavaScript object
     *
     * @param {string} formData The FormData object to convert to JSON.
     *
     * @returns {Object<string, any> | null} The converted object.
     */
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils.isArray(target) ? target.length : name;

        if (isLast) {
          if (utils.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }

          return !isNumericKey;
        }

        if (!target[name] || !utils.isObject(target[name])) {
          target[name] = [];
        }

        const result = buildPath(path, value, target[name], index);

        if (result && utils.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }

        return !isNumericKey;
      }

      if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
        const obj = {};

        utils.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });

        return obj;
      }

      return null;
    }

    const DEFAULT_CONTENT_TYPE = {
      'Content-Type': undefined
    };

    /**
     * It takes a string, tries to parse it, and if it fails, it returns the stringified version
     * of the input
     *
     * @param {any} rawValue - The value to be stringified.
     * @param {Function} parser - A function that parses a string into a JavaScript object.
     * @param {Function} encoder - A function that takes a value and returns a string.
     *
     * @returns {string} A stringified version of the rawValue.
     */
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }

      return (encoder || JSON.stringify)(rawValue);
    }

    const defaults$1 = {

      transitional: transitionalDefaults,

      adapter: ['xhr', 'http'],

      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || '';
        const hasJSONContentType = contentType.indexOf('application/json') > -1;
        const isObjectPayload = utils.isObject(data);

        if (isObjectPayload && utils.isHTMLForm(data)) {
          data = new FormData(data);
        }

        const isFormData = utils.isFormData(data);

        if (isFormData) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }

        if (utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
          return data.toString();
        }

        let isFileList;

        if (isObjectPayload) {
          if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }

          if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
            const _FormData = this.env && this.env.FormData;

            return toFormData(
              isFileList ? {'files[]': data} : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }

        if (isObjectPayload || hasJSONContentType ) {
          headers.setContentType('application/json', false);
          return stringifySafely(data);
        }

        return data;
      }],

      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$1.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === 'json';

        if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;

          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },

      headers: {
        common: {
          'Accept': 'application/json, text/plain, */*'
        }
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults$1.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults$1.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults$2 = defaults$1;

    // RawAxiosHeaders whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    const ignoreDuplicateOf = utils.toObjectSet([
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ]);

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} rawHeaders Headers needing to be parsed
     *
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = rawHeaders => {
      const parsed = {};
      let key;
      let val;
      let i;

      rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
        i = line.indexOf(':');
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();

        if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
          return;
        }

        if (key === 'set-cookie') {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      });

      return parsed;
    };

    const $internals = Symbol('internals');

    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }

    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }

      return utils.isArray(value) ? value.map(normalizeValue) : String(value);
    }

    function parseTokens(str) {
      const tokens = Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;

      while ((match = tokensRE.exec(str))) {
        tokens[match[1]] = match[2];
      }

      return tokens;
    }

    function isValidHeaderName(str) {
      return /^[-_a-zA-Z]+$/.test(str.trim());
    }

    function matchHeaderValue(context, value, header, filter) {
      if (utils.isFunction(filter)) {
        return filter.call(this, value, header);
      }

      if (!utils.isString(value)) return;

      if (utils.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }

      if (utils.isRegExp(filter)) {
        return filter.test(value);
      }
    }

    function formatHeader(header) {
      return header.trim()
        .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
          return char.toUpperCase() + str;
        });
    }

    function buildAccessors(obj, header) {
      const accessorName = utils.toCamelCase(' ' + header);

      ['get', 'set', 'has'].forEach(methodName => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }

    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }

      set(header, valueOrRewrite, rewrite) {
        const self = this;

        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);

          if (!lHeader) {
            throw new Error('header name must be a non-empty string');
          }

          const key = utils.findKey(self, lHeader);

          if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
            self[key || _header] = normalizeValue(_value);
          }
        }

        const setHeaders = (headers, _rewrite) =>
          utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

        if (utils.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }

        return this;
      }

      get(header, parser) {
        header = normalizeHeader(header);

        if (header) {
          const key = utils.findKey(this, header);

          if (key) {
            const value = this[key];

            if (!parser) {
              return value;
            }

            if (parser === true) {
              return parseTokens(value);
            }

            if (utils.isFunction(parser)) {
              return parser.call(this, value, key);
            }

            if (utils.isRegExp(parser)) {
              return parser.exec(value);
            }

            throw new TypeError('parser must be boolean|regexp|function');
          }
        }
      }

      has(header, matcher) {
        header = normalizeHeader(header);

        if (header) {
          const key = utils.findKey(this, header);

          return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }

        return false;
      }

      delete(header, matcher) {
        const self = this;
        let deleted = false;

        function deleteHeader(_header) {
          _header = normalizeHeader(_header);

          if (_header) {
            const key = utils.findKey(self, _header);

            if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
              delete self[key];

              deleted = true;
            }
          }
        }

        if (utils.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }

        return deleted;
      }

      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;

        while (i--) {
          const key = keys[i];
          if(!matcher || matchHeaderValue(this, this[key], key, matcher)) {
            delete this[key];
            deleted = true;
          }
        }

        return deleted;
      }

      normalize(format) {
        const self = this;
        const headers = {};

        utils.forEach(this, (value, header) => {
          const key = utils.findKey(headers, header);

          if (key) {
            self[key] = normalizeValue(value);
            delete self[header];
            return;
          }

          const normalized = format ? formatHeader(header) : String(header).trim();

          if (normalized !== header) {
            delete self[header];
          }

          self[normalized] = normalizeValue(value);

          headers[normalized] = true;
        });

        return this;
      }

      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }

      toJSON(asStrings) {
        const obj = Object.create(null);

        utils.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
        });

        return obj;
      }

      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }

      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
      }

      get [Symbol.toStringTag]() {
        return 'AxiosHeaders';
      }

      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }

      static concat(first, ...targets) {
        const computed = new this(first);

        targets.forEach((target) => computed.set(target));

        return computed;
      }

      static accessor(header) {
        const internals = this[$internals] = (this[$internals] = {
          accessors: {}
        });

        const accessors = internals.accessors;
        const prototype = this.prototype;

        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);

          if (!accessors[lHeader]) {
            buildAccessors(prototype, _header);
            accessors[lHeader] = true;
          }
        }

        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

        return this;
      }
    }

    AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

    utils.freezeMethods(AxiosHeaders.prototype);
    utils.freezeMethods(AxiosHeaders);

    var AxiosHeaders$1 = AxiosHeaders;

    /**
     * Transform the data for a request or a response
     *
     * @param {Array|Function} fns A single function or Array of functions
     * @param {?Object} response The response object
     *
     * @returns {*} The resulting transformed data
     */
    function transformData(fns, response) {
      const config = this || defaults$2;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;

      utils.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
      });

      headers.normalize();

      return data;
    }

    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }

    /**
     * A `CanceledError` is an object that is thrown when an operation is canceled.
     *
     * @param {string=} message The message.
     * @param {Object=} config The config.
     * @param {Object=} request The request.
     *
     * @returns {CanceledError} The created error.
     */
    function CanceledError(message, config, request) {
      // eslint-disable-next-line no-eq-null,eqeqeq
      AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
      this.name = 'CanceledError';
    }

    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     *
     * @returns {object} The response.
     */
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          'Request failed with status code ' + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }

    var cookies = platform.isStandardBrowserEnv ?

    // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            const cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

    // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })();

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     *
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     *
     * @returns {string} The combined URL
     */
    function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    }

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     *
     * @returns {string} The combined full path
     */
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }

    var isURLSameOrigin = platform.isStandardBrowserEnv ?

    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement('a');
        let originURL;

        /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
        function resolveURL(url) {
          let href = url;

          if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
              urlParsingNode.pathname :
              '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
        return function isURLSameOrigin(requestURL) {
          const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
              parsed.host === originURL.host);
        };
      })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })();

    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || '';
    }

    /**
     * Calculate data maxRate
     * @param {Number} [samplesCount= 10]
     * @param {Number} [min= 1000]
     * @returns {Function}
     */
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;

      min = min !== undefined ? min : 1000;

      return function push(chunkLength) {
        const now = Date.now();

        const startedAt = timestamps[tail];

        if (!firstSampleTS) {
          firstSampleTS = now;
        }

        bytes[head] = chunkLength;
        timestamps[head] = now;

        let i = tail;
        let bytesCount = 0;

        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }

        head = (head + 1) % samplesCount;

        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }

        if (now - firstSampleTS < min) {
          return;
        }

        const passed = startedAt && now - startedAt;

        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
      };
    }

    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);

      return e => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;

        bytesNotified = loaded;

        const data = {
          loaded,
          total,
          progress: total ? (loaded / total) : undefined,
          bytes: progressBytes,
          rate: rate ? rate : undefined,
          estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
          event: e
        };

        data[isDownloadStream ? 'download' : 'upload'] = true;

        listener(data);
      };
    }

    const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

    var xhrAdapter = isXHRAdapterSupported && function (config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }

          if (config.signal) {
            config.signal.removeEventListener('abort', onCanceled);
          }
        }

        if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
          requestHeaders.setContentType(false); // Let the browser set it
        }

        let request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          const username = config.auth.username || '';
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
        }

        const fullPath = buildFullPath(config.baseURL, config.url);

        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          const responseHeaders = AxiosHeaders$1.from(
            'getAllResponseHeaders' in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
            request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };

          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);

          // Clean up request
          request = null;
        }

        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (platform.isStandardBrowserEnv) {
          // Add xsrf header
          const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
            && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }

        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
        }

        if (config.cancelToken || config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = cancel => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };

          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
          }
        }

        const protocol = parseProtocol(fullPath);

        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
          return;
        }


        // Send the request
        request.send(requestData || null);
      });
    };

    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };

    utils.forEach(knownAdapters, (fn, value) => {
      if(fn) {
        try {
          Object.defineProperty(fn, 'name', {value});
        } catch (e) {
          // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, 'adapterName', {value});
      }
    });

    var adapters = {
      getAdapter: (adapters) => {
        adapters = utils.isArray(adapters) ? adapters : [adapters];

        const {length} = adapters;
        let nameOrAdapter;
        let adapter;

        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters[i];
          if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
            break;
          }
        }

        if (!adapter) {
          if (adapter === false) {
            throw new AxiosError(
              `Adapter ${nameOrAdapter} is not supported by the environment`,
              'ERR_NOT_SUPPORT'
            );
          }

          throw new Error(
            utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
              `Adapter '${nameOrAdapter}' is not available in the build` :
              `Unknown adapter '${nameOrAdapter}'`
          );
        }

        if (!utils.isFunction(adapter)) {
          throw new TypeError('adapter is not a function');
        }

        return adapter;
      },
      adapters: knownAdapters
    };

    /**
     * Throws a `CanceledError` if cancellation has been requested.
     *
     * @param {Object} config The config that is to be used for the request
     *
     * @returns {void}
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }

      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      config.headers = AxiosHeaders$1.from(config.headers);

      // Transform request data
      config.data = transformData.call(
        config,
        config.transformRequest
      );

      if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
        config.headers.setContentType('application/x-www-form-urlencoded', false);
      }

      const adapter = adapters.getAdapter(config.adapter || defaults$2.adapter);

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );

        response.headers = AxiosHeaders$1.from(response.headers);

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }

        return Promise.reject(reason);
      });
    }

    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     *
     * @returns {Object} New object resulting from merging config2 to config1
     */
    function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      const config = {};

      function getMergedValue(target, source, caseless) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge.call({caseless}, target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      // eslint-disable-next-line consistent-return
      function mergeDeepProperties(a, b, caseless) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils.isUndefined(a)) {
          return getMergedValue(undefined, a, caseless);
        }
      }

      // eslint-disable-next-line consistent-return
      function valueFromConfig2(a, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(undefined, b);
        }
      }

      // eslint-disable-next-line consistent-return
      function defaultToConfig2(a, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(undefined, b);
        } else if (!utils.isUndefined(a)) {
          return getMergedValue(undefined, a);
        }
      }

      // eslint-disable-next-line consistent-return
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(undefined, a);
        }
      }

      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };

      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
      });

      return config;
    }

    const VERSION = "1.3.0";

    const validators$1 = {};

    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
      validators$1[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });

    const deprecatedWarnings = {};

    /**
     * Transitional option validator
     *
     * @param {function|boolean?} validator - set to false if the transitional option has been removed
     * @param {string?} version - deprecated version / removed since version
     * @param {string?} message - some message with additional info
     *
     * @returns {function}
     */
    validators$1.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }

      // eslint-disable-next-line func-names
      return (value, opt, opts) => {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
            AxiosError.ERR_DEPRECATED
          );
        }

        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }

        return validator ? validator(value, opt, opts) : true;
      };
    };

    /**
     * Assert object's properties type
     *
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     *
     * @returns {object}
     */

    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
          const value = options[opt];
          const result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }

    var validator = {
      assertOptions,
      validators: validators$1
    };

    const validators = validator.validators;

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     *
     * @return {Axios} A new instance of Axios
     */
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }

      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/
        // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === 'string') {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }

        config = mergeConfig(this.defaults, config);

        const {transitional, paramsSerializer, headers} = config;

        if (transitional !== undefined) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }

        if (paramsSerializer !== undefined) {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }

        // Set config.method
        config.method = (config.method || this.defaults.method || 'get').toLowerCase();

        let contextHeaders;

        // Flatten headers
        contextHeaders = headers && utils.merge(
          headers.common,
          headers[config.method]
        );

        contextHeaders && utils.forEach(
          ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
          (method) => {
            delete headers[method];
          }
        );

        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
            return;
          }

          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });

        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });

        let promise;
        let i = 0;
        let len;

        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), undefined];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;

          promise = Promise.resolve(config);

          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }

          return promise;
        }

        len = requestInterceptorChain.length;

        let newConfig = config;

        i = 0;

        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }

        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }

        i = 0;
        len = responseInterceptorChain.length;

        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }

        return promise;
      }

      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/

      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              'Content-Type': 'multipart/form-data'
            } : {},
            url,
            data
          }));
        };
      }

      Axios.prototype[method] = generateHTTPMethod();

      Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
    });

    var Axios$1 = Axios;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @param {Function} executor The executor function.
     *
     * @returns {CancelToken}
     */
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== 'function') {
          throw new TypeError('executor must be a function.');
        }

        let resolvePromise;

        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });

        const token = this;

        // eslint-disable-next-line func-names
        this.promise.then(cancel => {
          if (!token._listeners) return;

          let i = token._listeners.length;

          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });

        // eslint-disable-next-line func-names
        this.promise.then = onfulfilled => {
          let _resolve;
          // eslint-disable-next-line func-names
          const promise = new Promise(resolve => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);

          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };

          return promise;
        };

        executor(function cancel(message, config, request) {
          if (token.reason) {
            // Cancellation has already been requested
            return;
          }

          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }

      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }

      /**
       * Subscribe to the cancel signal
       */

      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }

        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }

      /**
       * Unsubscribe from the cancel signal
       */

      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }

      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    }

    var CancelToken$1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     *
     * @returns {Function}
     */
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     *
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    function isAxiosError(payload) {
      return utils.isObject(payload) && (payload.isAxiosError === true);
    }

    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
    };

    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });

    var HttpStatusCode$1 = HttpStatusCode;

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     *
     * @returns {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

      // Copy context to instance
      utils.extend(instance, context, null, {allOwnKeys: true});

      // Factory for creating new instances
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };

      return instance;
    }

    // Create the default instance to be exported
    const axios = createInstance(defaults$2);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios$1;

    // Expose Cancel & CancelToken
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;

    // Expose AxiosError class
    axios.AxiosError = AxiosError;

    // alias for CanceledError for backward compatibility
    axios.Cancel = axios.CanceledError;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };

    axios.spread = spread;

    // Expose isAxiosError
    axios.isAxiosError = isAxiosError;

    // Expose mergeConfig
    axios.mergeConfig = mergeConfig;

    axios.AxiosHeaders = AxiosHeaders$1;

    axios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

    axios.HttpStatusCode = HttpStatusCode$1;

    axios.default = axios;

    // this module should only have a default export
    var axios$1 = axios;

    var axiosInstance = axios$1.create({
        timeout: 10000,
        responseType: 'json',
        headers: {
            'Content-Type': 'application/json',
        },
    });
    axiosInstance.interceptors.request.use(function (config) { return __awaiter$5(void 0, void 0, void 0, function () {
        return __generator$5(this, function (_a) {
            config.headers = __assign$6(__assign$6({}, config.headers), { 'X-Auth-Token': api.get(RC_USER_TOKEN_COOKIE), 'X-User-Id': api.get(RC_USER_ID_COOKIE) });
            return [2 /*return*/, config];
        });
    }); });
    axiosInstance.interceptors.response.use(function (response) {
        return response;
    }, function (error) {
        return Promise.reject(error.response);
    });
    var get$1 = function (url, queryParams) {
        var config = {
            params: queryParams
        };
        return axiosInstance.get(url, config).then(function (res) { return res.data; });
    };
    var post = function (url, data, config) {
        return axiosInstance.post(url, data, config).then(function (res) { return res.data; });
    };

    var Uploader = /** @class */ (function () {
        function Uploader() {
            this.store = new Map();
        }
        Uploader.prototype.getFile = function (id) {
            var item = this.store.get(id);
            return item === null || item === void 0 ? void 0 : item.file;
        };
        Uploader.prototype.add = function (id, issue) {
            this.store.set(id, issue);
        };
        Uploader.prototype.remove = function (id) {
            this.store.delete(id);
        };
        Uploader.prototype.cancel = function (id) {
            var item = this.store.get(id);
            if (item) {
                item.controller.abort();
                this.store.delete(id);
            }
        };
        return Uploader;
    }());

    var EventType;
    (function (EventType) {
        EventType["TYPING"] = "typing";
        EventType["DELETE_MESSAGE"] = "deleteMessage";
    })(EventType || (EventType = {}));

    var RcService = /** @class */ (function () {
        function RcService(config) {
            this.host = config.host;
            this.rid = config.rId;
            this.dmUid = config.dmUid;
            this.dmUsername = config.dmUsername;
            this.uploaderStore = new Uploader();
            this.rcClient = new Rocketchat({
                protocol: 'ddp',
                host: this.host,
                useSsl: !/http:\/\//.test(this.host),
            });
        }
        RcService.prototype.getHost = function () {
            return this.host;
        };
        RcService.prototype.getCookies = function () {
            return {
                rc_token: api.get(RC_USER_TOKEN_COOKIE),
                rc_uid: api.get(RC_USER_ID_COOKIE),
                rc_username: api.get(RC_USER_NAME_COOKIE),
            };
        };
        RcService.prototype.setCookies = function (uid, token, username) {
            api.set(RC_USER_TOKEN_COOKIE, token || '');
            api.set(RC_USER_ID_COOKIE, uid || '');
            api.set(RC_USER_NAME_COOKIE, username || '');
        };
        RcService.prototype.realtime = function (rid, onMessage, onStream) {
            return __awaiter$5(this, void 0, void 0, function () {
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 7, , 9]);
                            return [4 /*yield*/, this.rcClient.connect({})];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.rcClient.resume({ token: api.get(RC_USER_TOKEN_COOKIE) || '' })];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, this.rcClient.subscribe('stream-room-messages', rid)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, this.rcClient.onMessage(function (data) {
                                    data = __assign$6(__assign$6({}, data), { 
                                        // @ts-ignore
                                        ts: data.ts ? data.ts.toISOString() : null, 
                                        // @ts-ignore
                                        unread: (data === null || data === void 0 ? void 0 : data.unread) || false });
                                    onMessage(data);
                                })];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, this.rcClient.subscribeRoom(rid)];
                        case 5:
                            _a.sent();
                            return [4 /*yield*/, this.rcClient.onStreamData('stream-notify-room', function (ddpMessage) {
                                    // @ts-ignore
                                    var _a = ddpMessage.fields, eventName = _a.eventName, args = _a.args;
                                    var _b = eventName.split('/'), roomId = _b[0], event = _b[1];
                                    if (roomId !== rid) {
                                        return;
                                    }
                                    if (event === EventType.TYPING && args[0] === api.get(RC_USER_NAME_COOKIE)) {
                                        return;
                                    }
                                    onStream(event, args);
                                    // if (event === 'deleteMessage') {
                                    //     callback(ddpMessage);
                                    // }
                                })];
                        case 6:
                            _a.sent();
                            return [3 /*break*/, 9];
                        case 7:
                            _a.sent();
                            return [4 /*yield*/, this.close()];
                        case 8:
                            _a.sent();
                            return [3 /*break*/, 9];
                        case 9: return [2 /*return*/];
                    }
                });
            });
        };
        RcService.prototype.sendIsTyping = function (rid, isTyping) {
            return this.rcClient.methodCall('stream-notify-room', rid + '/typing', api.get(RC_USER_NAME_COOKIE), isTyping);
        };
        RcService.prototype.readMessages = function (rid) {
            return this.rcClient.methodCall('readMessages', rid);
        };
        RcService.prototype.close = function () {
            return __awaiter$5(this, void 0, void 0, function () {
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.rcClient)
                                return [2 /*return*/];
                            return [4 /*yield*/, this.rcClient.unsubscribeAll()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.rcClient.disconnect()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        RcService.prototype.getMessages = function (rid, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 20; }
            return get$1("".concat(this.host, "/api/v1/im.messages?roomId=").concat(rid, "&count=").concat(count, "&offset=").concat(offset));
            // try {
            //     const messages = await fetch(
            //         `${this.host}/api/v1/im.messages?roomId=${rid}&count=${count}&offset=${offset}`,
            //         {
            //             headers: {
            //                 'Content-Type': 'application/json',
            //                 'X-Auth-Token': Cookies.get(RC_USER_TOKEN_COOKIE),
            //                 'X-User-Id': Cookies.get(RC_USER_ID_COOKIE),
            //             },
            //             method: 'GET',
            //         }
            //     );
            //     return await messages.json();
            // } catch (err) {
            //     throw err
            // }
        };
        RcService.prototype.markAsRead = function (rid) {
            return post("".concat(this.host, "/api/v1/subscriptions.read"), {
                rid: rid
            });
        };
        RcService.prototype.sendMessage = function (rid, msg) {
            return post("".concat(this.host, "/api/v1/chat.sendMessage"), {
                message: {
                    rid: rid,
                    msg: msg
                }
            });
        };
        RcService.prototype.deleteMessage = function (rid, msgId) {
            return post("".concat(this.host, "/api/v1/chat.delete"), {
                roomId: rid,
                msgId: msgId,
                asUser: true
            });
        };
        RcService.prototype.me = function () {
            return get$1("".concat(this.host, "/api/v1/me"));
        };
        RcService.prototype.getRoomInfo = function (rid) {
            return get$1("".concat(this.host, "/api/v1/rooms.info?roomId=").concat(rid)).then(function (res) { return res.room; });
        };
        RcService.prototype.autoDiscoverImRoom = function (uId) {
            return __awaiter$5(this, void 0, void 0, function () {
                var u1Id, u2Id, rid1, rid2, e_1;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            u1Id = api.get(RC_USER_ID_COOKIE);
                            u2Id = uId;
                            rid1 = u1Id + u2Id;
                            rid2 = u2Id + u1Id;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, Promise.any([
                                    this.getRoomInfo(rid1),
                                    this.getRoomInfo(rid2)
                                ])];
                        case 2: return [2 /*return*/, _a.sent()];
                        case 3:
                            e_1 = _a.sent();
                            throw e_1;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        RcService.prototype.getUploadingFile = function (id) {
            return this.uploaderStore.getFile(id);
        };
        RcService.prototype.abortUpload = function (id) {
            this.uploaderStore.cancel(id);
        };
        RcService.prototype.uploadFile = function (id, rid, file, onUploadProgress) {
            var controller = new AbortController();
            this.uploaderStore.add(id, {
                file: file,
                controller: controller
            });
            return post("".concat(this.host, "/api/v1/rooms.upload/").concat(rid), {
                file: file
            }, {
                signal: controller.signal,
                headers: {
                    "Content-Type": "multipart/form-data",
                },
                onUploadProgress: function (e) {
                    onUploadProgress(id, e);
                }
            }).then(function (res) { return ({
                id: id,
                res: res
            }); }).catch(function (e) {
                throw {
                    id: id,
                    e: e
                };
            });
        };
        RcService.prototype.createImRoom = function () {
            if (!this.dmUsername)
                throw new Error('Username is not defined');
            return post("".concat(this.host, "/api/v1/im.create"), {
                username: this.dmUsername
            }).then(function (res) { return res.room; });
        };
        return RcService;
    }());

    /**
     * marked v4.2.12 - a markdown parser
     * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/markedjs/marked
     */

    /**
     * DO NOT EDIT THIS FILE
     * The code in this file is generated from files in ./src/
     */

    function getDefaults$1() {
      return {
        async: false,
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }

    let defaults = getDefaults$1();

    function changeDefaults(newDefaults) {
      defaults = newDefaults;
    }

    /**
     * Helpers
     */
    const escapeTest = /[&<>"']/;
    const escapeReplace = new RegExp(escapeTest.source, 'g');
    const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
    const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape$2(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }

      return html;
    }

    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

    /**
     * @param {string} html
     */
    function unescape$2(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    const caret = /(^|[^\[])\^/g;

    /**
     * @param {string | RegExp} regex
     * @param {string} opt
     */
    function edit(regex, opt) {
      regex = typeof regex === 'string' ? regex : regex.source;
      opt = opt || '';
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(caret, '$1');
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }

    const nonWordAndColonTest = /[^\w:]/g;
    const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

    /**
     * @param {boolean} sanitize
     * @param {string} base
     * @param {string} href
     */
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape$2(href))
            .replace(nonWordAndColonTest, '')
            .toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }

    const baseUrls = {};
    const justDomain = /^[^:]+:\/*[^/]*$/;
    const protocol = /^([^:]+:)[\s\S]*$/;
    const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

    /**
     * @param {string} base
     * @param {string} href
     */
    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add _that_
        // https://tools.ietf.org/html/rfc3986#section-3
        if (justDomain.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = rtrim(base, '/', true);
        }
      }
      base = baseUrls[' ' + base];
      const relativeBase = base.indexOf(':') === -1;

      if (href.substring(0, 2) === '//') {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, '$1') + href;
      } else if (href.charAt(0) === '/') {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, '$1') + href;
      } else {
        return base + href;
      }
    }

    const noopTest = { exec: function noopTest() {} };

    function merge(obj) {
      let i = 1,
        target,
        key;

      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }

      return obj;
    }

    function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
          let escaped = false,
            curr = offset;
          while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
          if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
          } else {
            // add space before unescaped |
            return ' |';
          }
        }),
        cells = row.split(/ \|/);
      let i = 0;

      // First/last cell in a row cannot be empty if it has no leading/trailing pipe
      if (!cells[0].trim()) { cells.shift(); }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) { cells.pop(); }

      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) cells.push('');
      }

      for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
    }

    /**
     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
     * /c*$/ is vulnerable to REDOS.
     *
     * @param {string} str
     * @param {string} c
     * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
     */
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return '';
      }

      // Length of suffix matching the invert condition.
      let suffLen = 0;

      // Step left until we fail to match the invert condition.
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }

      return str.slice(0, l - suffLen);
    }

    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0,
        i = 0;
      for (; i < l; i++) {
        if (str[i] === '\\') {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }

    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
      }
    }

    // copied from https://stackoverflow.com/a/5450113/806777
    /**
     * @param {string} pattern
     * @param {number} count
     */
    function repeatString(pattern, count) {
      if (count < 1) {
        return '';
      }
      let result = '';
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }

    function outputLink(cap, link, raw, lexer) {
      const href = link.href;
      const title = link.title ? escape$2(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, '$1');

      if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
          type: 'link',
          raw,
          href,
          title,
          text,
          tokens: lexer.inlineTokens(text)
        };
        lexer.state.inLink = false;
        return token;
      }
      return {
        type: 'image',
        raw,
        href,
        title,
        text: escape$2(text)
      };
    }

    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);

      if (matchIndentToCode === null) {
        return text;
      }

      const indentToCode = matchIndentToCode[1];

      return text
        .split('\n')
        .map(node => {
          const matchIndentInNode = node.match(/^\s+/);
          if (matchIndentInNode === null) {
            return node;
          }

          const [indentInNode] = matchIndentInNode;

          if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
          }

          return node;
        })
        .join('\n');
    }

    /**
     * Tokenizer
     */
    class Tokenizer {
      constructor(options) {
        this.options = options || defaults;
      }

      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: 'space',
            raw: cap[0]
          };
        }
      }

      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, '');
          return {
            type: 'code',
            raw: cap[0],
            codeBlockStyle: 'indented',
            text: !this.options.pedantic
              ? rtrim(text, '\n')
              : text
          };
        }
      }

      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || '');

          return {
            type: 'code',
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
            text
          };
        }
      }

      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();

          // remove trailing #s
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, '#');
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              // CommonMark requires space before trailing #s
              text = trimmed.trim();
            }
          }

          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }

      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: 'hr',
            raw: cap[0]
          };
        }
      }

      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *>[ \t]?/gm, '');
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: 'blockquote',
            raw: cap[0],
            tokens,
            text
          };
        }
      }

      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,
            line, nextLine, rawLine, itemContents, endEarly;

          let bull = cap[1].trim();
          const isordered = bull.length > 1;

          const list = {
            type: 'list',
            raw: '',
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : '',
            loose: false,
            items: []
          };

          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;

          if (this.options.pedantic) {
            bull = isordered ? bull : '[*+-]';
          }

          // Get next list item
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);

          // Check if current bullet point can start a new List Item
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }

            if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
              break;
            }

            raw = cap[0];
            src = src.substring(raw.length);

            line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
            nextLine = src.split('\n', 1)[0];

            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/); // Find first non-space char
              indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }

            blankLine = false;

            if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
              raw += nextLine + '\n';
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }

            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);

              // Check if following lines should be included in List Item
              while (src) {
                rawLine = src.split('\n', 1)[0];
                nextLine = rawLine;

                // Re-align to follow commonmark nesting rules
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                }

                // End list item if found code fences
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }

                // End list item if found start of new heading
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }

                // End list item if found start of new bullet
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }

                // Horizontal rule found
                if (hrRegex.test(src)) {
                  break;
                }

                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible
                  itemContents += '\n' + nextLine.slice(indent);
                } else {
                  // not enough indentation
                  if (blankLine) {
                    break;
                  }

                  // paragraph continuation unless last line was a different block level element
                  if (line.search(/[^ ]/) >= 4) { // indented code block
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }

                  itemContents += '\n' + nextLine;
                }

                if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                  blankLine = true;
                }

                raw += rawLine + '\n';
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }

            if (!list.loose) {
              // If the previous item ended with a blank line, the list is loose
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }

            // Check for task list items
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== '[ ] ';
                itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
              }
            }

            list.items.push({
              type: 'list_item',
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });

            list.raw += raw;
          }

          // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
          list.items[list.items.length - 1].raw = raw.trimRight();
          list.items[list.items.length - 1].text = itemContents.trimRight();
          list.raw = list.raw.trimRight();

          const l = list.items.length;

          // Item child tokens handled here at end because we needed to have the final item to trim it first
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);

            if (!list.loose) {
              // Check if list should be loose
              const spacers = list.items[i].tokens.filter(t => t.type === 'space');
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));

              list.loose = hasMultipleLineBreaks;
            }
          }

          // Set all items to loose if list is loose
          if (list.loose) {
            for (i = 0; i < l; i++) {
              list.items[i].loose = true;
            }
          }

          return list;
        }
      }

      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: 'html',
            raw: cap[0],
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: cap[0]
          };
          if (this.options.sanitize) {
            const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0]);
            token.type = 'paragraph';
            token.text = text;
            token.tokens = this.lexer.inline(text);
          }
          return token;
        }
      }

      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
          return {
            type: 'def',
            tag,
            raw: cap[0],
            href,
            title
          };
        }
      }

      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: 'table',
            header: splitCells(cap[1]).map(c => { return { text: c }; }),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            item.raw = cap[0];

            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => { return { text: c }; });
            }

            // parse child tokens inside headers and cells

            // header child tokens
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }

            // cell child tokens
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }

            return item;
          }
        }
      }

      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }

      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === '\n'
            ? cap[1].slice(0, -1)
            : cap[1];
          return {
            type: 'paragraph',
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }

      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: 'text',
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }

      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: 'escape',
            raw: cap[0],
            text: escape$2(cap[1])
          };
        }
      }

      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }

          return {
            type: this.options.sanitize
              ? 'text'
              : 'html',
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize
              ? (this.options.sanitizer
                ? this.options.sanitizer(cap[0])
                : escape$2(cap[0]))
              : cap[0]
          };
        }
      }

      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            // commonmark requires matching angle brackets
            if (!(/>$/.test(trimmedUrl))) {
              return;
            }

            // ending angle bracket cannot be escaped
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            // find closing parenthesis
            const lastParenIndex = findClosingBracket(cap[2], '()');
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf('!') === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = '';
            }
          }
          let href = cap[2];
          let title = '';
          if (this.options.pedantic) {
            // split pedantic href and title
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : '';
          }

          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
              // pedantic allows starting angle bracket without ending angle bracket
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
            title: title ? title.replace(this.rules.inline._escapes, '$1') : title
          }, cap[0], this.lexer);
        }
      }

      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src))
            || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = links[link.toLowerCase()];
          if (!link) {
            const text = cap[0].charAt(0);
            return {
              type: 'text',
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }

      emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match) return;

        // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;

        const nextChar = match[1] || match[2] || '';

        if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;

          const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;

          // Clip maskedSrc to same section of string as src (move to lexer?)
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];

            if (!rDelim) continue; // skip single * in __abc*abc__

            rLength = rDelim.length;

            if (match[3] || match[4]) { // found another Left Delim
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) { // either Left or Right Delim
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue; // CommonMark Emphasis Rules 9-10
              }
            }

            delimTotal -= rLength;

            if (delimTotal > 0) continue; // Haven't found enough closing delimiters

            // Remove extra characters. *a*** -> *a*
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);

            const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

            // Create `em` if smallest delimiter has odd char count. *a***
            if (Math.min(lLength, rLength) % 2) {
              const text = raw.slice(1, -1);
              return {
                type: 'em',
                raw,
                text,
                tokens: this.lexer.inlineTokens(text)
              };
            }

            // Create 'strong' if smallest delimiter has even char count. **a***
            const text = raw.slice(2, -2);
            return {
              type: 'strong',
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      }

      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, ' ');
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape$2(text, true);
          return {
            type: 'codespan',
            raw: cap[0],
            text
          };
        }
      }

      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: 'br',
            raw: cap[0]
          };
        }
      }

      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: 'del',
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }

      autolink(src, mangle) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === '@') {
            text = escape$2(this.options.mangle ? mangle(cap[1]) : cap[1]);
            href = 'mailto:' + text;
          } else {
            text = escape$2(cap[1]);
            href = text;
          }

          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: 'text',
                raw: text,
                text
              }
            ]
          };
        }
      }

      url(src, mangle) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === '@') {
            text = escape$2(this.options.mangle ? mangle(cap[0]) : cap[0]);
            href = 'mailto:' + text;
          } else {
            // do extended autolink path validation
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape$2(cap[0]);
            if (cap[1] === 'www.') {
              href = 'http://' + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: 'text',
                raw: text,
                text
              }
            ]
          };
        }
      }

      inlineText(src, smartypants) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0])) : cap[0];
          } else {
            text = escape$2(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
          }
          return {
            type: 'text',
            raw: cap[0],
            text
          };
        }
      }
    }

    /**
     * Block-Level Grammar
     */
    const block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
        + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
        + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
        + ')',
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };

    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def)
      .replace('label', block._label)
      .replace('title', block._title)
      .getRegex();

    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */)
      .replace('bull', block.bullet)
      .getRegex();

    block.list = edit(block.list)
      .replace(/bull/g, block.bullet)
      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
      .replace('def', '\\n+(?=' + block.def.source + ')')
      .getRegex();

    block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
      + '|track|ul';
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, 'i')
      .replace('comment', block._comment)
      .replace('tag', block._tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();

    block.paragraph = edit(block._paragraph)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('|table', '')
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();

    block.blockquote = edit(block.blockquote)
      .replace('paragraph', block.paragraph)
      .getRegex();

    /**
     * Normal Block Grammar
     */

    block.normal = merge({}, block);

    /**
     * GFM Block Grammar
     */

    block.gfm = merge({}, block.normal, {
      table: '^ *([^\\n ].*\\|.*)\\n' // Header
        + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
        + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
    });

    block.gfm.table = edit(block.gfm.table)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('blockquote', ' {0,3}>')
      .replace('code', ' {4}[^\\n]')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();

    block.gfm.paragraph = edit(block._paragraph)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('table', block.gfm.table) // interrupt paragraphs with table
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();
    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */

    block.pedantic = merge({}, block.normal, {
      html: edit(
        '^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', block._comment)
        .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest, // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph)
        .replace('hr', block.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block.lheading)
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .getRegex()
    });

    /**
     * Inline-Level Grammar
     */
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: '^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: 'reflink|nolink(?!\\()',
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };

    // list of punctuation marks from CommonMark spec
    // without * and _ to handle the different emphasis markers * and _
    inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

    // sequences em should skip over [title](link), `code`, <html>
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    // lookbehind is not available on Safari as of version 16
    // inline.escapedEmSt = /(?<=(?:^|[^\\)(?:\\[^])*)\\[*_]/g;
    inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;

    inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();

    inline.emStrong.lDelim = edit(inline.emStrong.lDelim)
      .replace(/punct/g, inline._punctuation)
      .getRegex();

    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g')
      .replace(/punct/g, inline._punctuation)
      .getRegex();

    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g')
      .replace(/punct/g, inline._punctuation)
      .getRegex();

    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink)
      .replace('scheme', inline._scheme)
      .replace('email', inline._email)
      .getRegex();

    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

    inline.tag = edit(inline.tag)
      .replace('comment', inline._comment)
      .replace('attribute', inline._attribute)
      .getRegex();

    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

    inline.link = edit(inline.link)
      .replace('label', inline._label)
      .replace('href', inline._href)
      .replace('title', inline._title)
      .getRegex();

    inline.reflink = edit(inline.reflink)
      .replace('label', inline._label)
      .replace('ref', block._label)
      .getRegex();

    inline.nolink = edit(inline.nolink)
      .replace('ref', block._label)
      .getRegex();

    inline.reflinkSearch = edit(inline.reflinkSearch, 'g')
      .replace('reflink', inline.reflink)
      .replace('nolink', inline.nolink)
      .getRegex();

    /**
     * Normal Inline Grammar
     */

    inline.normal = merge({}, inline);

    /**
     * Pedantic Inline Grammar
     */

    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', inline._label)
        .getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', inline._label)
        .getRegex()
    });

    /**
     * GFM Inline Grammar
     */

    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace('])', '~|])').getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });

    inline.gfm.url = edit(inline.gfm.url, 'i')
      .replace('email', inline.gfm._extended_email)
      .getRegex();
    /**
     * GFM + Line Breaks Inline Grammar
     */

    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace('{2,}', '*').getRegex(),
      text: edit(inline.gfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex()
    });

    /**
     * smartypants text replacement
     * @param {string} text
     */
    function smartypants(text) {
      return text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
    }

    /**
     * mangle email addresses
     * @param {string} text
     */
    function mangle(text) {
      let out = '',
        i,
        ch;

      const l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }

      return out;
    }

    /**
     * Block Lexer
     */
    class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };

        const rules = {
          block: block.normal,
          inline: inline.normal
        };

        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }

      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }

      /**
       * Static Lex Method
       */
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }

      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
        const lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }

      /**
       * Preprocessing
       */
      lex(src) {
        src = src
          .replace(/\r\n|\r/g, '\n');

        this.blockTokens(src, this.tokens);

        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }

        return this.tokens;
      }

      /**
       * Lexing
       */
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
            return leading + '    '.repeat(tabs.length);
          });
        }

        let token, lastToken, cutSrc, lastParagraphClipped;

        while (src) {
          if (this.options.extensions
            && this.options.extensions.block
            && this.options.extensions.block.some((extTokenizer) => {
              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
            continue;
          }

          // newline
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              // if there's a single \n as a spacer, it's terminating the last line,
              // so move it there so that we don't get unecessary paragraph tags
              tokens[tokens.length - 1].raw += '\n';
            } else {
              tokens.push(token);
            }
            continue;
          }

          // code
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            // An indented code block cannot interrupt a paragraph.
            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          // fences
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // heading
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // hr
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // blockquote
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // list
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // html
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // def
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }

          // table (gfm)
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // lheading
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // top-level paragraph
          // prevent paragraph consuming extensions by clipping 'src' to extension start
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === 'paragraph') {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = (cutSrc.length !== src.length);
            src = src.substring(token.raw.length);
            continue;
          }

          // text
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }

        this.state.top = true;
        return tokens;
      }

      inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
      }

      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;

        // String with links masked to avoid interference with em and strong
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;

        // Mask out reflinks
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        // Mask out other blocks
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }

        // Mask out escaped em & strong delimiters
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
        }

        while (src) {
          if (!keepPrevChar) {
            prevChar = '';
          }
          keepPrevChar = false;

          // extensions
          if (this.options.extensions
            && this.options.extensions.inline
            && this.options.extensions.inline.some((extTokenizer) => {
              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
            continue;
          }

          // escape
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // tag
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === 'text' && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          // link
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // reflink, nolink
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === 'text' && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          // em & strong
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // code
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // br
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // del (gfm)
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // autolink
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // url (gfm)
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // text
          // prevent inlineText consuming extensions by clipping 'src' to extension start
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }

        return tokens;
      }
    }

    /**
     * Renderer
     */
    class Renderer {
      constructor(options) {
        this.options = options || defaults;
      }

      code(code, infostring, escaped) {
        const lang = (infostring || '').match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }

        code = code.replace(/\n$/, '') + '\n';

        if (!lang) {
          return '<pre><code>'
            + (escaped ? code : escape$2(code, true))
            + '</code></pre>\n';
        }

        return '<pre><code class="'
          + this.options.langPrefix
          + escape$2(lang)
          + '">'
          + (escaped ? code : escape$2(code, true))
          + '</code></pre>\n';
      }

      /**
       * @param {string} quote
       */
      blockquote(quote) {
        return `<blockquote>\n${quote}</blockquote>\n`;
      }

      html(html) {
        return html;
      }

      /**
       * @param {string} text
       * @param {string} level
       * @param {string} raw
       * @param {any} slugger
       */
      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          const id = this.options.headerPrefix + slugger.slug(raw);
          return `<h${level} id="${id}">${text}</h${level}>\n`;
        }

        // ignore IDs
        return `<h${level}>${text}</h${level}>\n`;
      }

      hr() {
        return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
      }

      list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul',
          startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
      }

      /**
       * @param {string} text
       */
      listitem(text) {
        return `<li>${text}</li>\n`;
      }

      checkbox(checked) {
        return '<input '
          + (checked ? 'checked="" ' : '')
          + 'disabled="" type="checkbox"'
          + (this.options.xhtml ? ' /' : '')
          + '> ';
      }

      /**
       * @param {string} text
       */
      paragraph(text) {
        return `<p>${text}</p>\n`;
      }

      /**
       * @param {string} header
       * @param {string} body
       */
      table(header, body) {
        if (body) body = `<tbody>${body}</tbody>`;

        return '<table>\n'
          + '<thead>\n'
          + header
          + '</thead>\n'
          + body
          + '</table>\n';
      }

      /**
       * @param {string} content
       */
      tablerow(content) {
        return `<tr>\n${content}</tr>\n`;
      }

      tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const tag = flags.align
          ? `<${type} align="${flags.align}">`
          : `<${type}>`;
        return tag + content + `</${type}>\n`;
      }

      /**
       * span level renderer
       * @param {string} text
       */
      strong(text) {
        return `<strong>${text}</strong>`;
      }

      /**
       * @param {string} text
       */
      em(text) {
        return `<em>${text}</em>`;
      }

      /**
       * @param {string} text
       */
      codespan(text) {
        return `<code>${text}</code>`;
      }

      br() {
        return this.options.xhtml ? '<br/>' : '<br>';
      }

      /**
       * @param {string} text
       */
      del(text) {
        return `<del>${text}</del>`;
      }

      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
      }

      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }

        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += this.options.xhtml ? '/>' : '>';
        return out;
      }

      text(text) {
        return text;
      }
    }

    /**
     * TextRenderer
     * returns only the textual part of the token
     */
    class TextRenderer {
      // no need for block level renderers
      strong(text) {
        return text;
      }

      em(text) {
        return text;
      }

      codespan(text) {
        return text;
      }

      del(text) {
        return text;
      }

      html(text) {
        return text;
      }

      text(text) {
        return text;
      }

      link(href, title, text) {
        return '' + text;
      }

      image(href, title, text) {
        return '' + text;
      }

      br() {
        return '';
      }
    }

    /**
     * Slugger generates header id
     */
    class Slugger {
      constructor() {
        this.seen = {};
      }

      /**
       * @param {string} value
       */
      serialize(value) {
        return value
          .toLowerCase()
          .trim()
          // remove html tags
          .replace(/<[!\/a-z].*?>/ig, '')
          // remove unwanted chars
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
          .replace(/\s/g, '-');
      }

      /**
       * Finds the next safe (unique) slug to use
       * @param {string} originalSlug
       * @param {boolean} isDryRun
       */
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + '-' + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }

      /**
       * Convert string to unique id
       * @param {object} [options]
       * @param {boolean} [options.dryrun] Generates the next unique slug without
       * updating the internal accumulator.
       */
      slug(value, options = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options.dryrun);
      }
    }

    /**
     * Parsing & Compiling
     */
    class Parser {
      constructor(options) {
        this.options = options || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }

      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
        const parser = new Parser(options);
        return parser.parse(tokens);
      }

      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
        const parser = new Parser(options);
        return parser.parseInline(tokens);
      }

      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox,
          ret;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];

          // Run any renderer extensions
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
              out += ret || '';
              continue;
            }
          }

          switch (token.type) {
            case 'space': {
              continue;
            }
            case 'hr': {
              out += this.renderer.hr();
              continue;
            }
            case 'heading': {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape$2(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger);
              continue;
            }
            case 'code': {
              out += this.renderer.code(token.text,
                token.lang,
                token.escaped);
              continue;
            }
            case 'table': {
              header = '';

              // header
              cell = '';
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[j].tokens),
                  { header: true, align: token.align[j] }
                );
              }
              header += this.renderer.tablerow(cell);

              body = '';
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];

                cell = '';
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k].tokens),
                    { header: false, align: token.align[k] }
                  );
                }

                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case 'blockquote': {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case 'list': {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;

              body = '';
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;

                itemBody = '';
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case 'html': {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }
            case 'paragraph': {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case 'text': {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }

        return out;
      }

      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '',
          i,
          token,
          ret;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];

          // Run any renderer extensions
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
              out += ret || '';
              continue;
            }
          }

          switch (token.type) {
            case 'escape': {
              out += renderer.text(token.text);
              break;
            }
            case 'html': {
              out += renderer.html(token.text);
              break;
            }
            case 'link': {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case 'image': {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case 'strong': {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'em': {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'codespan': {
              out += renderer.codespan(token.text);
              break;
            }
            case 'br': {
              out += renderer.br();
              break;
            }
            case 'del': {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'text': {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    }

    /**
     * Marked
     */
    function marked(src, opt, callback) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      if (typeof opt === 'function') {
        callback = opt;
        opt = null;
      }

      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);

      if (callback) {
        const highlight = opt.highlight;
        let tokens;

        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }

        const done = function(err) {
          let out;

          if (!err) {
            try {
              if (opt.walkTokens) {
                marked.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }

          opt.highlight = highlight;

          return err
            ? callback(err)
            : callback(null, out);
        };

        if (!highlight || highlight.length < 3) {
          return done();
        }

        delete opt.highlight;

        if (!tokens.length) return done();

        let pending = 0;
        marked.walkTokens(tokens, function(token) {
          if (token.type === 'code') {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }

                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });

        if (pending === 0) {
          done();
        }

        return;
      }

      function onError(e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if (opt.silent) {
          return '<p>An error occurred:</p><pre>'
            + escape$2(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }

      try {
        const tokens = Lexer.lex(src, opt);
        if (opt.walkTokens) {
          if (opt.async) {
            return Promise.all(marked.walkTokens(tokens, opt.walkTokens))
              .then(() => {
                return Parser.parse(tokens, opt);
              })
              .catch(onError);
          }
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parse(tokens, opt);
      } catch (e) {
        onError(e);
      }
    }

    /**
     * Options
     */

    marked.options =
    marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };

    marked.getDefaults = getDefaults$1;

    marked.defaults = defaults;

    /**
     * Use Extension
     */

    marked.use = function(...args) {
      const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };

      args.forEach((pack) => {
        // copy options to new object
        const opts = merge({}, pack);

        // set async to true if it was set to true before
        opts.async = marked.defaults.async || opts.async;

        // ==-- Parse "addon" extensions --== //
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error('extension name required');
            }
            if (ext.renderer) { // Renderer extensions
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                // Replace extension with func to run new extension but fall back if false
                extensions.renderers[ext.name] = function(...args) {
                  let ret = ext.renderer.apply(this, args);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) { // Tokenizer Extensions
              if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) { // Function to check for start of token
                if (ext.level === 'block') {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === 'inline') {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) { // Child tokens to be visited by walkTokens
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }

        // ==-- Parse "overwrite" extensions --== //
        if (pack.renderer) {
          const renderer = marked.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            // Replace renderer with func to run extension, but fall back if false
            renderer[prop] = (...args) => {
              let ret = pack.renderer[prop].apply(renderer, args);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            // Replace tokenizer with func to run extension, but fall back if false
            tokenizer[prop] = (...args) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }

        // ==-- Parse WalkTokens extensions --== //
        if (pack.walkTokens) {
          const walkTokens = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(pack.walkTokens.call(this, token));
            if (walkTokens) {
              values = values.concat(walkTokens.call(this, token));
            }
            return values;
          };
        }

        marked.setOptions(opts);
      });
    };

    /**
     * Run callback for every token
     */

    marked.walkTokens = function(tokens, callback) {
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(marked, token));
        switch (token.type) {
          case 'table': {
            for (const cell of token.header) {
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }
            for (const row of token.rows) {
              for (const cell of row) {
                values = values.concat(marked.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case 'list': {
            values = values.concat(marked.walkTokens(token.items, callback));
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) { // Walk any extensions
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked.walkTokens(token.tokens, callback));
            }
          }
        }
      }
      return values;
    };

    /**
     * Parse Inline
     * @param {string} src
     */
    marked.parseInline = function(src, opt) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked.parseInline(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked.parseInline(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);

      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if (opt.silent) {
          return '<p>An error occurred:</p><pre>'
            + escape$2(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    };

    /**
     * Expose
     */
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.parse = marked;

    marked.options;
    marked.setOptions;
    marked.use;
    marked.walkTokens;
    marked.parseInline;
    Parser.parse;
    Lexer.lex;

    var purify = {exports: {}};

    /*! @license DOMPurify 2.4.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.3/LICENSE */

    (function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    })(commonjsGlobal, (function () {
      function _typeof(obj) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _typeof(obj);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }

        return _construct.apply(null, arguments);
      }

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var hasOwnProperty = Object.hasOwnProperty,
          setPrototypeOf = Object.setPrototypeOf,
          isFrozen = Object.isFrozen,
          getPrototypeOf = Object.getPrototypeOf,
          getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze,
          seal = Object.seal,
          create = Object.create; // eslint-disable-line import/no-mutable-exports

      var _ref = typeof Reflect !== 'undefined' && Reflect,
          apply = _ref.apply,
          construct = _ref.construct;

      if (!apply) {
        apply = function apply(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }

      if (!freeze) {
        freeze = function freeze(x) {
          return x;
        };
      }

      if (!seal) {
        seal = function seal(x) {
          return x;
        };
      }

      if (!construct) {
        construct = function construct(Func, args) {
          return _construct(Func, _toConsumableArray(args));
        };
      }

      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function (thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return construct(func, args);
        };
      }
      /* Add properties to a lookup table */

      function addToSet(set, array, transformCaseFunc) {
        transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

        if (setPrototypeOf) {
          // Make 'in' and truthy checks like Boolean(set.constructor)
          // independent of any properties defined on Object.prototype.
          // Prevent prototype setters from intercepting set as a this value.
          setPrototypeOf(set, null);
        }

        var l = array.length;

        while (l--) {
          var element = array[l];

          if (typeof element === 'string') {
            var lcElement = transformCaseFunc(element);

            if (lcElement !== element) {
              // Config presets (e.g. tags.js, attrs.js) are immutable.
              if (!isFrozen(array)) {
                array[l] = lcElement;
              }

              element = lcElement;
            }
          }

          set[element] = true;
        }

        return set;
      }
      /* Shallow clone an object */

      function clone(object) {
        var newObject = create(null);
        var property;

        for (property in object) {
          if (apply(hasOwnProperty, object, [property]) === true) {
            newObject[property] = object[property];
          }
        }

        return newObject;
      }
      /* IE10 doesn't support __lookupGetter__ so lets'
       * simulate it. It also automatically checks
       * if the prop is function or getter and behaves
       * accordingly. */

      function lookupGetter(object, prop) {
        while (object !== null) {
          var desc = getOwnPropertyDescriptor(object, prop);

          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }

            if (typeof desc.value === 'function') {
              return unapply(desc.value);
            }
          }

          object = getPrototypeOf(object);
        }

        function fallbackValue(element) {
          console.warn('fallback value for', element);
          return null;
        }

        return fallbackValue;
      }

      var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

      var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
      var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
      // We still need to know them so that we can do namespace
      // checks properly in case one wants to add them to
      // allow-list.

      var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
      var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
      // even those that we disallow by default.

      var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
      var text = freeze(['#text']);

      var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
      var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
      var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
      var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

      var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

      var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);

      var getGlobal = function getGlobal() {
        return typeof window === 'undefined' ? null : window;
      };
      /**
       * Creates a no-op policy for internal use only.
       * Don't export this function outside this module!
       * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
       * @param {Document} document The document object (to determine policy name suffix)
       * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
       * are not supported).
       */


      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
        if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
          return null;
        } // Allow the callers to control the unique policy name
        // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
        // Policy creation with duplicate names throws in Trusted Types.


        var suffix = null;
        var ATTR_NAME = 'data-tt-policy-suffix';

        if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document.currentScript.getAttribute(ATTR_NAME);
        }

        var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html) {
              return html;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_) {
          // Policy creation failed (most likely another DOMPurify script has
          // already run). Skip creating the policy, as this will only cause errors
          // if TT are enforced.
          console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
          return null;
        }
      };

      function createDOMPurify() {
        var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

        var DOMPurify = function DOMPurify(root) {
          return createDOMPurify(root);
        };
        /**
         * Version label, exposed for easier checks
         * if DOMPurify is up to date or not
         */


        DOMPurify.version = '2.4.3';
        /**
         * Array of elements that DOMPurify removed during sanitation.
         * Empty if nothing was removed.
         */

        DOMPurify.removed = [];

        if (!window || !window.document || window.document.nodeType !== 9) {
          // Not running in a browser, provide a factory function
          // so that you can pass your own Window
          DOMPurify.isSupported = false;
          return DOMPurify;
        }

        var originalDocument = window.document;
        var document = window.document;
        var DocumentFragment = window.DocumentFragment,
            HTMLTemplateElement = window.HTMLTemplateElement,
            Node = window.Node,
            Element = window.Element,
            NodeFilter = window.NodeFilter,
            _window$NamedNodeMap = window.NamedNodeMap,
            NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
            HTMLFormElement = window.HTMLFormElement,
            DOMParser = window.DOMParser,
            trustedTypes = window.trustedTypes;
        var ElementPrototype = Element.prototype;
        var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
        var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
        var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
        var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
        // new document created via createHTMLDocument. As per the spec
        // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
        // a new empty registry is used when creating a template contents owner
        // document, so we use that as our parent document to ensure nothing
        // is inherited.

        if (typeof HTMLTemplateElement === 'function') {
          var template = document.createElement('template');

          if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
          }
        }

        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
        var _document = document,
            implementation = _document.implementation,
            createNodeIterator = _document.createNodeIterator,
            createDocumentFragment = _document.createDocumentFragment,
            getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};

        try {
          documentMode = clone(document).documentMode ? document.documentMode : {};
        } catch (_) {}

        var hooks = {};
        /**
         * Expose whether this browser supports running the full DOMPurify.
         */

        DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
            ERB_EXPR$1 = ERB_EXPR,
            TMPLIT_EXPR$1 = TMPLIT_EXPR,
            DATA_ATTR$1 = DATA_ATTR,
            ARIA_ATTR$1 = ARIA_ATTR,
            IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
            ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        /**
         * We consider the elements and attributes below to be safe. Ideally
         * don't add any new ones but feel free to remove unwanted ones.
         */

        /* allowed element names */

        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
        /* Allowed attribute names */

        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
        /*
         * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
         * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
         * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
         * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
         */

        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

        var FORBID_TAGS = null;
        /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

        var FORBID_ATTR = null;
        /* Decide if ARIA attributes are okay */

        var ALLOW_ARIA_ATTR = true;
        /* Decide if custom data attributes are okay */

        var ALLOW_DATA_ATTR = true;
        /* Decide if unknown protocols are okay */

        var ALLOW_UNKNOWN_PROTOCOLS = false;
        /* Output should be safe for common template engines.
         * This means, DOMPurify removes data attributes, mustaches and ERB
         */

        var SAFE_FOR_TEMPLATES = false;
        /* Decide if document with <html>... should be returned */

        var WHOLE_DOCUMENT = false;
        /* Track whether config is already set on this instance of DOMPurify. */

        var SET_CONFIG = false;
        /* Decide if all elements (e.g. style, script) must be children of
         * document.body. By default, browsers might move them to document.head */

        var FORCE_BODY = false;
        /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
         * string (or a TrustedHTML object if Trusted Types are supported).
         * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
         */

        var RETURN_DOM = false;
        /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
         * string  (or a TrustedHTML object if Trusted Types are supported) */

        var RETURN_DOM_FRAGMENT = false;
        /* Try to return a Trusted Type object instead of a string, return a string in
         * case Trusted Types are not supported  */

        var RETURN_TRUSTED_TYPE = false;
        /* Output should be free from DOM clobbering attacks?
         * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
         */

        var SANITIZE_DOM = true;
        /* Achieve full DOM Clobbering protection by isolating the namespace of named
         * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
         *
         * HTML/DOM spec rules that enable DOM Clobbering:
         *   - Named Access on Window (§7.3.3)
         *   - DOM Tree Accessors (§3.1.5)
         *   - Form Element Parent-Child Relations (§4.10.3)
         *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
         *   - HTMLCollection (§4.2.10.2)
         *
         * Namespace isolation is implemented by prefixing `id` and `name` attributes
         * with a constant string, i.e., `user-content-`
         */

        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
        /* Keep element content when removing element? */

        var KEEP_CONTENT = true;
        /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
         * of importing it into a new Document and returning a sanitized copy */

        var IN_PLACE = false;
        /* Allow usage of profiles like html, svg and mathMl */

        var USE_PROFILES = {};
        /* Tags to ignore content of when KEEP_CONTENT is true */

        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
        /* Tags that are safe for data: URIs */

        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
        /* Attributes safe for values like "javascript:" */

        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
        var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
        var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
        var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
        /* Document namespace */

        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        /* Allowed XHTML+XML namespaces */

        var ALLOWED_NAMESPACES = null;
        var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        /* Parsing of strict XHTML documents */

        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
        var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
        var transformCaseFunc;
        /* Keep a reference to config to pass to hooks */

        var CONFIG = null;
        /* Ideally, do not touch anything below this line */

        /* ______________________________________________ */

        var formElement = document.createElement('form');

        var isRegexOrFunction = function isRegexOrFunction(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        /**
         * _parseConfig
         *
         * @param  {Object} cfg optional config literal
         */
        // eslint-disable-next-line complexity


        var _parseConfig = function _parseConfig(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          /* Shield configuration object from tampering */


          if (!cfg || _typeof(cfg) !== 'object') {
            cfg = {};
          }
          /* Shield configuration object from prototype pollution */


          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

          transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
          /* Set configuration parameters */

          ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
          cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
          transformCaseFunc // eslint-disable-line indent
          ) // eslint-disable-line indent
          : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
          cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
          transformCaseFunc // eslint-disable-line indent
          ) // eslint-disable-line indent
          : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

          RETURN_DOM = cfg.RETURN_DOM || false; // Default false

          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

          FORCE_BODY = cfg.FORCE_BODY || false; // Default false

          SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

          KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

          IN_PLACE = cfg.IN_PLACE || false; // Default false

          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }

          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }

          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }

          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }

          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          /* Parse profile info */


          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
            ALLOWED_ATTR = [];

            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html);
            }

            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }

            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }

            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          /* Merge configuration parameters */


          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }

            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }

          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }

            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }

          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }

          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }

            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          /* Add #text in case KEEP_CONTENT is set to true */


          if (KEEP_CONTENT) {
            ALLOWED_TAGS['#text'] = true;
          }
          /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
          }
          /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ['tbody']);
            delete FORBID_TAGS.tbody;
          } // Prevent further manipulation of configuration.
          // Not available in IE8, Safari 5, etc.


          if (freeze) {
            freeze(cfg);
          }

          CONFIG = cfg;
        };

        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
        var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erroneously deleted from
        // HTML namespace.

        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
        /* Keep track of all possible SVG and MathML tags
         * so that we can perform the namespace checks
         * correctly. */

        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        /**
         *
         *
         * @param  {Element} element a DOM element whose namespace is being checked
         * @returns {boolean} Return false if the element has a
         *  namespace that a spec-compliant parser would never
         *  return. Return true otherwise.
         */

        var _checkValidNamespace = function _checkValidNamespace(element) {
          var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
          // can be null. We just simulate parent in this case.

          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: 'template'
            };
          }

          var tagName = stringToLowerCase(element.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);

          if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
          }

          if (element.namespaceURI === SVG_NAMESPACE) {
            // The only way to switch from HTML namespace to SVG
            // is via <svg>. If it happens via any other tag, then
            // it should be killed.
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === 'svg';
            } // The only way to switch from MathML to SVG is via`
            // svg if parent is either <annotation-xml> or MathML
            // text integration points.


            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            } // We only allow elements that are defined in SVG
            // spec. All others are disallowed in SVG namespace.


            return Boolean(ALL_SVG_TAGS[tagName]);
          }

          if (element.namespaceURI === MATHML_NAMESPACE) {
            // The only way to switch from HTML namespace to MathML
            // is via <math>. If it happens via any other tag, then
            // it should be killed.
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === 'math';
            } // The only way to switch from SVG to MathML is via
            // <math> and HTML integration points


            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
            } // We only allow elements that are defined in MathML
            // spec. All others are disallowed in MathML namespace.


            return Boolean(ALL_MATHML_TAGS[tagName]);
          }

          if (element.namespaceURI === HTML_NAMESPACE) {
            // The only way to switch from SVG to HTML is via
            // HTML integration points, and from MathML to HTML
            // is via MathML text integration points
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }

            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            } // We disallow tags that are specific for MathML
            // or SVG and should never appear in HTML namespace


            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          } // For XHTML and XML documents that support custom namespaces


          if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
          } // The code should never reach this place (this means
          // that the element somehow got namespace that is not
          // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
          // Return false just in case.


          return false;
        };
        /**
         * _forceRemove
         *
         * @param  {Node} node a DOM node
         */


        var _forceRemove = function _forceRemove(node) {
          arrayPush(DOMPurify.removed, {
            element: node
          });

          try {
            // eslint-disable-next-line unicorn/prefer-dom-node-remove
            node.parentNode.removeChild(node);
          } catch (_) {
            try {
              node.outerHTML = emptyHTML;
            } catch (_) {
              node.remove();
            }
          }
        };
        /**
         * _removeAttribute
         *
         * @param  {String} name an Attribute name
         * @param  {Node} node a DOM node
         */


        var _removeAttribute = function _removeAttribute(name, node) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node.getAttributeNode(name),
              from: node
            });
          } catch (_) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node
            });
          }

          node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

          if (name === 'is' && !ALLOWED_ATTR[name]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node);
              } catch (_) {}
            } else {
              try {
                node.setAttribute(name, '');
              } catch (_) {}
            }
          }
        };
        /**
         * _initDocument
         *
         * @param  {String} dirty a string of dirty markup
         * @return {Document} a DOM, filled with the dirty markup
         */


        var _initDocument = function _initDocument(dirty) {
          /* Create a HTML document */
          var doc;
          var leadingWhitespace;

          if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty;
          } else {
            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
            var matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
          }

          if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
          }

          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          /*
           * Use the DOMParser API by default, fallback later if needs be
           * DOMParser not work for svg when has multiple root element.
           */

          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_) {}
          }
          /* Use createHTMLDocument in case DOMParser is not available */


          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, 'template', null);

            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_) {// Syntax error if dirtyPayload is invalid xml
            }
          }

          var body = doc.body || doc.documentElement;

          if (dirty && leadingWhitespace) {
            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          /* Work on whole document or just its body */


          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
          }

          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        /**
         * _createIterator
         *
         * @param  {Document} root document/fragment to create iterator for
         * @return {Iterator} iterator instance
         */


        var _createIterator = function _createIterator(root) {
          return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
        };
        /**
         * _isClobbered
         *
         * @param  {Node} elm element to check for clobbering attacks
         * @return {Boolean} true if clobbered, false if safe
         */


        var _isClobbered = function _isClobbered(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
        };
        /**
         * _isNode
         *
         * @param  {Node} obj object to check whether it's a DOM node
         * @return {Boolean} true is object is a DOM node
         */


        var _isNode = function _isNode(object) {
          return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
        };
        /**
         * _executeHook
         * Execute user configurable hooks
         *
         * @param  {String} entryPoint  Name of the hook's entry point
         * @param  {Node} currentNode node to work on with the hook
         * @param  {Object} data additional hook parameters
         */


        var _executeHook = function _executeHook(entryPoint, currentNode, data) {
          if (!hooks[entryPoint]) {
            return;
          }

          arrayForEach(hooks[entryPoint], function (hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };
        /**
         * _sanitizeElements
         *
         * @protect nodeName
         * @protect textContent
         * @protect removeChild
         *
         * @param   {Node} currentNode to check for permission to exist
         * @return  {Boolean} true if node was killed, false if left alive
         */


        var _sanitizeElements = function _sanitizeElements(currentNode) {
          var content;
          /* Execute a hook if present */

          _executeHook('beforeSanitizeElements', currentNode, null);
          /* Check if element is clobbered or can clobber */


          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Check if tagname contains Unicode */


          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Now let's check the element's type and name */


          var tagName = transformCaseFunc(currentNode.nodeName);
          /* Execute a hook if present */

          _executeHook('uponSanitizeElement', currentNode, {
            tagName: tagName,
            allowedTags: ALLOWED_TAGS
          });
          /* Detect mXSS attempts abusing namespace confusion */


          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Mitigate a problem with templates inside select */


          if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Remove element if anything forbids its presence */


          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Check if we have a custom element to handle */
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
            }
            /* Keep content except for bad-listed elements */


            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

              if (childNodes && parentNode) {
                var childCount = childNodes.length;

                for (var i = childCount - 1; i >= 0; --i) {
                  parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                }
              }
            }

            _forceRemove(currentNode);

            return true;
          }
          /* Check whether element has a valid namespace */


          if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);

            return true;
          }

          if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Sanitize element content to be template-safe */


          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            /* Get the element's text content */
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
            content = stringReplace(content, ERB_EXPR$1, ' ');
            content = stringReplace(content, TMPLIT_EXPR$1, ' ');

            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          /* Execute a hook if present */


          _executeHook('afterSanitizeElements', currentNode, null);

          return false;
        };
        /**
         * _isValidAttribute
         *
         * @param  {string} lcTag Lowercase tag name of containing element.
         * @param  {string} lcName Lowercase attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid, otherwise false.
         */
        // eslint-disable-next-line complexity


        var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
          /* Make sure attribute cannot clobber */
          if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
            return false;
          }
          /* Allow valid data-* attributes: At least one character after "-"
              (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
              XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
              We don't need to check the value; it's always URI safe. */


          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
              return false;
            }
            /* Check value is safe. First, is attr inert? If so, is safe */

          } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
            return false;
          }

          return true;
        };
        /**
         * _basicCustomElementCheck
         * checks if at least one dash is included in tagName, and it's not the first char
         * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
         * @param {string} tagName name of the tag of the node to sanitize
         */


        var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
          return tagName.indexOf('-') > 0;
        };
        /**
         * _sanitizeAttributes
         *
         * @protect attributes
         * @protect nodeName
         * @protect removeAttribute
         * @protect setAttribute
         *
         * @param  {Node} currentNode to sanitize
         */


        var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
          var attr;
          var value;
          var lcName;
          var l;
          /* Execute a hook if present */

          _executeHook('beforeSanitizeAttributes', currentNode, null);

          var attributes = currentNode.attributes;
          /* Check if we have attributes; if not we might have a text node */

          if (!attributes) {
            return;
          }

          var hookEvent = {
            attrName: '',
            attrValue: '',
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l = attributes.length;
          /* Go backwards over all attributes; safely remove bad ones */

          while (l--) {
            attr = attributes[l];
            var _attr = attr,
                name = _attr.name,
                namespaceURI = _attr.namespaceURI;
            value = name === 'value' ? attr.value : stringTrim(attr.value);
            lcName = transformCaseFunc(name);
            /* Execute a hook if present */

            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

            _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

            value = hookEvent.attrValue;
            /* Did the hooks approve of the attribute? */

            if (hookEvent.forceKeepAttr) {
              continue;
            }
            /* Remove attribute */


            _removeAttribute(name, currentNode);
            /* Did the hooks approve of the attribute? */


            if (!hookEvent.keepAttr) {
              continue;
            }
            /* Work around a security issue in jQuery 3.0 */


            if (regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);

              continue;
            }
            /* Sanitize attribute content to be template-safe */


            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
              value = stringReplace(value, ERB_EXPR$1, ' ');
              value = stringReplace(value, TMPLIT_EXPR$1, ' ');
            }
            /* Is `value` valid for this attribute? */


            var lcTag = transformCaseFunc(currentNode.nodeName);

            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            /* Full DOM Clobbering protection via namespace isolation,
             * Prefix id and name attributes with `user-content-`
             */


            if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
              // Remove the attribute with this value
              _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            /* Handle attributes that require Trusted Types */


            if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
              if (namespaceURI) ; else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case 'TrustedHTML':
                    value = trustedTypesPolicy.createHTML(value);
                    break;

                  case 'TrustedScriptURL':
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                }
              }
            }
            /* Handle invalid data-* attribute set by try-catching it */


            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                currentNode.setAttribute(name, value);
              }

              arrayPop(DOMPurify.removed);
            } catch (_) {}
          }
          /* Execute a hook if present */


          _executeHook('afterSanitizeAttributes', currentNode, null);
        };
        /**
         * _sanitizeShadowDOM
         *
         * @param  {DocumentFragment} fragment to iterate over recursively
         */


        var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
          var shadowNode;

          var shadowIterator = _createIterator(fragment);
          /* Execute a hook if present */


          _executeHook('beforeSanitizeShadowDOM', fragment, null);

          while (shadowNode = shadowIterator.nextNode()) {
            /* Execute a hook if present */
            _executeHook('uponSanitizeShadowNode', shadowNode, null);
            /* Sanitize tags and elements */


            if (_sanitizeElements(shadowNode)) {
              continue;
            }
            /* Deep shadow DOM detected */


            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(shadowNode.content);
            }
            /* Check attributes, sanitize if necessary */


            _sanitizeAttributes(shadowNode);
          }
          /* Execute a hook if present */


          _executeHook('afterSanitizeShadowDOM', fragment, null);
        };
        /**
         * Sanitize
         * Public method providing core sanitation functionality
         *
         * @param {String|Node} dirty string or DOM node
         * @param {Object} configuration object
         */
        // eslint-disable-next-line complexity


        DOMPurify.sanitize = function (dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          /* Make sure we have a string to sanitize.
            DO NOT return early, as this will return the wrong type if
            the user has requested a DOM object rather than a string */

          IS_EMPTY_INPUT = !dirty;

          if (IS_EMPTY_INPUT) {
            dirty = '<!-->';
          }
          /* Stringify, in case dirty is an object */


          if (typeof dirty !== 'string' && !_isNode(dirty)) {
            // eslint-disable-next-line no-negated-condition
            if (typeof dirty.toString !== 'function') {
              throw typeErrorCreate('toString is not a function');
            } else {
              dirty = dirty.toString();

              if (typeof dirty !== 'string') {
                throw typeErrorCreate('dirty is not a string, aborting');
              }
            }
          }
          /* Check we can run. Otherwise fall back or ignore */


          if (!DOMPurify.isSupported) {
            if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
              if (typeof dirty === 'string') {
                return window.toStaticHTML(dirty);
              }

              if (_isNode(dirty)) {
                return window.toStaticHTML(dirty.outerHTML);
              }
            }

            return dirty;
          }
          /* Assign config vars */


          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          /* Clean up removed elements */


          DOMPurify.removed = [];
          /* Check if dirty is correctly typed for IN_PLACE */

          if (typeof dirty === 'string') {
            IN_PLACE = false;
          }

          if (IN_PLACE) {
            /* Do some early pre-sanitization to avoid unsafe root nodes */
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);

              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
              }
            }
          } else if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
               elements being stripped by the parser */
            body = _initDocument('<!---->');
            importedNode = body.ownerDocument.importNode(dirty, true);

            if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
              /* Node is already a body, use as is */
              body = importedNode;
            } else if (importedNode.nodeName === 'HTML') {
              body = importedNode;
            } else {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              body.appendChild(importedNode);
            }
          } else {
            /* Exit directly if we have nothing to do */
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf('<') === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            /* Initialize the document to work on */


            body = _initDocument(dirty);
            /* Check we have a DOM node from the data */

            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
            }
          }
          /* Remove first element node (ours) if FORCE_BODY is set */


          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          /* Get node iterator */


          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          /* Now start iterating over the created document */


          while (currentNode = nodeIterator.nextNode()) {
            /* Fix IE's strange behavior with manipulated textNodes #89 */
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            /* Sanitize tags and elements */


            if (_sanitizeElements(currentNode)) {
              continue;
            }
            /* Shadow DOM detected, sanitize it */


            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
            /* Check attributes, sanitize if necessary */


            _sanitizeAttributes(currentNode);

            oldNode = currentNode;
          }

          oldNode = null;
          /* If we sanitized `dirty` in-place, return it. */

          if (IN_PLACE) {
            return dirty;
          }
          /* Return sanitized string or DOM */


          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);

              while (body.firstChild) {
                // eslint-disable-next-line unicorn/prefer-dom-node-append
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }

            if (ALLOWED_ATTR.shadowroot) {
              /*
                AdoptNode() is not used because internal state is not reset
                (e.g. the past names map of a HTMLFormElement), this is safe
                in theory but we would rather not risk another attack vector.
                The state that is cloned by importNode() is explicitly defined
                by the specs.
              */
              returnNode = importNode.call(originalDocument, returnNode, true);
            }

            return returnNode;
          }

          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          /* Serialize doctype if allowed */

          if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
          }
          /* Sanitize final string template-safe */


          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, ' ');
          }

          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        /**
         * Public method to set the configuration once
         * setConfig
         *
         * @param {Object} cfg configuration object
         */


        DOMPurify.setConfig = function (cfg) {
          _parseConfig(cfg);

          SET_CONFIG = true;
        };
        /**
         * Public method to remove the configuration
         * clearConfig
         *
         */


        DOMPurify.clearConfig = function () {
          CONFIG = null;
          SET_CONFIG = false;
        };
        /**
         * Public method to check if an attribute value is valid.
         * Uses last set config, if any. Otherwise, uses config defaults.
         * isValidAttribute
         *
         * @param  {string} tag Tag name of containing element.
         * @param  {string} attr Attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
         */


        DOMPurify.isValidAttribute = function (tag, attr, value) {
          /* Initialize shared config vars if necessary. */
          if (!CONFIG) {
            _parseConfig({});
          }

          var lcTag = transformCaseFunc(tag);
          var lcName = transformCaseFunc(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };
        /**
         * AddHook
         * Public method to add DOMPurify hooks
         *
         * @param {String} entryPoint entry point for the hook to add
         * @param {Function} hookFunction function to execute
         */


        DOMPurify.addHook = function (entryPoint, hookFunction) {
          if (typeof hookFunction !== 'function') {
            return;
          }

          hooks[entryPoint] = hooks[entryPoint] || [];
          arrayPush(hooks[entryPoint], hookFunction);
        };
        /**
         * RemoveHook
         * Public method to remove a DOMPurify hook at a given entryPoint
         * (pops it from the stack of hooks if more are present)
         *
         * @param {String} entryPoint entry point for the hook to remove
         * @return {Function} removed(popped) hook
         */


        DOMPurify.removeHook = function (entryPoint) {
          if (hooks[entryPoint]) {
            return arrayPop(hooks[entryPoint]);
          }
        };
        /**
         * RemoveHooks
         * Public method to remove all DOMPurify hooks at a given entryPoint
         *
         * @param  {String} entryPoint entry point for the hooks to remove
         */


        DOMPurify.removeHooks = function (entryPoint) {
          if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
          }
        };
        /**
         * RemoveAllHooks
         * Public method to remove all DOMPurify hooks
         *
         */


        DOMPurify.removeAllHooks = function () {
          hooks = {};
        };

        return DOMPurify;
      }

      var purify = createDOMPurify();

      return purify;

    }));

    }(purify));

    var DOMPurify = purify.exports;

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z$f = ".message a {\n\n    --tw-text-opacity: 1;\n\n    color: rgb(2 132 199 / var(--tw-text-opacity));\n\n    text-decoration-line: underline\n}\n\n.message a:hover {\n\n    text-decoration-line: none\n}\n";
    styleInject(css_248z$f,{"insertAt":"top"});

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i$3 = 0; i$3 < 256; ++i$3) {
      byteToHex.push((i$3 + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html

    var _nodeId;

    var _clockseq; // Previous uuid creation time


    var _lastMSecs = 0;
    var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || new Array(16);
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189

      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || rng)();

        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }

        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


      var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock

      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval


      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested


      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

      msecs += 12219292800000; // `time_low`

      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff; // `time_mid`

      var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`

      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

      b[i++] = clockseq & 0xff; // `node`

      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf || stringify(b);
    }

    function parse(uuid) {
      if (!validate(uuid)) {
        throw TypeError('Invalid UUID');
      }

      var v;
      var arr = new Uint8Array(16); // Parse ########-....-....-....-............

      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 0xff;
      arr[2] = v >>> 8 & 0xff;
      arr[3] = v & 0xff; // Parse ........-####-....-....-............

      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 0xff; // Parse ........-....-####-....-............

      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 0xff; // Parse ........-....-....-####-............

      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 0xff; // Parse ........-....-....-....-############
      // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
      arr[11] = v / 0x100000000 & 0xff;
      arr[12] = v >>> 24 & 0xff;
      arr[13] = v >>> 16 & 0xff;
      arr[14] = v >>> 8 & 0xff;
      arr[15] = v & 0xff;
      return arr;
    }

    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str)); // UTF8 escape

      var bytes = [];

      for (var i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }

      return bytes;
    }

    var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    var URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    function v35 (name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === 'string') {
          value = stringToBytes(value);
        }

        if (typeof namespace === 'string') {
          namespace = parse(namespace);
        }

        if (namespace.length !== 16) {
          throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`


        var bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;

        if (buf) {
          offset = offset || 0;

          for (var i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }

          return buf;
        }

        return stringify(bytes);
      } // Function#name is not settable on some platforms (#270)


      try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
      } catch (err) {} // For CommonJS default export support


      generateUUID.DNS = DNS;
      generateUUID.URL = URL$1;
      return generateUUID;
    }

    /*
     * Browser-compatible JavaScript MD5
     *
     * Modification of JavaScript MD5
     * https://github.com/blueimp/JavaScript-MD5
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * https://opensource.org/licenses/MIT
     *
     * Based on
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */
    function md5(bytes) {
      if (typeof bytes === 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = new Uint8Array(msg.length);

        for (var i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }

      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    /*
     * Convert an array of little-endian words to an array of bytes
     */


    function md5ToHexEncodedArray(input) {
      var output = [];
      var length32 = input.length * 32;
      var hexTab = '0123456789abcdef';

      for (var i = 0; i < length32; i += 8) {
        var x = input[i >> 5] >>> i % 32 & 0xff;
        var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
      }

      return output;
    }
    /**
     * Calculate output length with padding and bit length
     */


    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */


    function wordsToMd5(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << len % 32;
      x[getOutputLength(len) - 1] = len;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;

      for (var i = 0; i < x.length; i += 16) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }

      return [a, b, c, d];
    }
    /*
     * Convert an array bytes to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */


    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }

      var length8 = input.length * 8;
      var output = new Uint32Array(getOutputLength(length8));

      for (var i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
      }

      return output;
    }
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */


    function safeAdd(x, y) {
      var lsw = (x & 0xffff) + (y & 0xffff);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 0xffff;
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */


    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    /*
     * These functions implement the four basic operations the algorithm uses.
     */


    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }

    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }

    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }

    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }

    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }

    var v3 = v35('v3', 0x30, md5);
    var v3$1 = v3;

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    // Adapted from Chris Veness' SHA1 code at
    // http://www.movable-type.co.uk/scripts/sha1.html
    function f$4(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;

        case 1:
          return x ^ y ^ z;

        case 2:
          return x & y ^ x & z ^ y & z;

        case 3:
          return x ^ y ^ z;
      }
    }

    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }

    function sha1(bytes) {
      var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
      var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

      if (typeof bytes === 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = [];

        for (var i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        // Convert Array-like to Array
        bytes = Array.prototype.slice.call(bytes);
      }

      bytes.push(0x80);
      var l = bytes.length / 4 + 2;
      var N = Math.ceil(l / 16);
      var M = new Array(N);

      for (var _i = 0; _i < N; ++_i) {
        var arr = new Uint32Array(16);

        for (var j = 0; j < 16; ++j) {
          arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
        }

        M[_i] = arr;
      }

      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

      for (var _i2 = 0; _i2 < N; ++_i2) {
        var W = new Uint32Array(80);

        for (var t = 0; t < 16; ++t) {
          W[t] = M[_i2][t];
        }

        for (var _t = 16; _t < 80; ++_t) {
          W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
        }

        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];

        for (var _t2 = 0; _t2 < 80; ++_t2) {
          var s = Math.floor(_t2 / 20);
          var T = ROTL(a, 5) + f$4(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }

        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }

      return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
    }

    var v5 = v35('v5', 0x50, sha1);
    var v5$1 = v5;

    var nil = '00000000-0000-0000-0000-000000000000';

    function version(uuid) {
      if (!validate(uuid)) {
        throw TypeError('Invalid UUID');
      }

      return parseInt(uuid.substr(14, 1), 16);
    }

    var esmBrowser = /*#__PURE__*/Object.freeze({
        __proto__: null,
        v1: v1,
        v3: v3$1,
        v4: v4,
        v5: v5$1,
        NIL: nil,
        version: version,
        validate: validate,
        stringify: stringify,
        parse: parse
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(esmBrowser);

    /**
     * Converter
     *
     * @param {string|Array} srcAlphabet
     * @param {string|Array} dstAlphabet
     * @constructor
     */
    function Converter$1(srcAlphabet, dstAlphabet) {
        if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
            throw new Error('Bad alphabet');
        }
        this.srcAlphabet = srcAlphabet;
        this.dstAlphabet = dstAlphabet;
    }

    /**
     * Convert number from source alphabet to destination alphabet
     *
     * @param {string|Array} number - number represented as a string or array of points
     *
     * @returns {string|Array}
     */
    Converter$1.prototype.convert = function(number) {
        var i, divide, newlen,
        numberMap = {},
        fromBase = this.srcAlphabet.length,
        toBase = this.dstAlphabet.length,
        length = number.length,
        result = typeof number === 'string' ? '' : [];

        if (!this.isValid(number)) {
            throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
        }

        if (this.srcAlphabet === this.dstAlphabet) {
            return number;
        }

        for (i = 0; i < length; i++) {
            numberMap[i] = this.srcAlphabet.indexOf(number[i]);
        }
        do {
            divide = 0;
            newlen = 0;
            for (i = 0; i < length; i++) {
                divide = divide * fromBase + numberMap[i];
                if (divide >= toBase) {
                    numberMap[newlen++] = parseInt(divide / toBase, 10);
                    divide = divide % toBase;
                } else if (newlen > 0) {
                    numberMap[newlen++] = 0;
                }
            }
            length = newlen;
            result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
        } while (newlen !== 0);

        return result;
    };

    /**
     * Valid number with source alphabet
     *
     * @param {number} number
     *
     * @returns {boolean}
     */
    Converter$1.prototype.isValid = function(number) {
        var i = 0;
        for (; i < number.length; ++i) {
            if (this.srcAlphabet.indexOf(number[i]) === -1) {
                return false;
            }
        }
        return true;
    };

    var converter = Converter$1;

    var Converter = converter;

    /**
     * Function get source and destination alphabet and return convert function
     *
     * @param {string|Array} srcAlphabet
     * @param {string|Array} dstAlphabet
     *
     * @returns {function(number|Array)}
     */
    function anyBase$1(srcAlphabet, dstAlphabet) {
        var converter = new Converter(srcAlphabet, dstAlphabet);
        /**
         * Convert function
         *
         * @param {string|Array} number
         *
         * @return {string|Array} number
         */
        return function (number) {
            return converter.convert(number);
        }
    }
    anyBase$1.BIN = '01';
    anyBase$1.OCT = '01234567';
    anyBase$1.DEC = '0123456789';
    anyBase$1.HEX = '0123456789abcdef';

    var anyBase_1 = anyBase$1;

    /**
     * Created by Samuel on 6/4/2016.
     * Simple wrapper functions to produce shorter UUIDs for cookies, maybe everything?
     */

    const { v4: uuidv4 } = require$$0;
    const anyBase = anyBase_1;

    const flickrBase58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
    const cookieBase90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";

    const baseOptions = {
      consistentLength: true,
    };

    // A default generator, instantiated only if used.
    let toFlickr;

    /**
     * Takes a UUID, strips the dashes, and translates.
     * @param {string} longId
     * @param {function(string)} translator
     * @param {Object} [paddingParams]
     * @returns {string}
     */
    const shortenUUID = (longId, translator, paddingParams) => {
      const translated = translator(longId.toLowerCase().replace(/-/g, ''));

      if (!paddingParams || !paddingParams.consistentLength) return translated;

      return translated.padStart(
        paddingParams.shortIdLength,
        paddingParams.paddingChar,
      );
    };

    /**
     * Translate back to hex and turn back into UUID format, with dashes
     * @param {string} shortId
     * @param {function(string)} translator
     * @returns {string}
     */
    const enlargeUUID = (shortId, translator) => {
      const uu1 = translator(shortId).padStart(32, '0');

      // Join the zero padding and the UUID and then slice it up with match
      const m = uu1.match(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/);

      // Accumulate the matches and join them.
      return [m[1], m[2], m[3], m[4], m[5]].join('-');
    };

    // Calculate length for the shortened ID
    const getShortIdLength = (alphabetLength) => (
      Math.ceil(Math.log(2 ** 128) / Math.log(alphabetLength)));

    var shortUuid = (() => {
      /**
       * @param {string} toAlphabet - Defaults to flickrBase58 if not provided
       * @param {Object} [options]
       *
       * @returns {{new: (function()),
       *  uuid: (function()),
       *  fromUUID: (function(string)),
       *  toUUID: (function(string)),
       *  alphabet: (string)}}
       */
      const makeConvertor = (toAlphabet, options) => {
        // Default to Flickr 58
        const useAlphabet = toAlphabet || flickrBase58;

        // Default to baseOptions
        const selectedOptions = { ...baseOptions, ...options };

        // Check alphabet for duplicate entries
        if ([...new Set(Array.from(useAlphabet))].length !== useAlphabet.length) {
          throw new Error('The provided Alphabet has duplicate characters resulting in unreliable results');
        }

        const shortIdLength = getShortIdLength(useAlphabet.length);

        // Padding Params
        const paddingParams = {
          shortIdLength,
          consistentLength: selectedOptions.consistentLength,
          paddingChar: useAlphabet[0],
        };

        // UUIDs are in hex, so we translate to and from.
        const fromHex = anyBase(anyBase.HEX, useAlphabet);
        const toHex = anyBase(useAlphabet, anyBase.HEX);
        const generate = () => shortenUUID(uuidv4(), fromHex, paddingParams);

        const translator = {
          new: generate,
          generate,
          uuid: uuidv4,
          fromUUID: (uuid) => shortenUUID(uuid, fromHex, paddingParams),
          toUUID: (shortUuid) => enlargeUUID(shortUuid, toHex),
          alphabet: useAlphabet,
          maxLength: shortIdLength,
        };

        Object.freeze(translator);

        return translator;
      };

      // Expose the constants for other purposes.
      makeConvertor.constants = {
        flickrBase58,
        cookieBase90,
      };

      // Expose the generic v4 UUID generator for convenience
      makeConvertor.uuid = uuidv4;

      // Provide a generic generator
      makeConvertor.generate = () => {
        if (!toFlickr) {
          // Generate on first use;
          toFlickr = makeConvertor(flickrBase58).generate;
        }
        return toFlickr();
      };

      return makeConvertor;
    })();

    var classNames = function () {
        var classes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            classes[_i] = arguments[_i];
        }
        return classes.filter(Boolean).join(' ');
    };
    var getFileUrl = function (url) {
        var uid = api.get('rc_uid');
        var token = api.get('rc_token');
        return encodeURI("".concat(url, "?rc_uid=").concat(uid, "&rc_token=").concat(token));
    };
    var generateUploader = function (rid, file, id) {
        var decimalTranslator = shortUuid('0123456789');
        var uuid = id ? id : decimalTranslator.generate();
        return {
            id: uuid,
            name: file.name,
            ts: Date.now(),
            progress: 0,
            canReUpload: false,
            error: false,
            rid: rid
        };
    };
    var formatToMMSS = function (time) {
        var sec_num = time;
        var hours = Math.floor(sec_num / 3600);
        var minutes = Math.floor((sec_num - hours * 3600) / 60);
        var seconds = sec_num - hours * 3600 - minutes * 60;
        var minutesString = minutes < 10 ? '0' + minutes : minutes.toString();
        var secondsString = seconds < 10 ? '0' + seconds : seconds.toString();
        return minutesString + ':' + secondsString;
    };

    var useAppDispatch = useDispatch;
    var useAppSelector = useSelector;

    var Context = require$$0$1.createContext(null);
    var themes = {
        TEAL: 'teal',
    };
    var ThemeProvider = function (_a) {
        var children = _a.children, theme = _a.theme;
        return React.createElement(Context.Provider, { value: { theme: theme, themes: themes } }, children);
    };
    var useTheme = function () { return require$$0$1.useContext(Context); };

    var renderer = new marked.Renderer();
    renderer.link = function (href, title, text) {
        var link = marked.Renderer.prototype.link.call(this, href, title, text);
        return link.replace("<a", "<a target='_blank' rel='noopener noreferrer' ");
    };
    marked.use({
        renderer: renderer
    });
    var MessageBody = function (_a) {
        var message = _a.message;
        var _b = useTheme(), theme = _b.theme, themes = _b.themes;
        var content = require$$0$1.useMemo(function () {
            //return EmojiOne.toImage(DOMPurify.sanitize(marked.parse(message.msg)))
            return DOMPurify.sanitize(marked.parse(message.msg), {
                ADD_ATTR: ['target'],
                FORBID_ATTR: ['style'],
                FORBID_TAGS: ['style']
            });
        }, [message.msg]);
        var user = useAppSelector(function (state) { return state.user; }).user;
        var myMessage = require$$0$1.useMemo(function () {
            return (user === null || user === void 0 ? void 0 : user._id) === message.u._id;
        }, [user === null || user === void 0 ? void 0 : user._id, message.u._id]);
        return (React.createElement("div", { className: classNames('p-4 pb-2 [&:not(:first-child)]:pt-0 break-words', myMessage
                ? theme === themes.TEAL
                    ? 'text-theme-teal-2'
                    : 'text-sky-900'
                : 'text-gray-900'), dangerouslySetInnerHTML: { __html: content } }));
    };

    var css_248z$e = "";
    styleInject(css_248z$e,{"insertAt":"top"});

    const React$c = require$$0__default["default"];

    function ArrowPathIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$c.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$c.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$c.createElement("path", {
        fillRule: "evenodd",
        d: "M4.755 10.059a7.5 7.5 0 0112.548-3.364l1.903 1.903h-3.183a.75.75 0 100 1.5h4.992a.75.75 0 00.75-.75V4.356a.75.75 0 00-1.5 0v3.18l-1.9-1.9A9 9 0 003.306 9.67a.75.75 0 101.45.388zm15.408 3.352a.75.75 0 00-.919.53 7.5 7.5 0 01-12.548 3.364l-1.902-1.903h3.183a.75.75 0 000-1.5H2.984a.75.75 0 00-.75.75v4.992a.75.75 0 001.5 0v-3.18l1.9 1.9a9 9 0 0015.059-4.035.75.75 0 00-.53-.918z",
        clipRule: "evenodd"
      }));
    }

    const ForwardRef$a = React$c.forwardRef(ArrowPathIcon$1);
    var ArrowPathIcon_1 = ForwardRef$a;

    const React$b = require$$0__default["default"];

    function CheckCircleIcon$3({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$b.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$b.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$b.createElement("path", {
        fillRule: "evenodd",
        d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z",
        clipRule: "evenodd"
      }));
    }

    const ForwardRef$9 = React$b.forwardRef(CheckCircleIcon$3);
    var CheckCircleIcon_1$1 = ForwardRef$9;

    const React$a = require$$0__default["default"];

    function DocumentIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$a.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$a.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$a.createElement("path", {
        d: "M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0016.5 9h-1.875a1.875 1.875 0 01-1.875-1.875V5.25A3.75 3.75 0 009 1.5H5.625z"
      }), /*#__PURE__*/React$a.createElement("path", {
        d: "M12.971 1.816A5.23 5.23 0 0114.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 013.434 1.279 9.768 9.768 0 00-6.963-6.963z"
      }));
    }

    const ForwardRef$8 = React$a.forwardRef(DocumentIcon$1);
    var DocumentIcon_1 = ForwardRef$8;

    const React$9 = require$$0__default["default"];

    function EllipsisHorizontalIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$9.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$9.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$9.createElement("path", {
        fillRule: "evenodd",
        d: "M4.5 12a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm6 0a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm6 0a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0z",
        clipRule: "evenodd"
      }));
    }

    const ForwardRef$7 = React$9.forwardRef(EllipsisHorizontalIcon$1);
    var EllipsisHorizontalIcon_1 = ForwardRef$7;

    const React$8 = require$$0__default["default"];

    function MicrophoneIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$8.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$8.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$8.createElement("path", {
        d: "M8.25 4.5a3.75 3.75 0 117.5 0v8.25a3.75 3.75 0 11-7.5 0V4.5z"
      }), /*#__PURE__*/React$8.createElement("path", {
        d: "M6 10.5a.75.75 0 01.75.75v1.5a5.25 5.25 0 1010.5 0v-1.5a.75.75 0 011.5 0v1.5a6.751 6.751 0 01-6 6.709v2.291h3a.75.75 0 010 1.5h-7.5a.75.75 0 010-1.5h3v-2.291a6.751 6.751 0 01-6-6.709v-1.5A.75.75 0 016 10.5z"
      }));
    }

    const ForwardRef$6 = React$8.forwardRef(MicrophoneIcon$1);
    var MicrophoneIcon_1 = ForwardRef$6;

    const React$7 = require$$0__default["default"];

    function PaperAirplaneIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$7.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$7.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$7.createElement("path", {
        d: "M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z"
      }));
    }

    const ForwardRef$5 = React$7.forwardRef(PaperAirplaneIcon$1);
    var PaperAirplaneIcon_1 = ForwardRef$5;

    const React$6 = require$$0__default["default"];

    function PaperClipIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$6.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$6.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$6.createElement("path", {
        fillRule: "evenodd",
        d: "M18.97 3.659a2.25 2.25 0 00-3.182 0l-10.94 10.94a3.75 3.75 0 105.304 5.303l7.693-7.693a.75.75 0 011.06 1.06l-7.693 7.693a5.25 5.25 0 11-7.424-7.424l10.939-10.94a3.75 3.75 0 115.303 5.304L9.097 18.835l-.008.008-.007.007-.002.002-.003.002A2.25 2.25 0 015.91 15.66l7.81-7.81a.75.75 0 011.061 1.06l-7.81 7.81a.75.75 0 001.054 1.068L18.97 6.84a2.25 2.25 0 000-3.182z",
        clipRule: "evenodd"
      }));
    }

    const ForwardRef$4 = React$6.forwardRef(PaperClipIcon$1);
    var PaperClipIcon_1 = ForwardRef$4;

    const React$5 = require$$0__default["default"];

    function XMarkIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$5.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$5.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$5.createElement("path", {
        fillRule: "evenodd",
        d: "M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z",
        clipRule: "evenodd"
      }));
    }

    const ForwardRef$3 = React$5.forwardRef(XMarkIcon$1);
    var XMarkIcon_1 = ForwardRef$3;

    var ArrowPathIcon = ArrowPathIcon_1;
    var CheckCircleIcon$2 = CheckCircleIcon_1$1;
    var DocumentIcon = DocumentIcon_1;
    var EllipsisHorizontalIcon = EllipsisHorizontalIcon_1;
    var MicrophoneIcon = MicrophoneIcon_1;
    var PaperAirplaneIcon = PaperAirplaneIcon_1;
    var PaperClipIcon = PaperClipIcon_1;
    var XMarkIcon = XMarkIcon_1;

    const React$4 = require$$0__default["default"];

    function ArrowDownTrayIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$4.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$4.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$4.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"
      }));
    }

    const ForwardRef$2 = React$4.forwardRef(ArrowDownTrayIcon$1);
    var ArrowDownTrayIcon_1 = ForwardRef$2;

    const React$3 = require$$0__default["default"];

    function CheckCircleIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$3.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$3.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$3.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
      }));
    }

    const ForwardRef$1 = React$3.forwardRef(CheckCircleIcon$1);
    var CheckCircleIcon_1 = ForwardRef$1;

    const React$2 = require$$0__default["default"];

    function XCircleIcon$1({
      title,
      titleId,
      ...props
    }, svgRef) {
      return /*#__PURE__*/React$2.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        ref: svgRef,
        "aria-labelledby": titleId
      }, props), title ? /*#__PURE__*/React$2.createElement("title", {
        id: titleId
      }, title) : null, /*#__PURE__*/React$2.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9.75 9.75l4.5 4.5m0-4.5l-4.5 4.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
      }));
    }

    const ForwardRef = React$2.forwardRef(XCircleIcon$1);
    var XCircleIcon_1 = ForwardRef;

    var ArrowDownTrayIcon = ArrowDownTrayIcon_1;
    var CheckCircleIcon = CheckCircleIcon_1;
    var XCircleIcon = XCircleIcon_1;

    function toInteger(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }

      var number = Number(dirtyNumber);

      if (isNaN(number)) {
        return number;
      }

      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */

    function addMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var timestamp = toDate(dirtyDate).getTime();
      var amount = toInteger(dirtyAmount);
      return new Date(timestamp + amount);
    }

    var defaultOptions$2 = {};
    function getDefaultOptions() {
      return defaultOptions$2;
    }

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    /**
     * @name startOfDay
     * @category Day Helpers
     * @summary Return the start of a day for the given date.
     *
     * @description
     * Return the start of a day for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a day for 2 September 2014 11:55:00:
     * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 00:00:00
     */

    function startOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    var MILLISECONDS_IN_DAY$1 = 86400000;
    /**
     * @name differenceInCalendarDays
     * @category Day Helpers
     * @summary Get the number of calendar days between the given dates.
     *
     * @description
     * Get the number of calendar days between the given dates. This means that the times are removed
     * from the dates and then the difference in days is calculated.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar days
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInCalendarDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 366
     * // How many calendar days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInCalendarDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 1
     */

    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var startOfDayLeft = startOfDay(dirtyDateLeft);
      var startOfDayRight = startOfDay(dirtyDateRight);
      var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
      var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
      // because the number of milliseconds in a day is not constant
      // (e.g. it's different in the day of the daylight saving time clock shift)

      return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
    }

    /**
     * @name isSameDay
     * @category Day Helpers
     * @summary Are the given dates in the same day (and year and month)?
     *
     * @description
     * Are the given dates in the same day (and year and month)?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same day (and year and month)
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
     * //=> true
     *
     * @example
     * // Are 4 September and 4 October in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
     * //=> false
     *
     * @example
     * // Are 4 September, 2014 and 4 September, 2015 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
     * //=> false
     */

    function isSameDay(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
      var dateRightStartOfDay = startOfDay(dirtyDateRight);
      return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
    }

    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
    /**
     * @name isDate
     * @category Common Helpers
     * @summary Is the given value a date?
     *
     * @description
     * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
     *
     * @param {*} value - the value to check
     * @returns {boolean} true if the given value is a date
     * @throws {TypeError} 1 arguments required
     *
     * @example
     * // For a valid date:
     * const result = isDate(new Date())
     * //=> true
     *
     * @example
     * // For an invalid date:
     * const result = isDate(new Date(NaN))
     * //=> true
     *
     * @example
     * // For some value:
     * const result = isDate('2014-02-31')
     * //=> false
     *
     * @example
     * // For an object:
     * const result = isDate({})
     * //=> false
     */

    function isDate(value) {
      requiredArgs(1, arguments);
      return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * const result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * const result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * const result = isValid(new Date(''))
     * //=> false
     */

    function isValid(dirtyDate) {
      requiredArgs(1, arguments);

      if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
        return false;
      }

      var date = toDate(dirtyDate);
      return !isNaN(Number(date));
    }

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */

    function subMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }

    var MILLISECONDS_IN_DAY = 86400000;
    function getUTCDayOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }

    function startOfUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000;
    function getUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    function startOfUTCWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getUTCWeekYear(dirtyDate, options);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, options);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000;
    function getUTCWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();

      while (output.length < targetLength) {
        output = '0' + output;
      }

      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */

    var formatters$2 = {
      // Year
      y: function y(date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function d(date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return dayPeriodEnumValue.toUpperCase();

          case 'aaa':
            return dayPeriodEnumValue;

          case 'aaaaa':
            return dayPeriodEnumValue[0];

          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function h(date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function H(date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function m(date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function s(date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    var formatters$3 = formatters$2;

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    };

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */
    var formatters = {
      // Era
      G: function G(date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;

        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B

          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function y(date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }

        return formatters$3.y(date, token);
      },
      // Local week-numbering year
      Y: function Y(date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        } // Ordinal number


        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        } // Padding


        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function R(date, token) {
        var isoWeekYear = getUTCISOWeekYear(date); // Padding

        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function u(date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function Q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'QQ':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'qq':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function M(date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          case 'M':
          case 'MM':
            return formatters$3.M(date, token);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function L(date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12

          case 'LL':
            return addLeadingZeros(month + 1, 2);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function w(date, token, localize, options) {
        var week = getUTCWeek(date, options);

        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }

        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function I(date, token, localize) {
        var isoWeek = getUTCISOWeek(date);

        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }

        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function d(date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }

        return formatters$3.d(date, token);
      },
      // Day of year
      D: function D(date, token, localize) {
        var dayOfYear = getUTCDayOfYear(date);

        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }

        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function E(date, token, localize) {
        var dayOfWeek = date.getUTCDay();

        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function e(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'ee':
            return addLeadingZeros(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th

          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function c(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'cc':
            return addLeadingZeros(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th

          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function i(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02

          case 'ii':
            return addLeadingZeros(isoDayOfWeek, token.length);
          // 2nd

          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function a(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function b(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }

        switch (token) {
          case 'b':
          case 'bb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function B(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }

        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function h(date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return formatters$3.h(date, token);
      },
      // Hour [0-23]
      H: function H(date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }

        return formatters$3.H(date, token);
      },
      // Hour [0-11]
      K: function K(date, token, localize) {
        var hours = date.getUTCHours() % 12;

        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function k(date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;

        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function m(date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }

        return formatters$3.m(date, token);
      },
      // Second
      s: function s(date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }

        return formatters$3.s(date, token);
      },
      // Fraction of second
      S: function S(date, token) {
        return formatters$3.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        if (timezoneOffset === 0) {
          return 'Z';
        }

        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`

          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`

          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`

          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`

          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };

    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;

      if (minutes === 0) {
        return sign + String(hours);
      }

      var delimiter = dirtyDelimiter || '';
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }

    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }

      return formatTimezone(offset, dirtyDelimiter);
    }

    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    var formatters$1 = formatters;

    var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });

        case 'PP':
          return formatLong.date({
            width: 'medium'
          });

        case 'PPP':
          return formatLong.date({
            width: 'long'
          });

        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    };

    var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });

        case 'pp':
          return formatLong.time({
            width: 'medium'
          });

        case 'ppp':
          return formatLong.time({
            width: 'long'
          });

        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    };

    var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];

      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }

      var dateTimeFormat;

      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;

        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;

        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;

        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }

      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    };

    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    var longFormatters$1 = longFormatters;

    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }

    var formatDistanceLocale$1 = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };

    var formatDistance$2 = function formatDistance(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$1[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    };

    var formatDistance$3 = formatDistance$2;

    function buildFormatLongFn(args) {
      return function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // TODO: Remove String()
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats$2 = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats$2 = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats$2 = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$4 = {
      date: buildFormatLongFn({
        formats: dateFormats$2,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$2,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$2,
        defaultWidth: 'full'
      })
    };
    var formatLong$5 = formatLong$4;

    var formatRelativeLocale$1 = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };

    var formatRelative$3 = function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale$1[token];
    };

    var formatRelative$4 = formatRelative$3;

    function buildLocalizeFn(args) {
      return function (dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

        return valuesArray[index];
      };
    }

    var eraValues$1 = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues$1 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
    }; // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues$1 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues$1 = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues$1 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues$1 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    var ordinalNumber$1 = function ordinalNumber(dirtyNumber, _options) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`.
      //
      // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'.

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    };

    var localize$2 = {
      ordinalNumber: ordinalNumber$1,
      era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: 'wide'
      })
    };
    var localize$3 = localize$2;

    function buildMatchFn(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }

      return undefined;
    }

    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }

      return undefined;
    }

    function buildMatchPatternFn(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    var matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern$1 = /\d+/i;
    var matchEraPatterns$1 = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns$1 = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns$1 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns$1 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$1 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns$1 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$1 = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns$1 = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$1 = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns$1 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match$2 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: 'any'
      })
    };
    var match$3 = match$2;

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */
    var locale$2 = {
      code: 'en-US',
      formatDistance: formatDistance$3,
      formatLong: formatLong$5,
      formatRelative: formatRelative$4,
      localize: localize$3,
      match: match$3,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };
    var defaultLocale = locale$2;

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          | a..aa   | AM, PM                            |       |
     * |                                 | aaa     | am, pm                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
     * |                                 | bbb     | am, pm, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 001, ..., 999                |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 04/29/1453                        | 7     |
     * |                                 | PP      | Apr 29, 1453                      | 7     |
     * |                                 | PPP     | April 29th, 1453                  | 7     |
     * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
     * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

      requiredArgs(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions = getDefaultOptions();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
      var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (!locale.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      var originalDate = toDate(dirtyDate);

      if (!isValid(originalDate)) {
        throw new RangeError('Invalid time value');
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters$1[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }

        return substring;
      }).join('').match(formattingTokensRegExp).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        var firstCharacter = substring[0];

        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }

        var formatter = formatters$1[firstCharacter];

        if (formatter) {
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }

          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }

          return formatter(utcDate, substring, locale.localize, formatterOptions);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        return substring;
      }).join('');
      return result;
    }

    function cleanEscapedString(input) {
      var matched = input.match(escapedStringRegExp);

      if (!matched) {
        return input;
      }

      return matched[1].replace(doubleQuoteRegExp, "'");
    }

    /**
     * @name formatRelative
     * @category Common Helpers
     * @summary Represent the date in words relative to the given base date.
     *
     * @description
     * Represent the date in words relative to the given base date.
     *
     * | Distance to the base date | Result                    |
     * |---------------------------|---------------------------|
     * | Previous 6 days           | last Sunday at 04:30 AM   |
     * | Last day                  | yesterday at 04:30 AM     |
     * | Same day                  | today at 04:30 AM         |
     * | Next day                  | tomorrow at 04:30 AM      |
     * | Next 6 days               | Sunday at 04:30 AM        |
     * | Other                     | 12/31/2017                |
     *
     * @param {Date|Number} date - the date to format
     * @param {Date|Number} baseDate - the date to compare with
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @returns {String} the date in words
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `baseDate` must not be Invalid Date
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.locale` must contain `formatRelative` property
     *
     * @example
     * // Represent the date of 6 days ago in words relative to the given base date. In this example, today is Wednesday
     * const result = formatRelative(addDays(new Date(), -6), new Date())
     * //=> "last Thursday at 12:45 AM"
     */

    function formatRelative$2(dirtyDate, dirtyBaseDate, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$weekStartsOn, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var baseDate = toDate(dirtyBaseDate);
      var defaultOptions = getDefaultOptions();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
      var weekStartsOn = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);

      if (!locale.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      if (!locale.formatRelative) {
        throw new RangeError('locale must contain formatRelative property');
      }

      var diff = differenceInCalendarDays(date, baseDate);

      if (isNaN(diff)) {
        throw new RangeError('Invalid time value');
      }

      var token;

      if (diff < -6) {
        token = 'other';
      } else if (diff < -1) {
        token = 'lastWeek';
      } else if (diff < 0) {
        token = 'yesterday';
      } else if (diff < 1) {
        token = 'today';
      } else if (diff < 2) {
        token = 'tomorrow';
      } else if (diff < 7) {
        token = 'nextWeek';
      } else {
        token = 'other';
      }

      var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
      var utcBaseDate = subMilliseconds(baseDate, getTimezoneOffsetInMilliseconds(baseDate));
      var formatStr = locale.formatRelative(token, utcDate, utcBaseDate, {
        locale: locale,
        weekStartsOn: weekStartsOn
      });
      return format(date, formatStr, {
        locale: locale,
        weekStartsOn: weekStartsOn
      });
    }

    var formatDistanceLocale = {
      lessThanXSeconds: {
        standalone: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        },
        withPreposition: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        }
      },
      xSeconds: {
        standalone: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        },
        withPreposition: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        }
      },
      halfAMinute: {
        standalone: 'halbe Minute',
        withPreposition: 'halben Minute'
      },
      lessThanXMinutes: {
        standalone: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        },
        withPreposition: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        }
      },
      xMinutes: {
        standalone: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        },
        withPreposition: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        }
      },
      aboutXHours: {
        standalone: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        },
        withPreposition: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        }
      },
      xHours: {
        standalone: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        },
        withPreposition: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        }
      },
      xDays: {
        standalone: {
          one: '1 Tag',
          other: '{{count}} Tage'
        },
        withPreposition: {
          one: '1 Tag',
          other: '{{count}} Tagen'
        }
      },
      aboutXWeeks: {
        standalone: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        },
        withPreposition: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        }
      },
      xWeeks: {
        standalone: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        },
        withPreposition: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        }
      },
      aboutXMonths: {
        standalone: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monate'
        },
        withPreposition: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monaten'
        }
      },
      xMonths: {
        standalone: {
          one: '1 Monat',
          other: '{{count}} Monate'
        },
        withPreposition: {
          one: '1 Monat',
          other: '{{count}} Monaten'
        }
      },
      aboutXYears: {
        standalone: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahre'
        },
        withPreposition: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahren'
        }
      },
      xYears: {
        standalone: {
          one: '1 Jahr',
          other: '{{count}} Jahre'
        },
        withPreposition: {
          one: '1 Jahr',
          other: '{{count}} Jahren'
        }
      },
      overXYears: {
        standalone: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahre'
        },
        withPreposition: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahren'
        }
      },
      almostXYears: {
        standalone: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahre'
        },
        withPreposition: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahren'
        }
      }
    };

    var formatDistance = function formatDistance(token, count, options) {
      var result;
      var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale[token].withPreposition : formatDistanceLocale[token].standalone;

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return 'vor ' + result;
        }
      }

      return result;
    };

    var formatDistance$1 = formatDistance;

    // DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008
    var dateFormats$1 = {
      full: 'EEEE, do MMMM y',
      // Montag, 7. Januar 2018
      long: 'do MMMM y',
      // 7. Januar 2018
      medium: 'do MMM y',
      // 7. Jan. 2018
      short: 'dd.MM.y' // 07.01.2018

    };
    var timeFormats$1 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$1 = {
      full: "{{date}} 'um' {{time}}",
      long: "{{date}} 'um' {{time}}",
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$2 = {
      date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: 'full'
      })
    };
    var formatLong$3 = formatLong$2;

    var formatRelativeLocale = {
      lastWeek: "'letzten' eeee 'um' p",
      yesterday: "'gestern um' p",
      today: "'heute um' p",
      tomorrow: "'morgen um' p",
      nextWeek: "eeee 'um' p",
      other: 'P'
    };

    var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };

    var formatRelative$1 = formatRelative;

    var eraValues = {
      narrow: ['v.Chr.', 'n.Chr.'],
      abbreviated: ['v.Chr.', 'n.Chr.'],
      wide: ['vor Christus', 'nach Christus']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal']
    }; // Note: in German, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
      wide: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
    }; // https://st.unicode.org/cldr-apps/v#/de/Gregorian/

    var formattingMonthValues = {
      narrow: monthValues.narrow,
      abbreviated: ['Jan.', 'Feb.', 'März', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'],
      wide: monthValues.wide
    };
    var dayValues = {
      narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
      short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
      wide: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag']
    }; // https://www.unicode.org/cldr/charts/32/summary/de.html#1881

    var dayPeriodValues = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachm.',
        evening: 'Abend',
        night: 'Nacht'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachm.',
        evening: 'abends',
        night: 'nachts'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      }
    };

    var ordinalNumber = function ordinalNumber(dirtyNumber) {
      var number = Number(dirtyNumber);
      return number + '.';
    };

    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        formattingValues: formattingMonthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };
    var localize$1 = localize;

    var matchOrdinalNumberPattern = /^(\d+)(\.)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
    };
    var parseEraPatterns = {
      any: [/^v/i, /^n/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](\.)? Quartal/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
      wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^j[aä]/i, /^f/i, /^mär/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smdmf]/i,
      short: /^(so|mo|di|mi|do|fr|sa)/i,
      abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
      wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
    };
    var parseDayPatterns = {
      any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^v/i,
        pm: /^n/i,
        midnight: /^Mitte/i,
        noon: /^Mitta/i,
        morning: /morgens/i,
        afternoon: /nachmittags/i,
        // will never be matched. Afternoon is matched by `pm`
        evening: /abends/i,
        night: /nachts/i // will never be matched. Night is matched by `pm`

      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };
    var match$1 = match;

    /**
     * @type {Locale}
     * @category Locales
     * @summary German locale.
     * @language German
     * @iso-639-2 deu
     * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
     * @author Asia [@asia-t]{@link https://github.com/asia-t}
     * @author Van Vuong Ngo [@vanvuongngo]{@link https://github.com/vanvuongngo}
     * @author RomanErnst [@pex]{@link https://github.com/pex}
     * @author Philipp Keck [@Philipp91]{@link https://github.com/Philipp91}
     */
    var locale$1 = {
      code: 'de',
      formatDistance: formatDistance$1,
      formatLong: formatLong$3,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };
    var de$2 = locale$1;

    var dateFormats = {
      full: 'EEEE, d MMMM yyyy',
      long: 'd MMMM yyyy',
      medium: 'd MMM yyyy',
      short: 'dd/MM/yyyy'
    };
    var timeFormats = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };
    var formatLong$1 = formatLong;

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United Kingdom).
     * @language English
     * @iso-639-2 eng
     * @author Alex [@glintik]{@link https://github.com/glintik}
     */

    var locale = {
      code: 'en-GB',
      formatDistance: formatDistance$3,
      formatLong: formatLong$1,
      formatRelative: formatRelative$4,
      localize: localize$3,
      match: match$3,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };
    var en$1 = locale;

    function warn() {
      if (console && console.warn) {
        var _console;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (typeof args[0] === 'string') args[0] = "react-i18next:: ".concat(args[0]);

        (_console = console).warn.apply(_console, args);
      }
    }
    var alreadyWarned = {};
    function warnOnce() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (typeof args[0] === 'string' && alreadyWarned[args[0]]) return;
      if (typeof args[0] === 'string') alreadyWarned[args[0]] = new Date();
      warn.apply(void 0, args);
    }
    function loadNamespaces(i18n, ns, cb) {
      i18n.loadNamespaces(ns, function () {
        if (i18n.isInitialized) {
          cb();
        } else {
          var initialized = function initialized() {
            setTimeout(function () {
              i18n.off('initialized', initialized);
            }, 0);
            cb();
          };

          i18n.on('initialized', initialized);
        }
      });
    }

    function oldI18nextHasLoadedNamespace(ns, i18n) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var lng = i18n.languages[0];
      var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
      var lastLng = i18n.languages[i18n.languages.length - 1];
      if (lng.toLowerCase() === 'cimode') return true;

      var loadNotPending = function loadNotPending(l, n) {
        var loadState = i18n.services.backendConnector.state["".concat(l, "|").concat(n)];
        return loadState === -1 || loadState === 2;
      };

      if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns)) return false;
      if (i18n.hasResourceBundle(lng, ns)) return true;
      if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }

    function hasLoadedNamespace(ns, i18n) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!i18n.languages || !i18n.languages.length) {
        warnOnce('i18n.languages were undefined or empty', i18n.languages);
        return true;
      }

      var isNewerI18next = i18n.options.ignoreJSONStructure !== undefined;

      if (!isNewerI18next) {
        return oldI18nextHasLoadedNamespace(ns, i18n, options);
      }

      return i18n.hasLoadedNamespace(ns, {
        precheck: function precheck(i18nInstance, loadNotPending) {
          if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18nInstance.services.backendConnector.backend && i18nInstance.isLanguageChangingTo && !loadNotPending(i18nInstance.isLanguageChangingTo, ns)) return false;
        }
      });
    }

    var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
    var htmlEntities = {
      '&amp;': '&',
      '&#38;': '&',
      '&lt;': '<',
      '&#60;': '<',
      '&gt;': '>',
      '&#62;': '>',
      '&apos;': "'",
      '&#39;': "'",
      '&quot;': '"',
      '&#34;': '"',
      '&nbsp;': ' ',
      '&#160;': ' ',
      '&copy;': '©',
      '&#169;': '©',
      '&reg;': '®',
      '&#174;': '®',
      '&hellip;': '…',
      '&#8230;': '…',
      '&#x2F;': '/',
      '&#47;': '/'
    };

    var unescapeHtmlEntity = function unescapeHtmlEntity(m) {
      return htmlEntities[m];
    };

    var unescape$1 = function unescape(text) {
      return text.replace(matchHtmlEntity, unescapeHtmlEntity);
    };

    function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
    var defaultOptions$1 = {
      bindI18n: 'languageChanged',
      bindI18nStore: '',
      transEmptyNodeValue: '',
      transSupportBasicHtmlNodes: true,
      transWrapTextNodes: '',
      transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],
      useSuspense: true,
      unescape: unescape$1
    };
    function setDefaults() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      defaultOptions$1 = _objectSpread$8(_objectSpread$8({}, defaultOptions$1), options);
    }
    function getDefaults() {
      return defaultOptions$1;
    }

    var i18nInstance;
    function setI18n(instance) {
      i18nInstance = instance;
    }
    function getI18n() {
      return i18nInstance;
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    var initReactI18next = {
      type: '3rdParty',
      init: function init(instance) {
        setDefaults(instance.options.react);
        setI18n(instance);
      }
    };

    var I18nContext = require$$0$1.createContext();
    var ReportNamespaces = function () {
      function ReportNamespaces() {
        _classCallCheck(this, ReportNamespaces);

        this.usedNamespaces = {};
      }

      _createClass(ReportNamespaces, [{
        key: "addUsedNamespaces",
        value: function addUsedNamespaces(namespaces) {
          var _this = this;

          namespaces.forEach(function (ns) {
            if (!_this.usedNamespaces[ns]) _this.usedNamespaces[ns] = true;
          });
        }
      }, {
        key: "getUsedNamespaces",
        value: function getUsedNamespaces() {
          return Object.keys(this.usedNamespaces);
        }
      }]);

      return ReportNamespaces;
    }();

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s,
          _e,
          _x,
          _r,
          _arr = [],
          _n = !0,
          _d = !1;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i) return;
            _n = !1;
          } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    var usePrevious = function usePrevious(value, ignore) {
      var ref = require$$0$1.useRef();
      require$$0$1.useEffect(function () {
        ref.current = ignore ? ref.current : value;
      }, [value, ignore]);
      return ref.current;
    };

    function useTranslation(ns) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var i18nFromProps = props.i18n;

      var _ref = require$$0$1.useContext(I18nContext) || {},
          i18nFromContext = _ref.i18n,
          defaultNSFromContext = _ref.defaultNS;

      var i18n = i18nFromProps || i18nFromContext || getI18n();
      if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();

      if (!i18n) {
        warnOnce('You will need to pass in an i18next instance by using initReactI18next');

        var notReadyT = function notReadyT(k) {
          return Array.isArray(k) ? k[k.length - 1] : k;
        };

        var retNotReady = [notReadyT, {}, false];
        retNotReady.t = notReadyT;
        retNotReady.i18n = {};
        retNotReady.ready = false;
        return retNotReady;
      }

      if (i18n.options.react && i18n.options.react.wait !== undefined) warnOnce('It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.');

      var i18nOptions = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, getDefaults()), i18n.options.react), props);

      var useSuspense = i18nOptions.useSuspense,
          keyPrefix = i18nOptions.keyPrefix;
      var namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
      namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];
      if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces);
      var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function (n) {
        return hasLoadedNamespace(n, i18n, i18nOptions);
      });

      function getT() {
        return i18n.getFixedT(null, i18nOptions.nsMode === 'fallback' ? namespaces : namespaces[0], keyPrefix);
      }

      var _useState = require$$0$1.useState(getT),
          _useState2 = _slicedToArray(_useState, 2),
          t = _useState2[0],
          setT = _useState2[1];

      var joinedNS = namespaces.join();
      var previousJoinedNS = usePrevious(joinedNS);
      var isMounted = require$$0$1.useRef(true);
      require$$0$1.useEffect(function () {
        var bindI18n = i18nOptions.bindI18n,
            bindI18nStore = i18nOptions.bindI18nStore;
        isMounted.current = true;

        if (!ready && !useSuspense) {
          loadNamespaces(i18n, namespaces, function () {
            if (isMounted.current) setT(getT);
          });
        }

        if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
          setT(getT);
        }

        function boundReset() {
          if (isMounted.current) setT(getT);
        }

        if (bindI18n && i18n) i18n.on(bindI18n, boundReset);
        if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset);
        return function () {
          isMounted.current = false;
          if (bindI18n && i18n) bindI18n.split(' ').forEach(function (e) {
            return i18n.off(e, boundReset);
          });
          if (bindI18nStore && i18n) bindI18nStore.split(' ').forEach(function (e) {
            return i18n.store.off(e, boundReset);
          });
        };
      }, [i18n, joinedNS]);
      var isInitial = require$$0$1.useRef(true);
      require$$0$1.useEffect(function () {
        if (isMounted.current && !isInitial.current) {
          setT(getT);
        }

        isInitial.current = false;
      }, [i18n, keyPrefix]);
      var ret = [t, i18n, ready];
      ret.t = t;
      ret.i18n = i18n;
      ret.ready = ready;
      if (ready) return ret;
      if (!ready && !useSuspense) return ret;
      throw new Promise(function (resolve) {
        loadNamespaces(i18n, namespaces, function () {
          resolve();
        });
      });
    }

    function useDateFormatter() {
        var _a = useTranslation(), t = _a.t, i18n = _a.i18n;
        var format$1 = function (date, format$1) {
            return format(date, format$1);
        };
        var formatRelative = function (date, relativeDate, dateFormat, timeFormat) {
            if (timeFormat === void 0) { timeFormat = ''; }
            var locale = i18n.language === 'de' ? de$2 : en$1;
            var options = {
                weekStartsOn: 1,
                locale: __assign$6(__assign$6({}, locale), { formatRelative: function (args) {
                        switch (args) {
                            case 'yesterday':
                                return "'" + t('YESTERDAY') + "' " + timeFormat;
                            case 'today':
                                return "'" + t('TODAY') + "' " + timeFormat;
                            case 'tomorrow':
                                return "'" + t('TOMORROW') + "' " + timeFormat;
                            default:
                                return dateFormat + ' ' + timeFormat;
                        }
                    } }),
            };
            return formatRelative$2(date, relativeDate, options);
        };
        return { format: format$1, formatRelative: formatRelative };
    }

    var MessageFooter = function (_a) {
        var message = _a.message;
        var format = useDateFormatter().format;
        var user = useAppSelector(function (state) { return state.user; }).user;
        var _b = useTheme(), theme = _b.theme, themes = _b.themes;
        var date = require$$0$1.useMemo(function () {
            return format(new Date(message.ts), 'HH:mm');
        }, [message.ts]);
        var myMessage = require$$0$1.useMemo(function () {
            return (user === null || user === void 0 ? void 0 : user._id) === message.u._id;
        }, [user === null || user === void 0 ? void 0 : user._id, message.u._id]);
        var color = require$$0$1.useMemo(function () {
            return myMessage ? theme === themes.TEAL ? 'text-theme-teal-1' : 'text-sky-600' : 'text-gray-600';
        }, [theme]);
        return (React.createElement("div", { className: classNames("text-xs leading-4 font-normal pb-4 px-4 flex items-center", color) },
            date,
            myMessage ? (React.createElement(React.Fragment, null, (message === null || message === void 0 ? void 0 : message.unread) === true ? React.createElement(CheckCircleIcon, { className: "ml-1 h-4 w-4" }) : React.createElement(CheckCircleIcon$2, { className: "ml-1 h-4 w-4" }))) : null));
    };

    var css_248z$d = "";
    styleInject(css_248z$d,{"insertAt":"top"});

    var css_248z$c = "";
    styleInject(css_248z$c,{"insertAt":"top"});

    var MessageDivider = function (_a) {
        var message = _a.message;
        var formatRelative = useDateFormatter().formatRelative;
        var date = require$$0$1.useMemo(function () {
            return formatRelative(new Date(message.ts), new Date(), 'cccc, dd.MM.yyyy', '');
        }, [message.ts]);
        return (require$$0__default["default"].createElement("div", { className: 'flex mb-2 text-xs font-medium leading-5 basis-full w-100 justify-center align-middle text-gray-500' },
            require$$0__default["default"].createElement("span", null, date)));
    };

    var css_248z$b = "";
    styleInject(css_248z$b,{"insertAt":"top"});

    var css_248z$a = "";
    styleInject(css_248z$a,{"insertAt":"top"});

    var css_248z$9 = "";
    styleInject(css_248z$9,{"insertAt":"top"});

    /*!
      * PhotoSwipe Lightbox 5.3.4 - https://photoswipe.com
      * (c) 2022 Dmytro Semenov
      */
    /** @typedef {import('../photoswipe.js').Point} Point */

    /** @typedef {undefined | null | false | '' | 0} Falsy */
    /** @typedef {keyof HTMLElementTagNameMap} HTMLElementTagName */

    /**
     * @template {HTMLElementTagName | Falsy} [T="div"]
     * @template {Node | undefined} [NodeToAppendElementTo=undefined]
     * @param {string=} className
     * @param {T=} [tagName]
     * @param {NodeToAppendElementTo=} appendToEl
     * @returns {T extends HTMLElementTagName ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap['div']}
     */
    function createElement$1(className, tagName, appendToEl) {
      const el = document.createElement(tagName || 'div');
      if (className) {
        el.className = className;
      }
      if (appendToEl) {
        appendToEl.appendChild(el);
      }
      // @ts-expect-error
      return el;
    }

    /**
     * Get transform string
     *
     * @param {number} x
     * @param {number=} y
     * @param {number=} scale
     */
    function toTransformString$1(x, y, scale) {
      let propValue = 'translate3d('
        + x + 'px,' + (y || 0) + 'px'
        + ',0)';

      if (scale !== undefined) {
        propValue += ' scale3d('
          + scale + ',' + scale
          + ',1)';
      }

      return propValue;
    }

    /**
     * Apply width and height CSS properties to element
     *
     * @param {HTMLElement} el
     * @param {string | number} w
     * @param {string | number} h
     */
    function setWidthHeight$1(el, w, h) {
      el.style.width = (typeof w === 'number') ? (w + 'px') : w;
      el.style.height = (typeof h === 'number') ? (h + 'px') : h;
    }

    /** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */
    /** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */
    const LOAD_STATE$1 = {
      IDLE: 'idle',
      LOADING: 'loading',
      LOADED: 'loaded',
      ERROR: 'error',
    };


    /**
     * Check if click or keydown event was dispatched
     * with a special key or via mouse wheel.
     *
     * @param {MouseEvent | KeyboardEvent} e
     */
    function specialKeyUsed$1(e) {
      if (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
        return true;
      }
    }

    /**
     * Parse `gallery` or `children` options.
     *
     * @param {import('../photoswipe.js').ElementProvider} option
     * @param {string=} legacySelector
     * @param {HTMLElement | Document} [parent]
     * @returns HTMLElement[]
     */
    function getElementsFromOption$1(option, legacySelector, parent = document) {
      /** @type {HTMLElement[]} */
      let elements = [];

      if (option instanceof Element) {
        elements = [option];
      } else if (option instanceof NodeList || Array.isArray(option)) {
        elements = Array.from(option);
      } else {
        const selector = typeof option === 'string' ? option : legacySelector;
        if (selector) {
          elements = Array.from(parent.querySelectorAll(selector));
        }
      }

      return elements;
    }

    /**
     * Check if variable is PhotoSwipe class
     *
     * @param {any} fn
     */
    function isPswpClass(fn) {
      return typeof fn === 'function'
        && fn.prototype
        && fn.prototype.goTo;
    }

    /**
     * Check if browser is Safari
     *
     * @returns {boolean}
     */
    function isSafari$1() {
      return !!(navigator.vendor && navigator.vendor.match(/apple/i));
    }

    /** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../photoswipe.js').DataSource} DataSource */
    /** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */
    /** @typedef {import('../slide/content.js').default} ContentDefault */
    /** @typedef {import('../slide/slide.js').default} Slide */
    /** @typedef {import('../slide/slide.js').SlideData} SlideData */
    /** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */
    /** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

    /**
     * Allow adding an arbitrary props to the Content
     * https://photoswipe.com/custom-content/#using-webp-image-format
     * @typedef {ContentDefault & Record<string, any>} Content
     */
    /** @typedef {{ x?: number; y?: number }} Point */

    /**
     * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
     *
     *
     * https://photoswipe.com/adding-ui-elements/
     *
     * @prop {undefined} uiRegister
     * @prop {{ data: UIElementData }} uiElementCreate
     *
     *
     * https://photoswipe.com/events/#initialization-events
     *
     * @prop {undefined} beforeOpen
     * @prop {undefined} firstUpdate
     * @prop {undefined} initialLayout
     * @prop {undefined} change
     * @prop {undefined} afterInit
     * @prop {undefined} bindEvents
     *
     *
     * https://photoswipe.com/events/#opening-or-closing-transition-events
     *
     * @prop {undefined} openingAnimationStart
     * @prop {undefined} openingAnimationEnd
     * @prop {undefined} closingAnimationStart
     * @prop {undefined} closingAnimationEnd
     *
     *
     * https://photoswipe.com/events/#closing-events
     *
     * @prop {undefined} close
     * @prop {undefined} destroy
     *
     *
     * https://photoswipe.com/events/#pointer-and-gesture-events
     *
     * @prop {{ originalEvent: PointerEvent }} pointerDown
     * @prop {{ originalEvent: PointerEvent }} pointerMove
     * @prop {{ originalEvent: PointerEvent }} pointerUp
     * @prop {{ bgOpacity: number }} pinchClose can be default prevented
     * @prop {{ panY: number }} verticalDrag can be default prevented
     *
     *
     * https://photoswipe.com/events/#slide-content-events
     *
     * @prop {{ content: Content }} contentInit
     * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
     * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
     * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
     * @prop {{ content: Content; slide: Slide }} loadError
     * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
     * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
     * @prop {{ content: Content }} contentLazyLoad can be default prevented
     * @prop {{ content: Content }} contentAppend can be default prevented
     * @prop {{ content: Content }} contentActivate can be default prevented
     * @prop {{ content: Content }} contentDeactivate can be default prevented
     * @prop {{ content: Content }} contentRemove can be default prevented
     * @prop {{ content: Content }} contentDestroy can be default prevented
     *
     *
     * undocumented
     *
     * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
     * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
     * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
     * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
     *
     * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
     * @prop {{ x: number; dragging: boolean }} moveMainScroll
     * @prop {{ slide: Slide }} firstZoomPan
     * @prop {{ slide: Slide, data: SlideData, index: number }} gettingData
     * @prop {undefined} beforeResize
     * @prop {undefined} resize
     * @prop {undefined} viewportSize
     * @prop {undefined} updateScrollOffset
     * @prop {{ slide: Slide }} slideInit
     * @prop {{ slide: Slide }} afterSetContent
     * @prop {{ slide: Slide }} slideLoad
     * @prop {{ slide: Slide }} appendHeavy can be default prevented
     * @prop {{ slide: Slide }} appendHeavyContent
     * @prop {{ slide: Slide }} slideActivate
     * @prop {{ slide: Slide }} slideDeactivate
     * @prop {{ slide: Slide }} slideDestroy
     * @prop {{ destZoomLevel: number, centerPoint: Point, transitionDuration: number | false }} beforeZoomTo
     * @prop {{ slide: Slide }} zoomPanUpdate
     * @prop {{ slide: Slide }} initialZoomPan
     * @prop {{ slide: Slide }} calcSlideSize
     * @prop {undefined} resolutionChanged
     * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
     * @prop {{ content: Content }} contentAppendImage can be default prevented
     * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
     * @prop {undefined} lazyLoad
     * @prop {{ slide: Slide }} calcBounds
     * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
     *
     *
     * legacy
     *
     * @prop {undefined} init
     * @prop {undefined} initialZoomIn
     * @prop {undefined} initialZoomOut
     * @prop {undefined} initialZoomInEnd
     * @prop {undefined} initialZoomOutEnd
     * @prop {{ dataSource: DataSource, numItems: number }} numItems
     * @prop {{ itemData: SlideData; index: number }} itemData
     * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
     */

    /**
     * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
     *
     * @prop {(numItems: number, dataSource: DataSource) => number} numItems
     * Modify the total amount of slides. Example on Data sources page.
     * https://photoswipe.com/filters/#numitems
     *
     * @prop {(itemData: SlideData, index: number) => SlideData} itemData
     * Modify slide item data. Example on Data sources page.
     * https://photoswipe.com/filters/#itemdata
     *
     * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
     * Modify item data when it's parsed from DOM element. Example on Data sources page.
     * https://photoswipe.com/filters/#domitemdata
     *
     * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
     * Modify clicked gallery item index.
     * https://photoswipe.com/filters/#clickedindex
     *
     * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
     * Modify placeholder image source.
     * https://photoswipe.com/filters/#placeholdersrc
     *
     * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
     * Modify if the content is currently loading.
     * https://photoswipe.com/filters/#iscontentloading
     *
     * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
     * Modify if the content can be zoomed.
     * https://photoswipe.com/filters/#iscontentzoomable
     *
     * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
     * Modify if the placeholder should be used for the content.
     * https://photoswipe.com/filters/#usecontentplaceholder
     *
     * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
     * Modify if the placeholder should be kept after the content is loaded.
     * https://photoswipe.com/filters/#iskeepingplaceholder
     *
     *
     * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
     * Modify an element when the content has error state (for example, if image cannot be loaded).
     * https://photoswipe.com/filters/#contenterrorelement
     *
     * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
     * Modify a UI element that's being created.
     * https://photoswipe.com/filters/#uielement
     *
     * @prop {(thumbnail: HTMLElement, itemData: SlideData, index: number) => HTMLElement} thumbEl
     * Modify the thubmnail element from which opening zoom animation starts or ends.
     * https://photoswipe.com/filters/#thumbel
     *
     * @prop {(thumbBounds: Bounds, itemData: SlideData, index: number) => Bounds} thumbBounds
     * Modify the thubmnail bounds from which opening zoom animation starts or ends.
     * https://photoswipe.com/filters/#thumbbounds
     *
     * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
     *
     */

    /**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter<T>
     */

    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
     */

    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @typedef {(event: AugmentedEvent<T>) => void} EventCallback<T>
     */

    /**
     * Base PhotoSwipe event object
     *
     * @template {keyof PhotoSwipeEventsMap} T
     */
    class PhotoSwipeEvent$1 {
      /**
       * @param {T} type
       * @param {PhotoSwipeEventsMap[T]} [details]
       */
      constructor(type, details) {
        this.type = type;
        if (details) {
          Object.assign(this, details);
        }
      }

      preventDefault() {
        this.defaultPrevented = true;
      }
    }

    /**
     * PhotoSwipe base class that can listen and dispatch for events.
     * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
     */
    class Eventable$1 {
      constructor() {
        /**
         * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
         */
        this._listeners = {};

        /**
         * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
         */
        this._filters = {};

        /** @type {PhotoSwipe=} */
        this.pswp = undefined;

        /** @type {PhotoSwipeOptions} */
        this.options = undefined;
      }

      /**
       * @template {keyof PhotoSwipeFiltersMap} T
       * @param {T} name
       * @param {PhotoSwipeFiltersMap[T]} fn
       * @param {number} priority
       */
      addFilter(name, fn, priority = 100) {
        if (!this._filters[name]) {
          this._filters[name] = [];
        }

        this._filters[name].push({ fn, priority });
        this._filters[name].sort((f1, f2) => f1.priority - f2.priority);

        if (this.pswp) {
          this.pswp.addFilter(name, fn, priority);
        }
      }

      /**
       * @template {keyof PhotoSwipeFiltersMap} T
       * @param {T} name
       * @param {PhotoSwipeFiltersMap[T]} fn
       */
      removeFilter(name, fn) {
        if (this._filters[name]) {
          // @ts-expect-error
          this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));
        }

        if (this.pswp) {
          this.pswp.removeFilter(name, fn);
        }
      }

      /**
       * @template {keyof PhotoSwipeFiltersMap} T
       * @param {T} name
       * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
       * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
       */
      applyFilters(name, ...args) {
        if (this._filters[name]) {
          this._filters[name].forEach((filter) => {
            // @ts-expect-error
            args[0] = filter.fn.apply(this, args);
          });
        }
        return args[0];
      }

      /**
       * @template {keyof PhotoSwipeEventsMap} T
       * @param {T} name
       * @param {EventCallback<T>} fn
       */
      on(name, fn) {
        if (!this._listeners[name]) {
          this._listeners[name] = [];
        }
        this._listeners[name].push(fn);

        // When binding events to lightbox,
        // also bind events to PhotoSwipe Core,
        // if it's open.
        if (this.pswp) {
          this.pswp.on(name, fn);
        }
      }

      /**
       * @template {keyof PhotoSwipeEventsMap} T
       * @param {T} name
       * @param {EventCallback<T>} fn
       */
      off(name, fn) {
        if (this._listeners[name]) {
          // @ts-expect-error
          this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));
        }

        if (this.pswp) {
          this.pswp.off(name, fn);
        }
      }

      /**
       * @template {keyof PhotoSwipeEventsMap} T
       * @param {T} name
       * @param {PhotoSwipeEventsMap[T]} [details]
       * @returns {AugmentedEvent<T>}
       */
      dispatch(name, details) {
        if (this.pswp) {
          return this.pswp.dispatch(name, details);
        }

        const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent$1(name, details));

        if (!this._listeners) {
          return event;
        }

        if (this._listeners[name]) {
          this._listeners[name].forEach((listener) => {
            listener.call(this, event);
          });
        }

        return event;
      }
    }

    class Placeholder$1 {
      /**
       * @param {string | false} imageSrc
       * @param {HTMLElement} container
       */
      constructor(imageSrc, container) {
        // Create placeholder
        // (stretched thumbnail or simple div behind the main image)
        this.element = createElement$1(
          'pswp__img pswp__img--placeholder',
          imageSrc ? 'img' : '',
          container
        );

        if (imageSrc) {
          /** @type {HTMLImageElement} */
          (this.element).decoding = 'async';
          /** @type {HTMLImageElement} */
          (this.element).alt = '';
          /** @type {HTMLImageElement} */
          (this.element).src = imageSrc;
          this.element.setAttribute('role', 'presentation');
        }

        this.element.setAttribute('aria-hidden', 'true');
      }

      /**
       * @param {number} width
       * @param {number} height
       */
      setDisplayedSize(width, height) {
        if (!this.element) {
          return;
        }

        if (this.element.tagName === 'IMG') {
          // Use transform scale() to modify img placeholder size
          // (instead of changing width/height directly).
          // This helps with performance, specifically in iOS15 Safari.
          setWidthHeight$1(this.element, 250, 'auto');
          this.element.style.transformOrigin = '0 0';
          this.element.style.transform = toTransformString$1(0, 0, width / 250);
        } else {
          setWidthHeight$1(this.element, width, height);
        }
      }

      destroy() {
        if (this.element.parentNode) {
          this.element.remove();
        }
        this.element = null;
      }
    }

    /** @typedef {import('./slide.js').default} Slide */
    /** @typedef {import('./slide.js').SlideData} SlideData */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../util/util.js').LoadState} LoadState */

    class Content$1 {
      /**
       * @param {SlideData} itemData Slide data
       * @param {PhotoSwipe} instance PhotoSwipe or PhotoSwipeLightbox instance
       * @param {number} index
       */
      constructor(itemData, instance, index) {
        this.instance = instance;
        this.data = itemData;
        this.index = index;

        /** @type {HTMLImageElement | HTMLDivElement} */
        this.element = undefined;

        this.displayedImageWidth = 0;
        this.displayedImageHeight = 0;

        this.width = Number(this.data.w) || Number(this.data.width) || 0;
        this.height = Number(this.data.h) || Number(this.data.height) || 0;

        this.isAttached = false;
        this.hasSlide = false;
        /** @type {LoadState} */
        this.state = LOAD_STATE$1.IDLE;

        if (this.data.type) {
          this.type = this.data.type;
        } else if (this.data.src) {
          this.type = 'image';
        } else {
          this.type = 'html';
        }

        this.instance.dispatch('contentInit', { content: this });
      }

      removePlaceholder() {
        if (this.placeholder && !this.keepPlaceholder()) {
          // With delay, as image might be loaded, but not rendered
          setTimeout(() => {
            if (this.placeholder) {
              this.placeholder.destroy();
              this.placeholder = null;
            }
          }, 1000);
        }
      }

      /**
       * Preload content
       *
       * @param {boolean=} isLazy
       * @param {boolean=} reload
       */
      load(isLazy, reload) {
        if (this.slide && this.usePlaceholder()) {
          if (!this.placeholder) {
            const placeholderSrc = this.instance.applyFilters(
              'placeholderSrc',
              // use  image-based placeholder only for the first slide,
              // as rendering (even small stretched thumbnail) is an expensive operation
              (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,
              this
            );
            this.placeholder = new Placeholder$1(
              placeholderSrc,
              this.slide.container
            );
          } else {
            const placeholderEl = this.placeholder.element;
            // Add placeholder to DOM if it was already created
            if (placeholderEl && !placeholderEl.parentElement) {
              this.slide.container.prepend(placeholderEl);
            }
          }
        }

        if (this.element && !reload) {
          return;
        }

        if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {
          return;
        }

        if (this.isImageContent()) {
          this.element = createElement$1('pswp__img', 'img');
          // Start loading only after width is defined, as sizes might depend on it.
          // Due to Safari feature, we must define sizes before srcset.
          if (this.displayedImageWidth) {
            this.loadImage(isLazy);
          }
        } else {
          this.element = createElement$1('pswp__content');
          this.element.innerHTML = this.data.html || '';
        }

        if (reload && this.slide) {
          this.slide.updateContentSize(true);
        }
      }

      /**
       * Preload image
       *
       * @param {boolean} isLazy
       */
      loadImage(isLazy) {
        const imageElement = /** @type HTMLImageElement */ (this.element);

        if (this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {
          return;
        }

        this.updateSrcsetSizes();

        if (this.data.srcset) {
          imageElement.srcset = this.data.srcset;
        }

        imageElement.src = this.data.src;

        imageElement.alt = this.data.alt || '';

        this.state = LOAD_STATE$1.LOADING;

        if (imageElement.complete) {
          this.onLoaded();
        } else {
          imageElement.onload = () => {
            this.onLoaded();
          };

          imageElement.onerror = () => {
            this.onError();
          };
        }
      }

      /**
       * Assign slide to content
       *
       * @param {Slide} slide
       */
      setSlide(slide) {
        this.slide = slide;
        this.hasSlide = true;
        this.instance = slide.pswp;

        // todo: do we need to unset slide?
      }

      /**
       * Content load success handler
       */
      onLoaded() {
        this.state = LOAD_STATE$1.LOADED;

        if (this.slide) {
          this.instance.dispatch('loadComplete', { slide: this.slide, content: this });

          // if content is reloaded
          if (this.slide.isActive
              && this.slide.heavyAppended
              && !this.element.parentNode) {
            this.append();
            this.slide.updateContentSize(true);
          }

          if (this.state === LOAD_STATE$1.LOADED || this.state === LOAD_STATE$1.ERROR) {
            this.removePlaceholder();
          }
        }
      }

      /**
       * Content load error handler
       */
      onError() {
        this.state = LOAD_STATE$1.ERROR;

        if (this.slide) {
          this.displayError();
          this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });
          this.instance.dispatch('loadError', { slide: this.slide, content: this });
        }
      }

      /**
       * @returns {Boolean} If the content is currently loading
       */
      isLoading() {
        return this.instance.applyFilters(
          'isContentLoading',
          this.state === LOAD_STATE$1.LOADING,
          this
        );
      }

      isError() {
        return this.state === LOAD_STATE$1.ERROR;
      }

      /**
       * @returns {boolean} If the content is image
       */
      isImageContent() {
        return this.type === 'image';
      }

      /**
       * Update content size
       *
       * @param {Number} width
       * @param {Number} height
       */
      setDisplayedSize(width, height) {
        if (!this.element) {
          return;
        }

        if (this.placeholder) {
          this.placeholder.setDisplayedSize(width, height);
        }

        // eslint-disable-next-line max-len
        if (this.instance.dispatch('contentResize', { content: this, width, height }).defaultPrevented) {
          return;
        }

        setWidthHeight$1(this.element, width, height);

        if (this.isImageContent() && !this.isError()) {
          const isInitialSizeUpdate = (!this.displayedImageWidth && width);

          this.displayedImageWidth = width;
          this.displayedImageHeight = height;

          if (isInitialSizeUpdate) {
            this.loadImage(false);
          } else {
            this.updateSrcsetSizes();
          }

          if (this.slide) {
            // eslint-disable-next-line max-len
            this.instance.dispatch('imageSizeChange', { slide: this.slide, width, height, content: this });
          }
        }
      }

      /**
       * @returns {boolean} If the content can be zoomed
       */
      isZoomable() {
        return this.instance.applyFilters(
          'isContentZoomable',
          this.isImageContent() && (this.state !== LOAD_STATE$1.ERROR),
          this
        );
      }

      /**
       * Update image srcset sizes attribute based on width and height
       */
      updateSrcsetSizes() {
        // Handle srcset sizes attribute.
        //
        // Never lower quality, if it was increased previously.
        // Chrome does this automatically, Firefox and Safari do not,
        // so we store largest used size in dataset.
        // Handle srcset sizes attribute.
        //
        // Never lower quality, if it was increased previously.
        // Chrome does this automatically, Firefox and Safari do not,
        // so we store largest used size in dataset.
        if (this.data.srcset) {
          const image = /** @type HTMLImageElement */ (this.element);
          const sizesWidth = this.instance.applyFilters(
            'srcsetSizesWidth',
            this.displayedImageWidth,
            this
          );

          if (!image.dataset.largestUsedSize
              || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {
            image.sizes = sizesWidth + 'px';
            image.dataset.largestUsedSize = String(sizesWidth);
          }
        }
      }

      /**
       * @returns {boolean} If content should use a placeholder (from msrc by default)
       */
      usePlaceholder() {
        return this.instance.applyFilters(
          'useContentPlaceholder',
          this.isImageContent(),
          this
        );
      }

      /**
       * Preload content with lazy-loading param
       */
      lazyLoad() {
        if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {
          return;
        }

        this.load(true);
      }

      /**
       * @returns {boolean} If placeholder should be kept after content is loaded
       */
      keepPlaceholder() {
        return this.instance.applyFilters(
          'isKeepingPlaceholder',
          this.isLoading(),
          this
        );
      }

      /**
       * Destroy the content
       */
      destroy() {
        this.hasSlide = false;
        this.slide = null;

        if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {
          return;
        }

        this.remove();

        if (this.placeholder) {
          this.placeholder.destroy();
          this.placeholder = null;
        }

        if (this.isImageContent() && this.element) {
          this.element.onload = null;
          this.element.onerror = null;
          this.element = null;
        }
      }

      /**
       * Display error message
       */
      displayError() {
        if (this.slide) {
          /** @type {HTMLElement} */
          let errorMsgEl = createElement$1('pswp__error-msg');
          errorMsgEl.innerText = this.instance.options.errorMsg;
          errorMsgEl = this.instance.applyFilters(
            'contentErrorElement',
            errorMsgEl,
            this
          );
          this.element = createElement$1('pswp__content pswp__error-msg-container');
          this.element.appendChild(errorMsgEl);
          this.slide.container.innerText = '';
          this.slide.container.appendChild(this.element);
          this.slide.updateContentSize(true);
          this.removePlaceholder();
        }
      }

      /**
       * Append the content
       */
      append() {
        if (this.isAttached) {
          return;
        }

        this.isAttached = true;

        if (this.state === LOAD_STATE$1.ERROR) {
          this.displayError();
          return;
        }

        if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {
          return;
        }

        const supportsDecode = ('decode' in this.element);

        if (this.isImageContent()) {
          // Use decode() on nearby slides
          //
          // Nearby slide images are in DOM and not hidden via display:none.
          // However, they are placed offscreen (to the left and right side).
          //
          // Some browsers do not composite the image until it's actually visible,
          // using decode() helps.
          //
          // You might ask "why dont you just decode() and then append all images",
          // that's because I want to show image before it's fully loaded,
          // as browser can render parts of image while it is loading.
          // We do not do this in Safari due to partial loading bug.
          if (supportsDecode && this.slide && (!this.slide.isActive || isSafari$1())) {
            this.isDecoding = true;
            // purposefully using finally instead of then,
            // as if srcset sizes changes dynamically - it may cause decode error
            /** @type {HTMLImageElement} */
            (this.element).decode().catch(() => {}).finally(() => {
              this.isDecoding = false;
              this.appendImage();
            });
          } else {
            this.appendImage();
          }
        } else if (this.element && !this.element.parentNode) {
          this.slide.container.appendChild(this.element);
        }
      }

      /**
       * Activate the slide,
       * active slide is generally the current one,
       * meaning the user can see it.
       */
      activate() {
        if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented) {
          return;
        }

        if (this.slide) {
          if (this.isImageContent() && this.isDecoding && !isSafari$1()) {
            // add image to slide when it becomes active,
            // even if it's not finished decoding
            this.appendImage();
          } else if (this.isError()) {
            this.load(false, true); // try to reload
          }

          if (this.slide.holderElement) {
            this.slide.holderElement.setAttribute('aria-hidden', 'false');
          }
        }
      }

      /**
       * Deactivate the content
       */
      deactivate() {
        this.instance.dispatch('contentDeactivate', { content: this });
        if (this.slide && this.slide.holderElement) {
          this.slide.holderElement.setAttribute('aria-hidden', 'true');
        }
      }


      /**
       * Remove the content from DOM
       */
      remove() {
        this.isAttached = false;

        if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {
          return;
        }

        if (this.element && this.element.parentNode) {
          this.element.remove();
        }

        if (this.placeholder && this.placeholder.element) {
          this.placeholder.element.remove();
        }
      }

      /**
       * Append the image content to slide container
       */
      appendImage() {
        if (!this.isAttached) {
          return;
        }

        if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {
          return;
        }

        // ensure that element exists and is not already appended
        if (this.slide && this.element && !this.element.parentNode) {
          this.slide.container.appendChild(this.element);
        }

        if (this.state === LOAD_STATE$1.LOADED || this.state === LOAD_STATE$1.ERROR) {
          this.removePlaceholder();
        }
      }
    }

    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../slide/slide.js').SlideData} SlideData */

    /**
     * @param {PhotoSwipeOptions} options
     * @param {PhotoSwipe} pswp
     */
    function getViewportSize$1(options, pswp) {
      if (options.getViewportSizeFn) {
        const newViewportSize = options.getViewportSizeFn(options, pswp);
        if (newViewportSize) {
          return newViewportSize;
        }
      }

      return {
        x: document.documentElement.clientWidth,

        // TODO: height on mobile is very incosistent due to toolbar
        // find a way to improve this
        //
        // document.documentElement.clientHeight - doesn't seem to work well
        y: window.innerHeight
      };
    }

    /**
     * Parses padding option.
     * Supported formats:
     *
     * // Object
     * padding: {
     *  top: 0,
     *  bottom: 0,
     *  left: 0,
     *  right: 0
     * }
     *
     * // A function that returns the object
     * paddingFn: (viewportSize, itemData, index) => {
     *  return {
     *    top: 0,
     *    bottom: 0,
     *    left: 0,
     *    right: 0
     *  };
     * }
     *
     * // Legacy variant
     * paddingLeft: 0,
     * paddingRight: 0,
     * paddingTop: 0,
     * paddingBottom: 0,
     *
     * @param {'left' | 'top' | 'bottom' | 'right'} prop
     * @param {PhotoSwipeOptions} options PhotoSwipe options
     * @param {{ x?: number; y?: number }} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
     * @param {SlideData} itemData Data about the slide
     * @param {number} index Slide index
     * @returns {number}
     */
    function parsePaddingOption$1(prop, options, viewportSize, itemData, index) {
      /** @type {number} */
      let paddingValue;

      if (options.paddingFn) {
        paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
      } else if (options.padding) {
        paddingValue = options.padding[prop];
      } else {
        const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);
        // @ts-expect-error
        if (options[legacyPropName]) {
          // @ts-expect-error
          paddingValue = options[legacyPropName];
        }
      }

      return paddingValue || 0;
    }

    /**
     * @param {PhotoSwipeOptions} options
     * @param {{ x?: number; y?: number }} viewportSize
     * @param {SlideData} itemData
     * @param {number} index
     */
    function getPanAreaSize$1(options, viewportSize, itemData, index) {
      return {
        x: viewportSize.x
          - parsePaddingOption$1('left', options, viewportSize, itemData, index)
          - parsePaddingOption$1('right', options, viewportSize, itemData, index),
        y: viewportSize.y
          - parsePaddingOption$1('top', options, viewportSize, itemData, index)
          - parsePaddingOption$1('bottom', options, viewportSize, itemData, index)
      };
    }

    const MAX_IMAGE_WIDTH$1 = 4000;

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../slide/slide.js').SlideData} SlideData */

    /** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

    /**
     * Calculates zoom levels for specific slide.
     * Depends on viewport size and image size.
     */
    class ZoomLevel$1 {
      /**
       * @param {PhotoSwipeOptions} options PhotoSwipe options
       * @param {SlideData} itemData Slide data
       * @param {number} index Slide index
       * @param {PhotoSwipe=} pswp PhotoSwipe instance, can be undefined if not initialized yet
       */
      constructor(options, itemData, index, pswp) {
        this.pswp = pswp;
        this.options = options;
        this.itemData = itemData;
        this.index = index;
      }

      /**
       * Calculate initial, secondary and maximum zoom level for the specified slide.
       *
       * It should be called when either image or viewport size changes.
       *
       * @param {number} maxWidth
       * @param {number} maxHeight
       * @param {{ x?: number; y?: number }} panAreaSize
       */
      update(maxWidth, maxHeight, panAreaSize) {
        this.elementSize = {
          x: maxWidth,
          y: maxHeight
        };

        this.panAreaSize = panAreaSize;

        const hRatio = this.panAreaSize.x / this.elementSize.x;
        const vRatio = this.panAreaSize.y / this.elementSize.y;

        this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
        this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);

        // zoom.vFill defines zoom level of the image
        // when it has 100% of viewport vertical space (height)
        this.vFill = Math.min(1, vRatio);

        this.initial = this._getInitial();
        this.secondary = this._getSecondary();
        this.max = Math.max(
          this.initial,
          this.secondary,
          this._getMax()
        );

        this.min = Math.min(
          this.fit,
          this.initial,
          this.secondary
        );

        if (this.pswp) {
          this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });
        }
      }

      /**
       * Parses user-defined zoom option.
       *
       * @private
       * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
       */
      _parseZoomLevelOption(optionPrefix) {
        // eslint-disable-next-line max-len
        const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (optionPrefix + 'ZoomLevel');
        const optionValue = this.options[optionName];

        if (!optionValue) {
          return;
        }

        if (typeof optionValue === 'function') {
          return optionValue(this);
        }

        if (optionValue === 'fill') {
          return this.fill;
        }

        if (optionValue === 'fit') {
          return this.fit;
        }

        return Number(optionValue);
      }

      /**
       * Get zoom level to which image will be zoomed after double-tap gesture,
       * or when user clicks on zoom icon,
       * or mouse-click on image itself.
       * If you return 1 image will be zoomed to its original size.
       *
       * @private
       * @return {number}
       */
      _getSecondary() {
        let currZoomLevel = this._parseZoomLevelOption('secondary');

        if (currZoomLevel) {
          return currZoomLevel;
        }

        // 3x of "fit" state, but not larger than original
        currZoomLevel = Math.min(1, this.fit * 3);

        if (currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH$1) {
          currZoomLevel = MAX_IMAGE_WIDTH$1 / this.elementSize.x;
        }

        return currZoomLevel;
      }

      /**
       * Get initial image zoom level.
       *
       * @private
       * @return {number}
       */
      _getInitial() {
        return this._parseZoomLevelOption('initial') || this.fit;
      }

      /**
       * Maximum zoom level when user zooms
       * via zoom/pinch gesture,
       * via cmd/ctrl-wheel or via trackpad.
       *
       * @private
       * @return {number}
       */
      _getMax() {
        const currZoomLevel = this._parseZoomLevelOption('max');

        if (currZoomLevel) {
          return currZoomLevel;
        }

        // max zoom level is x4 from "fit state",
        // used for zoom gesture and ctrl/trackpad zoom
        return Math.max(1, this.fit * 4);
      }
    }

    /**
     * Lazy-load an image
     * This function is used both by Lightbox and PhotoSwipe core,
     * thus it can be called before dialog is opened.
     *
     * @param {SlideData} itemData Data about the slide
     * @param {PhotoSwipe | PhotoSwipeLightbox | PhotoSwipeBase} instance PhotoSwipe instance
     * @param {number} index
     * @returns Image that is being decoded or false.
     */
    function lazyLoadData$1(itemData, instance, index) {
      // src/slide/content/content.js
      const content = instance.createContentFromData(itemData, index);

      if (!content || !content.lazyLoad) {
        return;
      }

      const { options } = instance;

      // We need to know dimensions of the image to preload it,
      // as it might use srcset and we need to define sizes
      // @ts-expect-error should provide pswp instance?
      const viewportSize = instance.viewportSize || getViewportSize$1(options, instance);
      const panAreaSize = getPanAreaSize$1(options, viewportSize, itemData, index);

      const zoomLevel = new ZoomLevel$1(options, itemData, -1);
      zoomLevel.update(content.width, content.height, panAreaSize);

      content.lazyLoad();
      content.setDisplayedSize(
        Math.ceil(content.width * zoomLevel.initial),
        Math.ceil(content.height * zoomLevel.initial)
      );

      return content;
    }


    /**
     * Lazy-loads specific slide.
     * This function is used both by Lightbox and PhotoSwipe core,
     * thus it can be called before dialog is opened.
     *
     * By default it loads image based on viewport size and initial zoom level.
     *
     * @param {number} index Slide index
     * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
     */
    function lazyLoadSlide$1(index, instance) {
      const itemData = instance.getItemData(index);

      if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {
        return;
      }

      return lazyLoadData$1(itemData, instance, index);
    }

    /** @typedef {import("../photoswipe.js").default} PhotoSwipe */
    /** @typedef {import("../photoswipe.js").PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import("../slide/slide.js").SlideData} SlideData */

    /**
     * PhotoSwipe base class that can retrieve data about every slide.
     * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
     */
    class PhotoSwipeBase$1 extends Eventable$1 {
      /**
       * Get total number of slides
       *
       * @returns {number}
       */
      getNumItems() {
        let numItems;
        const { dataSource } = this.options;
        if (!dataSource) {
          numItems = 0;
        } else if ('length' in dataSource) {
          // may be an array or just object with length property
          numItems = dataSource.length;
        } else if ('gallery' in dataSource) {
          // query DOM elements
          if (!dataSource.items) {
            dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
          }

          if (dataSource.items) {
            numItems = dataSource.items.length;
          }
        }

        // legacy event, before filters were introduced
        const event = this.dispatch('numItems', {
          dataSource,
          numItems
        });
        return this.applyFilters('numItems', event.numItems, dataSource);
      }

      /**
       * @param {SlideData} slideData
       * @param {number} index
       */
      createContentFromData(slideData, index) {
        // @ts-expect-error
        return new Content$1(slideData, this, index);
      }

      /**
       * Get item data by index.
       *
       * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
       * For example, it may contain properties like
       * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
       *
       * @param {number} index
       */
      getItemData(index) {
        const { dataSource } = this.options;
        let dataSourceItem;
        if (Array.isArray(dataSource)) {
          // Datasource is an array of elements
          dataSourceItem = dataSource[index];
        } else if (dataSource && dataSource.gallery) {
          // dataSource has gallery property,
          // thus it was created by Lightbox, based on
          // gallery and children options

          // query DOM elements
          if (!dataSource.items) {
            dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
          }

          dataSourceItem = dataSource.items[index];
        }

        let itemData = dataSourceItem;

        if (itemData instanceof Element) {
          itemData = this._domElementToItemData(itemData);
        }

        // Dispatching the itemData event,
        // it's a legacy verion before filters were introduced
        const event = this.dispatch('itemData', {
          itemData: itemData || {},
          index
        });

        return this.applyFilters('itemData', event.itemData, index);
      }

      /**
       * Get array of gallery DOM elements,
       * based on childSelector and gallery element.
       *
       * @param {HTMLElement} galleryElement
       */
      _getGalleryDOMElements(galleryElement) {
        if (this.options.children || this.options.childSelector) {
          return getElementsFromOption$1(
            this.options.children,
            this.options.childSelector,
            galleryElement
          ) || [];
        }

        return [galleryElement];
      }

      /**
       * Converts DOM element to item data object.
       *
       * @param {HTMLElement} element DOM element
       */
      // eslint-disable-next-line class-methods-use-this
      _domElementToItemData(element) {
        /** @type {SlideData} */
        const itemData = {
          element
        };

        // eslint-disable-next-line max-len
        const linkEl = /** @type {HTMLAnchorElement} */ (element.tagName === 'A' ? element : element.querySelector('a'));

        if (linkEl) {
          // src comes from data-pswp-src attribute,
          // if it's empty link href is used
          itemData.src = linkEl.dataset.pswpSrc || linkEl.href;

          if (linkEl.dataset.pswpSrcset) {
            itemData.srcset = linkEl.dataset.pswpSrcset;
          }

          itemData.width = parseInt(linkEl.dataset.pswpWidth, 10);
          itemData.height = parseInt(linkEl.dataset.pswpHeight, 10);

          // support legacy w & h properties
          itemData.w = itemData.width;
          itemData.h = itemData.height;

          if (linkEl.dataset.pswpType) {
            itemData.type = linkEl.dataset.pswpType;
          }

          const thumbnailEl = element.querySelector('img');

          if (thumbnailEl) {
            // msrc is URL to placeholder image that's displayed before large image is loaded
            // by default it's displayed only for the first slide
            itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
            itemData.alt = thumbnailEl.getAttribute('alt');
          }

          if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
            itemData.thumbCropped = true;
          }
        }

        return this.applyFilters('domItemData', itemData, element, linkEl);
      }

      /**
       * Lazy-load by slide data
       *
       * @param {SlideData} itemData Data about the slide
       * @param {number} index
       * @returns Image that is being decoded or false.
       */
      lazyLoadData(itemData, index) {
        return lazyLoadData$1(itemData, this, index);
      }
    }

    /**
     * @template T
     * @typedef {import('../types.js').Type<T>} Type<T>
     */

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../photoswipe.js').DataSource} DataSource */
    /** @typedef {import('../slide/content.js').default} Content */
    /** @typedef {import('../core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */
    /** @typedef {import('../core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */

    /**
     * @template T
     * @typedef {import('../core/eventable.js').EventCallback<T>} EventCallback<T>
     */

    /**
     * PhotoSwipe Lightbox
     *
     * - If user has unsupported browser it falls back to default browser action (just opens URL)
     * - Binds click event to links that should open PhotoSwipe
     * - parses DOM strcture for PhotoSwipe (retrieves large image URLs and sizes)
     * - Initializes PhotoSwipe
     *
     *
     * Loader options use the same object as PhotoSwipe, and supports such options:
     *
     * gallery - Element | Element[] | NodeList | string selector for the gallery element
     * children - Element | Element[] | NodeList | string selector for the gallery children
     *
     */
    class PhotoSwipeLightbox extends PhotoSwipeBase$1 {
      /**
       * @param {PhotoSwipeOptions} options
       */
      constructor(options) {
        super();
        /** @type {PhotoSwipeOptions} */
        this.options = options || {};
        this._uid = 0;
      }

      /**
       * Initialize lightbox, should be called only once.
       * It's not included in the main constructor, so you may bind events before it.
       */
      init() {
        this.onThumbnailsClick = this.onThumbnailsClick.bind(this);

        // Bind click events to each gallery
        getElementsFromOption$1(this.options.gallery, this.options.gallerySelector)
          .forEach((galleryElement) => {
            galleryElement.addEventListener('click', this.onThumbnailsClick, false);
          });
      }

      /**
       * @param {MouseEvent} e
       */
      onThumbnailsClick(e) {
        // Exit and allow default browser action if:
        if (specialKeyUsed$1(e) // ... if clicked with a special key (ctrl/cmd...)
            || window.pswp // ... if PhotoSwipe is already open
            || window.navigator.onLine === false) { // ... if offline
          return;
        }

        // If both clientX and clientY are 0 or not defined,
        // the event is likely triggered by keyboard,
        // so we do not pass the initialPoint
        //
        // Note that some screen readers emulate the mouse position,
        // so it's not ideal way to detect them.
        //
        let initialPoint = { x: e.clientX, y: e.clientY };

        if (!initialPoint.x && !initialPoint.y) {
          initialPoint = null;
        }

        let clickedIndex = this.getClickedIndex(e);
        clickedIndex = this.applyFilters('clickedIndex', clickedIndex, e, this);
        const dataSource = {
          gallery: /** @type {HTMLElement} */ (e.currentTarget)
        };

        if (clickedIndex >= 0) {
          e.preventDefault();
          this.loadAndOpen(clickedIndex, dataSource, initialPoint);
        }
      }

      /**
       * Get index of gallery item that was clicked.
       *
       * @param {MouseEvent} e click event
       */
      getClickedIndex(e) {
        // legacy option
        if (this.options.getClickedIndexFn) {
          return this.options.getClickedIndexFn.call(this, e);
        }

        const clickedTarget = /** @type {HTMLElement} */ (e.target);
        const childElements = getElementsFromOption$1(
          this.options.children,
          this.options.childSelector,
          /** @type {HTMLElement} */ (e.currentTarget)
        );
        const clickedChildIndex = childElements.findIndex(
          child => child === clickedTarget || child.contains(clickedTarget)
        );

        if (clickedChildIndex !== -1) {
          return clickedChildIndex;
        } else if (this.options.children || this.options.childSelector) {
          // click wasn't on a child element
          return -1;
        }

        // There is only one item (which is the gallery)
        return 0;
      }

      /**
       * Load and open PhotoSwipe
       *
       * @param {number} index
       * @param {DataSource=} dataSource
       * @param {{ x?: number; y?: number }} [initialPoint]
       */
      loadAndOpen(index, dataSource, initialPoint) {
        // Check if the gallery is already open
        if (window.pswp) {
          return false;
        }

        // set initial index
        this.options.index = index;

        // define options for PhotoSwipe constructor
        this.options.initialPointerPos = initialPoint;

        this.shouldOpen = true;
        this.preload(index, dataSource);
        return true;
      }

      /**
       * Load the main module and the slide content by index
       *
       * @param {number} index
       * @param {DataSource=} dataSource
       */
      preload(index, dataSource) {
        const { options } = this;

        if (dataSource) {
          options.dataSource = dataSource;
        }

        // Add the main module
        /** @type {Promise<Type<PhotoSwipe>>[]} */
        const promiseArray = [];

        const pswpModuleType = typeof options.pswpModule;
        if (isPswpClass(options.pswpModule)) {
          promiseArray.push(Promise.resolve(/** @type {Type<PhotoSwipe>} */ (options.pswpModule)));
        } else if (pswpModuleType === 'string') {
          throw new Error('pswpModule as string is no longer supported');
        } else if (pswpModuleType === 'function') {
          promiseArray.push(/** @type {() => Promise<Type<PhotoSwipe>>} */ (options.pswpModule)());
        } else {
          throw new Error('pswpModule is not valid');
        }

        // Add custom-defined promise, if any
        if (typeof options.openPromise === 'function') {
          // allow developers to perform some task before opening
          promiseArray.push(options.openPromise());
        }

        if (options.preloadFirstSlide !== false && index >= 0) {
          this._preloadedContent = lazyLoadSlide$1(index, this);
        }

        // Wait till all promises resolve and open PhotoSwipe
        const uid = ++this._uid;
        Promise.all(promiseArray).then((iterableModules) => {
          if (this.shouldOpen) {
            const mainModule = iterableModules[0];
            this._openPhotoswipe(mainModule, uid);
          }
        });
      }

      /**
       * @private
       * @param {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} module
       * @param {number} uid
       */
      _openPhotoswipe(module, uid) {
        // Cancel opening if UID doesn't match the current one
        // (if user clicked on another gallery item before current was loaded).
        //
        // Or if shouldOpen flag is set to false
        // (developer may modify it via public API)
        if (uid !== this._uid && this.shouldOpen) {
          return;
        }

        this.shouldOpen = false;

        // PhotoSwipe is already open
        if (window.pswp) {
          return;
        }

        /**
         * Pass data to PhotoSwipe and open init
         *
         * @type {PhotoSwipe}
         */
        const pswp = typeof module === 'object'
            ? new module.default(this.options) // eslint-disable-line
            : new module(this.options); // eslint-disable-line

        this.pswp = pswp;
        window.pswp = pswp;

        // map listeners from Lightbox to PhotoSwipe Core
        /** @type {(keyof PhotoSwipeEventsMap)[]} */
        (Object.keys(this._listeners)).forEach((name) => {
          this._listeners[name].forEach((fn) => {
            pswp.on(name, /** @type {EventCallback<typeof name>} */(fn));
          });
        });

        // same with filters
        /** @type {(keyof PhotoSwipeFiltersMap)[]} */
        (Object.keys(this._filters)).forEach((name) => {
          this._filters[name].forEach((filter) => {
            pswp.addFilter(name, filter.fn, filter.priority);
          });
        });

        if (this._preloadedContent) {
          pswp.contentLoader.addToCache(this._preloadedContent);
          this._preloadedContent = null;
        }

        pswp.on('destroy', () => {
          // clean up public variables
          this.pswp = null;
          window.pswp = null;
        });

        pswp.init();
      }

      /**
       * Unbinds all events, closes PhotoSwipe if it's open.
       */
      destroy() {
        if (this.pswp) {
          this.pswp.destroy();
        }

        this.shouldOpen = false;
        this._listeners = null;

        getElementsFromOption$1(this.options.gallery, this.options.gallerySelector)
          .forEach((galleryElement) => {
            galleryElement.removeEventListener('click', this.onThumbnailsClick, false);
          });
      }
    }

    /*!
      * PhotoSwipe 5.3.4 - https://photoswipe.com
      * (c) 2022 Dmytro Semenov
      */
    /** @typedef {import('../photoswipe.js').Point} Point */

    /** @typedef {undefined | null | false | '' | 0} Falsy */
    /** @typedef {keyof HTMLElementTagNameMap} HTMLElementTagName */

    /**
     * @template {HTMLElementTagName | Falsy} [T="div"]
     * @template {Node | undefined} [NodeToAppendElementTo=undefined]
     * @param {string=} className
     * @param {T=} [tagName]
     * @param {NodeToAppendElementTo=} appendToEl
     * @returns {T extends HTMLElementTagName ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap['div']}
     */
    function createElement(className, tagName, appendToEl) {
      const el = document.createElement(tagName || 'div');
      if (className) {
        el.className = className;
      }
      if (appendToEl) {
        appendToEl.appendChild(el);
      }
      // @ts-expect-error
      return el;
    }

    /**
     * @param {Point} p1
     * @param {Point} p2
     */
    function equalizePoints(p1, p2) {
      p1.x = p2.x;
      p1.y = p2.y;
      if (p2.id !== undefined) {
        p1.id = p2.id;
      }
      return p1;
    }

    /**
     * @param {Point} p
     */
    function roundPoint(p) {
      p.x = Math.round(p.x);
      p.y = Math.round(p.y);
    }

    /**
     * Returns distance between two points.
     *
     * @param {Point} p1
     * @param {Point} p2
     */
    function getDistanceBetween(p1, p2) {
      const x = Math.abs(p1.x - p2.x);
      const y = Math.abs(p1.y - p2.y);
      return Math.sqrt((x * x) + (y * y));
    }

    /**
     * Whether X and Y positions of points are qual
     *
     * @param {Point} p1
     * @param {Point} p2
     */
    function pointsEqual(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }

    /**
     * The float result between the min and max values.
     *
     * @param {number} val
     * @param {number} min
     * @param {number} max
     */
    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }

    /**
     * Get transform string
     *
     * @param {number} x
     * @param {number=} y
     * @param {number=} scale
     */
    function toTransformString(x, y, scale) {
      let propValue = 'translate3d('
        + x + 'px,' + (y || 0) + 'px'
        + ',0)';

      if (scale !== undefined) {
        propValue += ' scale3d('
          + scale + ',' + scale
          + ',1)';
      }

      return propValue;
    }

    /**
     * Apply transform:translate(x, y) scale(scale) to element
     *
     * @param {HTMLElement} el
     * @param {number} x
     * @param {number=} y
     * @param {number=} scale
     */
    function setTransform(el, x, y, scale) {
      el.style.transform = toTransformString(x, y, scale);
    }

    const defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';

    /**
     * Apply CSS transition to element
     *
     * @param {HTMLElement} el
     * @param {string=} prop CSS property to animate
     * @param {number=} duration in ms
     * @param {string=} ease CSS easing function
     */
    function setTransitionStyle(el, prop, duration, ease) {
      // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for "toggle state" transitions
      // out: 'cubic-bezier(0, 0, .22, 1)', // for "show" transitions
      // in: 'cubic-bezier(.4, 0, 1, 1)'// for "hide" transitions
      el.style.transition = prop
        ? (prop + ' ' + duration + 'ms ' + (ease || defaultCSSEasing))
        : 'none';
    }

    /**
     * Apply width and height CSS properties to element
     *
     * @param {HTMLElement} el
     * @param {string | number} w
     * @param {string | number} h
     */
    function setWidthHeight(el, w, h) {
      el.style.width = (typeof w === 'number') ? (w + 'px') : w;
      el.style.height = (typeof h === 'number') ? (h + 'px') : h;
    }

    /**
     * @param {HTMLElement} el
     */
    function removeTransitionStyle(el) {
      setTransitionStyle(el);
    }

    /**
     * @param {HTMLImageElement} img
     * @returns {Promise<HTMLImageElement | void>}
     */
    function decodeImage(img) {
      if ('decode' in img) {
        return img.decode().catch(() => {});
      }

      if (img.complete) {
        return Promise.resolve(img);
      }

      return new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = reject;
      });
    }

    /** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */
    /** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */
    const LOAD_STATE = {
      IDLE: 'idle',
      LOADING: 'loading',
      LOADED: 'loaded',
      ERROR: 'error',
    };


    /**
     * Check if click or keydown event was dispatched
     * with a special key or via mouse wheel.
     *
     * @param {MouseEvent | KeyboardEvent} e
     */
    function specialKeyUsed(e) {
      if (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
        return true;
      }
    }

    /**
     * Parse `gallery` or `children` options.
     *
     * @param {import('../photoswipe.js').ElementProvider} option
     * @param {string=} legacySelector
     * @param {HTMLElement | Document} [parent]
     * @returns HTMLElement[]
     */
    function getElementsFromOption(option, legacySelector, parent = document) {
      /** @type {HTMLElement[]} */
      let elements = [];

      if (option instanceof Element) {
        elements = [option];
      } else if (option instanceof NodeList || Array.isArray(option)) {
        elements = Array.from(option);
      } else {
        const selector = typeof option === 'string' ? option : legacySelector;
        if (selector) {
          elements = Array.from(parent.querySelectorAll(selector));
        }
      }

      return elements;
    }

    /**
     * Check if browser is Safari
     *
     * @returns {boolean}
     */
    function isSafari() {
      return !!(navigator.vendor && navigator.vendor.match(/apple/i));
    }

    // Detect passive event listener support
    let supportsPassive = false;
    /* eslint-disable */
    try {
      window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
        get: () => {
          supportsPassive = true;
        }
      }));
    } catch (e) {}
    /* eslint-enable */


    /**
     * @typedef {Object} PoolItem
     * @prop {HTMLElement | Window | Document} target
     * @prop {string} type
     * @prop {(e: any) => void} listener
     * @prop {boolean} passive
     */

    class DOMEvents {
      constructor() {
        /**
         * @type {PoolItem[]}
         * @private
         */
        this._pool = [];
      }

      /**
       * Adds event listeners
       *
       * @param {HTMLElement | Window | Document} target
       * @param {string} type Can be multiple, separated by space.
       * @param {(e: any) => void} listener
       * @param {boolean=} passive
       */
      add(target, type, listener, passive) {
        this._toggleListener(target, type, listener, passive);
      }

      /**
       * Removes event listeners
       *
       * @param {HTMLElement | Window | Document} target
       * @param {string} type
       * @param {(e: any) => void} listener
       * @param {boolean=} passive
       */
      remove(target, type, listener, passive) {
        this._toggleListener(target, type, listener, passive, true);
      }

      /**
       * Removes all bound events
       */
      removeAll() {
        this._pool.forEach((poolItem) => {
          this._toggleListener(
            poolItem.target,
            poolItem.type,
            poolItem.listener,
            poolItem.passive,
            true,
            true
          );
        });
        this._pool = [];
      }

      /**
       * Adds or removes event
       *
       * @param {HTMLElement | Window | Document} target
       * @param {string} type
       * @param {(e: any) => void} listener
       * @param {boolean} passive
       * @param {boolean=} unbind Whether the event should be added or removed
       * @param {boolean=} skipPool Whether events pool should be skipped
       */
      _toggleListener(target, type, listener, passive, unbind, skipPool) {
        if (!target) {
          return;
        }

        const methodName = unbind ? 'removeEventListener' : 'addEventListener';
        const types = type.split(' ');
        types.forEach((eType) => {
          if (eType) {
            // Events pool is used to easily unbind all events when PhotoSwipe is closed,
            // so developer doesn't need to do this manually
            if (!skipPool) {
              if (unbind) {
                // Remove from the events pool
                this._pool = this._pool.filter((poolItem) => {
                  return poolItem.type !== eType
                    || poolItem.listener !== listener
                    || poolItem.target !== target;
                });
              } else {
                // Add to the events pool
                this._pool.push({
                  target,
                  type: eType,
                  listener,
                  passive
                });
              }
            }


            // most PhotoSwipe events call preventDefault,
            // and we do not need browser to scroll the page
            const eventOptions = supportsPassive ? { passive: (passive || false) } : false;

            target[methodName](
              eType,
              listener,
              eventOptions
            );
          }
        });
      }
    }

    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../slide/slide.js').SlideData} SlideData */

    /**
     * @param {PhotoSwipeOptions} options
     * @param {PhotoSwipe} pswp
     */
    function getViewportSize(options, pswp) {
      if (options.getViewportSizeFn) {
        const newViewportSize = options.getViewportSizeFn(options, pswp);
        if (newViewportSize) {
          return newViewportSize;
        }
      }

      return {
        x: document.documentElement.clientWidth,

        // TODO: height on mobile is very incosistent due to toolbar
        // find a way to improve this
        //
        // document.documentElement.clientHeight - doesn't seem to work well
        y: window.innerHeight
      };
    }

    /**
     * Parses padding option.
     * Supported formats:
     *
     * // Object
     * padding: {
     *  top: 0,
     *  bottom: 0,
     *  left: 0,
     *  right: 0
     * }
     *
     * // A function that returns the object
     * paddingFn: (viewportSize, itemData, index) => {
     *  return {
     *    top: 0,
     *    bottom: 0,
     *    left: 0,
     *    right: 0
     *  };
     * }
     *
     * // Legacy variant
     * paddingLeft: 0,
     * paddingRight: 0,
     * paddingTop: 0,
     * paddingBottom: 0,
     *
     * @param {'left' | 'top' | 'bottom' | 'right'} prop
     * @param {PhotoSwipeOptions} options PhotoSwipe options
     * @param {{ x?: number; y?: number }} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
     * @param {SlideData} itemData Data about the slide
     * @param {number} index Slide index
     * @returns {number}
     */
    function parsePaddingOption(prop, options, viewportSize, itemData, index) {
      /** @type {number} */
      let paddingValue;

      if (options.paddingFn) {
        paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
      } else if (options.padding) {
        paddingValue = options.padding[prop];
      } else {
        const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);
        // @ts-expect-error
        if (options[legacyPropName]) {
          // @ts-expect-error
          paddingValue = options[legacyPropName];
        }
      }

      return paddingValue || 0;
    }

    /**
     * @param {PhotoSwipeOptions} options
     * @param {{ x?: number; y?: number }} viewportSize
     * @param {SlideData} itemData
     * @param {number} index
     */
    function getPanAreaSize(options, viewportSize, itemData, index) {
      return {
        x: viewportSize.x
          - parsePaddingOption('left', options, viewportSize, itemData, index)
          - parsePaddingOption('right', options, viewportSize, itemData, index),
        y: viewportSize.y
          - parsePaddingOption('top', options, viewportSize, itemData, index)
          - parsePaddingOption('bottom', options, viewportSize, itemData, index)
      };
    }

    /** @typedef {import('./slide.js').default} Slide */
    /** @typedef {{ x?: number; y?: number }} Point */
    /** @typedef {'x' | 'y'} Axis */

    /**
     * Calculates minimum, maximum and initial (center) bounds of a slide
     */
    class PanBounds {
      /**
       * @param {Slide} slide
       */
      constructor(slide) {
        this.slide = slide;

        this.currZoomLevel = 1;

        /** @type {Point} */
        this.center = {};
        /** @type {Point} */
        this.max = {};
        /** @type {Point} */
        this.min = {};

        this.reset();
      }

      /**
       * _getItemBounds
       *
       * @param {number} currZoomLevel
       */
      update(currZoomLevel) {
        this.currZoomLevel = currZoomLevel;

        if (!this.slide.width) {
          this.reset();
        } else {
          this._updateAxis('x');
          this._updateAxis('y');
          this.slide.pswp.dispatch('calcBounds', { slide: this.slide });
        }
      }

      /**
       * _calculateItemBoundsForAxis
       *
       * @param {Axis} axis
       */
      _updateAxis(axis) {
        const { pswp } = this.slide;
        const elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;
        const paddingProp = axis === 'x' ? 'left' : 'top';
        const padding = parsePaddingOption(
          paddingProp,
          pswp.options,
          pswp.viewportSize,
          this.slide.data,
          this.slide.index
        );

        const panAreaSize = this.slide.panAreaSize[axis];

        // Default position of element.
        // By defaul it is center of viewport:
        this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding;

        // maximum pan position
        this.max[axis] = (elSize > panAreaSize)
          ? Math.round(panAreaSize - elSize) + padding
          : this.center[axis];

        // minimum pan position
        this.min[axis] = (elSize > panAreaSize)
          ? padding
          : this.center[axis];
      }

      // _getZeroBounds
      reset() {
        this.center.x = 0;
        this.center.y = 0;
        this.max.x = 0;
        this.max.y = 0;
        this.min.x = 0;
        this.min.y = 0;
      }

      /**
       * Correct pan position if it's beyond the bounds
       *
       * @param {Axis} axis x or y
       * @param {number} panOffset
       */
      correctPan(axis, panOffset) { // checkPanBounds
        return clamp(panOffset, this.max[axis], this.min[axis]);
      }
    }

    const MAX_IMAGE_WIDTH = 4000;

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../slide/slide.js').SlideData} SlideData */

    /** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

    /**
     * Calculates zoom levels for specific slide.
     * Depends on viewport size and image size.
     */
    class ZoomLevel {
      /**
       * @param {PhotoSwipeOptions} options PhotoSwipe options
       * @param {SlideData} itemData Slide data
       * @param {number} index Slide index
       * @param {PhotoSwipe=} pswp PhotoSwipe instance, can be undefined if not initialized yet
       */
      constructor(options, itemData, index, pswp) {
        this.pswp = pswp;
        this.options = options;
        this.itemData = itemData;
        this.index = index;
      }

      /**
       * Calculate initial, secondary and maximum zoom level for the specified slide.
       *
       * It should be called when either image or viewport size changes.
       *
       * @param {number} maxWidth
       * @param {number} maxHeight
       * @param {{ x?: number; y?: number }} panAreaSize
       */
      update(maxWidth, maxHeight, panAreaSize) {
        this.elementSize = {
          x: maxWidth,
          y: maxHeight
        };

        this.panAreaSize = panAreaSize;

        const hRatio = this.panAreaSize.x / this.elementSize.x;
        const vRatio = this.panAreaSize.y / this.elementSize.y;

        this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
        this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);

        // zoom.vFill defines zoom level of the image
        // when it has 100% of viewport vertical space (height)
        this.vFill = Math.min(1, vRatio);

        this.initial = this._getInitial();
        this.secondary = this._getSecondary();
        this.max = Math.max(
          this.initial,
          this.secondary,
          this._getMax()
        );

        this.min = Math.min(
          this.fit,
          this.initial,
          this.secondary
        );

        if (this.pswp) {
          this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });
        }
      }

      /**
       * Parses user-defined zoom option.
       *
       * @private
       * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
       */
      _parseZoomLevelOption(optionPrefix) {
        // eslint-disable-next-line max-len
        const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (optionPrefix + 'ZoomLevel');
        const optionValue = this.options[optionName];

        if (!optionValue) {
          return;
        }

        if (typeof optionValue === 'function') {
          return optionValue(this);
        }

        if (optionValue === 'fill') {
          return this.fill;
        }

        if (optionValue === 'fit') {
          return this.fit;
        }

        return Number(optionValue);
      }

      /**
       * Get zoom level to which image will be zoomed after double-tap gesture,
       * or when user clicks on zoom icon,
       * or mouse-click on image itself.
       * If you return 1 image will be zoomed to its original size.
       *
       * @private
       * @return {number}
       */
      _getSecondary() {
        let currZoomLevel = this._parseZoomLevelOption('secondary');

        if (currZoomLevel) {
          return currZoomLevel;
        }

        // 3x of "fit" state, but not larger than original
        currZoomLevel = Math.min(1, this.fit * 3);

        if (currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {
          currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;
        }

        return currZoomLevel;
      }

      /**
       * Get initial image zoom level.
       *
       * @private
       * @return {number}
       */
      _getInitial() {
        return this._parseZoomLevelOption('initial') || this.fit;
      }

      /**
       * Maximum zoom level when user zooms
       * via zoom/pinch gesture,
       * via cmd/ctrl-wheel or via trackpad.
       *
       * @private
       * @return {number}
       */
      _getMax() {
        const currZoomLevel = this._parseZoomLevelOption('max');

        if (currZoomLevel) {
          return currZoomLevel;
        }

        // max zoom level is x4 from "fit state",
        // used for zoom gesture and ctrl/trackpad zoom
        return Math.max(1, this.fit * 4);
      }
    }

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */

    /**
     * Renders and allows to control a single slide
     */
    class Slide {
      /**
       * @param {SlideData} data
       * @param {number} index
       * @param {PhotoSwipe} pswp
       */
      constructor(data, index, pswp) {
        this.data = data;
        this.index = index;
        this.pswp = pswp;
        this.isActive = (index === pswp.currIndex);
        this.currentResolution = 0;
        /** @type {Point} */
        this.panAreaSize = {};

        this.isFirstSlide = (this.isActive && !pswp.opener.isOpen);

        this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);

        this.pswp.dispatch('gettingData', {
          slide: this,
          data: this.data,
          index
        });

        this.pan = {
          x: 0,
          y: 0
        };

        this.content = this.pswp.contentLoader.getContentBySlide(this);
        this.container = createElement('pswp__zoom-wrap');

        this.currZoomLevel = 1;
        /** @type {number} */
        this.width = this.content.width;
        /** @type {number} */
        this.height = this.content.height;

        this.bounds = new PanBounds(this);

        this.prevDisplayedWidth = -1;
        this.prevDisplayedHeight = -1;

        this.pswp.dispatch('slideInit', { slide: this });
      }

      /**
       * If this slide is active/current/visible
       *
       * @param {boolean} isActive
       */
      setIsActive(isActive) {
        if (isActive && !this.isActive) {
          // slide just became active
          this.activate();
        } else if (!isActive && this.isActive) {
          // slide just became non-active
          this.deactivate();
        }
      }

      /**
       * Appends slide content to DOM
       *
       * @param {HTMLElement} holderElement
       */
      append(holderElement) {
        this.holderElement = holderElement;

        this.container.style.transformOrigin = '0 0';

        // Slide appended to DOM
        if (!this.data) {
          return;
        }

        this.calculateSize();

        this.load();
        this.updateContentSize();
        this.appendHeavy();

        this.holderElement.appendChild(this.container);

        this.zoomAndPanToInitial();

        this.pswp.dispatch('firstZoomPan', { slide: this });

        this.applyCurrentZoomPan();

        this.pswp.dispatch('afterSetContent', { slide: this });

        if (this.isActive) {
          this.activate();
        }
      }

      load() {
        this.content.load();
        this.pswp.dispatch('slideLoad', { slide: this });
      }

      /**
       * Append "heavy" DOM elements
       *
       * This may depend on a type of slide,
       * but generally these are large images.
       */
      appendHeavy() {
        const { pswp } = this;
        const appendHeavyNearby = true; // todo

        // Avoid appending heavy elements during animations
        if (this.heavyAppended
            || !pswp.opener.isOpen
            || pswp.mainScroll.isShifted()
            || (!this.isActive && !appendHeavyNearby)) {
          return;
        }

        if (this.pswp.dispatch('appendHeavy', { slide: this }).defaultPrevented) {
          return;
        }

        this.heavyAppended = true;

        this.content.append();

        this.pswp.dispatch('appendHeavyContent', { slide: this });
      }

      /**
       * Triggered when this slide is active (selected).
       *
       * If it's part of opening/closing transition -
       * activate() will trigger after the transition is ended.
       */
      activate() {
        this.isActive = true;
        this.appendHeavy();
        this.content.activate();
        this.pswp.dispatch('slideActivate', { slide: this });
      }

      /**
       * Triggered when this slide becomes inactive.
       *
       * Slide can become inactive only after it was active.
       */
      deactivate() {
        this.isActive = false;
        this.content.deactivate();

        if (this.currZoomLevel !== this.zoomLevels.initial) {
          // allow filtering
          this.calculateSize();
        }

        // reset zoom level
        this.currentResolution = 0;
        this.zoomAndPanToInitial();
        this.applyCurrentZoomPan();
        this.updateContentSize();

        this.pswp.dispatch('slideDeactivate', { slide: this });
      }

      /**
       * The slide should destroy itself, it will never be used again.
       * (unbind all events and destroy internal components)
       */
      destroy() {
        this.content.hasSlide = false;
        this.content.remove();
        this.container.remove();
        this.pswp.dispatch('slideDestroy', { slide: this });
      }

      resize() {
        if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {
          // Keep initial zoom level if it was before the resize,
          // as well as when this slide is not active

          // Reset position and scale to original state
          this.calculateSize();
          this.currentResolution = 0;
          this.zoomAndPanToInitial();
          this.applyCurrentZoomPan();
          this.updateContentSize();
        } else {
          // readjust pan position if it's beyond the bounds
          this.calculateSize();
          this.bounds.update(this.currZoomLevel);
          this.panTo(this.pan.x, this.pan.y);
        }
      }


      /**
       * Apply size to current slide content,
       * based on the current resolution and scale.
       *
       * @param {boolean=} force if size should be updated even if dimensions weren't changed
       */
      updateContentSize(force) {
        // Use initial zoom level
        // if resolution is not defined (user didn't zoom yet)
        const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;

        if (!scaleMultiplier) {
          return;
        }

        const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;
        const height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;

        if (!this.sizeChanged(width, height) && !force) {
          return;
        }
        this.content.setDisplayedSize(width, height);
      }

      /**
       * @param {number} width
       * @param {number} height
       */
      sizeChanged(width, height) {
        if (width !== this.prevDisplayedWidth
            || height !== this.prevDisplayedHeight) {
          this.prevDisplayedWidth = width;
          this.prevDisplayedHeight = height;
          return true;
        }

        return false;
      }

      getPlaceholderElement() {
        if (this.content.placeholder) {
          return this.content.placeholder.element;
        }
      }

      /**
       * Zoom current slide image to...
       *
       * @param {number} destZoomLevel Destination zoom level.
       * @param {{ x?: number; y?: number }} centerPoint
       * Transform origin center point, or false if viewport center should be used.
       * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
       * @param {boolean=} ignoreBounds Minimum and maximum zoom levels will be ignored.
       * @return {boolean=} Returns true if animated.
       */
      zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
        const { pswp } = this;
        if (!this.isZoomable()
            || pswp.mainScroll.isShifted()) {
          return;
        }

        pswp.dispatch('beforeZoomTo', {
          destZoomLevel, centerPoint, transitionDuration
        });

        // stop all pan and zoom transitions
        pswp.animations.stopAllPan();

        // if (!centerPoint) {
        //   centerPoint = pswp.getViewportCenterPoint();
        // }

        const prevZoomLevel = this.currZoomLevel;

        if (!ignoreBounds) {
          destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);
        }

        // if (transitionDuration === undefined) {
        //   transitionDuration = this.pswp.options.zoomAnimationDuration;
        // }

        this.setZoomLevel(destZoomLevel);
        this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);
        this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);
        roundPoint(this.pan);

        const finishTransition = () => {
          this._setResolution(destZoomLevel);
          this.applyCurrentZoomPan();
        };

        if (!transitionDuration) {
          finishTransition();
        } else {
          pswp.animations.startTransition({
            isPan: true,
            name: 'zoomTo',
            target: this.container,
            transform: this.getCurrentTransform(),
            onComplete: finishTransition,
            duration: transitionDuration,
            easing: pswp.options.easing
          });
        }
      }

      /**
       * @param {{ x?: number, y?: number }} [centerPoint]
       */
      toggleZoom(centerPoint) {
        this.zoomTo(
          this.currZoomLevel === this.zoomLevels.initial
            ? this.zoomLevels.secondary : this.zoomLevels.initial,
          centerPoint,
          this.pswp.options.zoomAnimationDuration
        );
      }

      /**
       * Updates zoom level property and recalculates new pan bounds,
       * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
       *
       * @param {number} currZoomLevel
       */
      setZoomLevel(currZoomLevel) {
        this.currZoomLevel = currZoomLevel;
        this.bounds.update(this.currZoomLevel);
      }

      /**
       * Get pan position after zoom at a given `point`.
       *
       * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
       * pan bounds according to the new zoom level.
       *
       * @param {'x' | 'y'} axis
       * @param {{ x?: number; y?: number }} [point]
       * point based on which zoom is performed, usually refers to the current mouse position,
       * if false - viewport center will be used.
       * @param {number=} prevZoomLevel Zoom level before new zoom was applied.
       */
      calculateZoomToPanOffset(axis, point, prevZoomLevel) {
        const totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];
        if (totalPanDistance === 0) {
          return this.bounds.center[axis];
        }

        if (!point) {
          point = this.pswp.getViewportCenterPoint();
        }

        const zoomFactor = this.currZoomLevel / prevZoomLevel;
        return this.bounds.correctPan(
          axis,
          (this.pan[axis] - point[axis]) * zoomFactor + point[axis]
        );
      }

      /**
       * Apply pan and keep it within bounds.
       *
       * @param {number} panX
       * @param {number} panY
       */
      panTo(panX, panY) {
        this.pan.x = this.bounds.correctPan('x', panX);
        this.pan.y = this.bounds.correctPan('y', panY);
        this.applyCurrentZoomPan();
      }

      /**
       * If the slide in the current state can be panned by the user
       */
      isPannable() {
        return this.width && (this.currZoomLevel > this.zoomLevels.fit);
      }

      /**
       * If the slide can be zoomed
       */
      isZoomable() {
        return this.width && this.content.isZoomable();
      }

      /**
       * Apply transform and scale based on
       * the current pan position (this.pan) and zoom level (this.currZoomLevel)
       */
      applyCurrentZoomPan() {
        this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);
        if (this === this.pswp.currSlide) {
          this.pswp.dispatch('zoomPanUpdate', { slide: this });
        }
      }

      zoomAndPanToInitial() {
        this.currZoomLevel = this.zoomLevels.initial;

        // pan according to the zoom level
        this.bounds.update(this.currZoomLevel);
        equalizePoints(this.pan, this.bounds.center);
        this.pswp.dispatch('initialZoomPan', { slide: this });
      }

      /**
       * Set translate and scale based on current resolution
       *
       * @param {number} x
       * @param {number} y
       * @param {number} zoom
       */
      _applyZoomTransform(x, y, zoom) {
        zoom /= this.currentResolution || this.zoomLevels.initial;
        setTransform(this.container, x, y, zoom);
      }

      calculateSize() {
        const { pswp } = this;

        equalizePoints(
          this.panAreaSize,
          getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index)
        );

        this.zoomLevels.update(this.width, this.height, this.panAreaSize);

        pswp.dispatch('calcSlideSize', {
          slide: this
        });
      }

      getCurrentTransform() {
        const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
        return toTransformString(this.pan.x, this.pan.y, scale);
      }

      /**
       * Set resolution and re-render the image.
       *
       * For example, if the real image size is 2000x1500,
       * and resolution is 0.5 - it will be rendered as 1000x750.
       *
       * Image with zoom level 2 and resolution 0.5 is
       * the same as image with zoom level 1 and resolution 1.
       *
       * Used to optimize animations and make
       * sure that browser renders image in highest quality.
       * Also used by responsive images to load the correct one.
       *
       * @param {number} newResolution
       */
      _setResolution(newResolution) {
        if (newResolution === this.currentResolution) {
          return;
        }

        this.currentResolution = newResolution;
        this.updateContentSize();

        this.pswp.dispatch('resolutionChanged');
      }
    }

    /** @typedef {import('../photoswipe.js').Point} Point */
    /** @typedef {import('./gestures.js').default} Gestures */

    const PAN_END_FRICTION = 0.35;
    const VERTICAL_DRAG_FRICTION = 0.6;

    // 1 corresponds to the third of viewport height
    const MIN_RATIO_TO_CLOSE = 0.4;

    // Minimum speed required to navigate
    // to next or previous slide
    const MIN_NEXT_SLIDE_SPEED = 0.5;

    /**
     * @param {number} initialVelocity
     * @param {number} decelerationRate
     */
    function project(initialVelocity, decelerationRate) {
      return initialVelocity * decelerationRate / (1 - decelerationRate);
    }

    /**
     * Handles single pointer dragging
     */
    class DragHandler {
      /**
       * @param {Gestures} gestures
       */
      constructor(gestures) {
        this.gestures = gestures;
        this.pswp = gestures.pswp;
        /** @type {Point} */
        this.startPan = {};
      }

      start() {
        equalizePoints(this.startPan, this.pswp.currSlide.pan);
        this.pswp.animations.stopAll();
      }

      change() {
        const { p1, prevP1, dragAxis, pswp } = this.gestures;
        const { currSlide } = pswp;

        if (dragAxis === 'y'
            && pswp.options.closeOnVerticalDrag
            && currSlide.currZoomLevel <= currSlide.zoomLevels.fit
            && !this.gestures.isMultitouch) {
          // Handle vertical drag to close
          const panY = currSlide.pan.y + (p1.y - prevP1.y);
          if (!pswp.dispatch('verticalDrag', { panY }).defaultPrevented) {
            this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);
            const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
            pswp.applyBgOpacity(bgOpacity);
            currSlide.applyCurrentZoomPan();
          }
        } else {
          const mainScrollChanged = this._panOrMoveMainScroll('x');
          if (!mainScrollChanged) {
            this._panOrMoveMainScroll('y');

            roundPoint(currSlide.pan);
            currSlide.applyCurrentZoomPan();
          }
        }
      }

      end() {
        const { pswp, velocity } = this.gestures;
        const { mainScroll } = pswp;
        let indexDiff = 0;

        pswp.animations.stopAll();

        // Handle main scroll if it's shifted
        if (mainScroll.isShifted()) {
          // Position of the main scroll relative to the viewport
          const mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX();

          // Ratio between 0 and 1:
          // 0 - slide is not visible at all,
          // 0.5 - half of the slide is vicible
          // 1 - slide is fully visible
          const currentSlideVisibilityRatio = (mainScrollShiftDiff / pswp.viewportSize.x);

          // Go next slide.
          //
          // - if velocity and its direction is matched
          //   and we see at least tiny part of the next slide
          //
          // - or if we see less than 50% of the current slide
          //   and velocity is close to 0
          //
          if ((velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0)
              || (velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5)) {
            // Go to next slide
            indexDiff = 1;
            velocity.x = Math.min(velocity.x, 0);
          } else if ((velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0)
              || (velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5)) {
            // Go to prev slide
            indexDiff = -1;
            velocity.x = Math.max(velocity.x, 0);
          }

          mainScroll.moveIndexBy(indexDiff, true, velocity.x);
        }

        // Restore zoom level
        if (pswp.currSlide.currZoomLevel > pswp.currSlide.zoomLevels.max
            || this.gestures.isMultitouch) {
          this.gestures.zoomLevels.correctZoomPan(true);
        } else {
          // we run two animations instead of one,
          // as each axis has own pan boundaries and thus different spring function
          // (correctZoomPan does not have this functionality,
          //  it animates all properties with single timing function)
          this._finishPanGestureForAxis('x');
          this._finishPanGestureForAxis('y');
        }
      }

      /**
       * @private
       * @param {'x' | 'y'} axis
       */
      _finishPanGestureForAxis(axis) {
        const { pswp } = this;
        const { currSlide } = pswp;
        const { velocity } = this.gestures;
        const { pan, bounds } = currSlide;
        const panPos = pan[axis];
        const restoreBgOpacity = (pswp.bgOpacity < 1 && axis === 'y');

        // 0.995 means - scroll view loses 0.5% of its velocity per millisecond
        // Inceasing this number will reduce travel distance
        const decelerationRate = 0.995; // 0.99

        // Pan position if there is no bounds
        const projectedPosition = panPos + project(velocity[axis], decelerationRate);

        if (restoreBgOpacity) {
          const vDragRatio = this._getVerticalDragRatio(panPos);
          const projectedVDragRatio = this._getVerticalDragRatio(projectedPosition);

          // If we are above and moving upwards,
          // or if we are below and moving downwards
          if ((vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE)
              || (vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE)) {
            pswp.close();
            return;
          }
        }

        // Pan position with corrected bounds
        const correctedPanPosition = bounds.correctPan(axis, projectedPosition);

        // Exit if pan position should not be changed
        // or if speed it too low
        if (panPos === correctedPanPosition) {
          return;
        }

        // Overshoot if the final position is out of pan bounds
        const dampingRatio = (correctedPanPosition === projectedPosition) ? 1 : 0.82;

        const initialBgOpacity = pswp.bgOpacity;
        const totalPanDist = correctedPanPosition - panPos;

        pswp.animations.startSpring({
          name: 'panGesture' + axis,
          isPan: true,
          start: panPos,
          end: correctedPanPosition,
          velocity: velocity[axis],
          dampingRatio,
          onUpdate: (pos) => {
            // Animate opacity of background relative to Y pan position of an image
            if (restoreBgOpacity && pswp.bgOpacity < 1) {
              // 0 - start of animation, 1 - end of animation
              const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist;

              // We clamp opacity to keep it between 0 and 1.
              // As progress ratio can be larger than 1 due to overshoot,
              // and we do not want to bounce opacity.
              pswp.applyBgOpacity(clamp(
                initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio,
                0,
                1
              ));
            }

            pan[axis] = Math.floor(pos);
            currSlide.applyCurrentZoomPan();
          },
        });
      }

      /**
       * Update position of the main scroll,
       * or/and update pan position of the current slide.
       *
       * Should return true if it changes (or can change) main scroll.
       *
       * @private
       * @param {'x' | 'y'} axis
       */
      _panOrMoveMainScroll(axis) {
        const { p1, pswp, dragAxis, prevP1, isMultitouch } = this.gestures;
        const { currSlide, mainScroll } = pswp;
        const delta = (p1[axis] - prevP1[axis]);
        const newMainScrollX = mainScroll.x + delta;

        if (!delta) {
          return;
        }

        // Always move main scroll if image can not be panned
        if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {
          mainScroll.moveTo(newMainScrollX, true);
          return true; // changed main scroll
        }

        const { bounds } = currSlide;
        const newPan = currSlide.pan[axis] + delta;

        if (pswp.options.allowPanToNext
            && dragAxis === 'x'
            && axis === 'x'
            && !isMultitouch) {
          const currSlideMainScrollX = mainScroll.getCurrSlideX();

          // Position of the main scroll relative to the viewport
          const mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;

          const isLeftToRight = delta > 0;
          const isRightToLeft = !isLeftToRight;

          if (newPan > bounds.min[axis] && isLeftToRight) {
            // Panning from left to right, beyond the left edge

            // Wether the image was at minimum pan position (or less)
            // when this drag gesture started.
            // Minimum pan position refers to the left edge of the image.
            const wasAtMinPanPosition = (bounds.min[axis] <= this.startPan[axis]);

            if (wasAtMinPanPosition) {
              mainScroll.moveTo(newMainScrollX, true);
              return true;
            } else {
              this._setPanWithFriction(axis, newPan);
              //currSlide.pan[axis] = newPan;
            }
          } else if (newPan < bounds.max[axis] && isRightToLeft) {
            // Paning from right to left, beyond the right edge

            // Maximum pan position refers to the right edge of the image.
            const wasAtMaxPanPosition = (this.startPan[axis] <= bounds.max[axis]);

            if (wasAtMaxPanPosition) {
              mainScroll.moveTo(newMainScrollX, true);
              return true;
            } else {
              this._setPanWithFriction(axis, newPan);
              //currSlide.pan[axis] = newPan;
            }
          } else {
            // If main scroll is shifted
            if (mainScrollShiftDiff !== 0) {
              // If main scroll is shifted right
              if (mainScrollShiftDiff > 0 /*&& isRightToLeft*/) {
                mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);
                return true;
              } else if (mainScrollShiftDiff < 0 /*&& isLeftToRight*/) {
                // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)
                mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);
                return true;
              }
            } else {
              // We are within pan bounds, so just pan
              this._setPanWithFriction(axis, newPan);
            }
          }
        } else {
          if (axis === 'y') {
            // Do not pan vertically if main scroll is shifted o
            if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {
              this._setPanWithFriction(axis, newPan);
            }
          } else {
            this._setPanWithFriction(axis, newPan);
          }
        }
      }
      //
      // If we move above - the ratio is negative
      // If we move below the ratio is positive

      /**
       * Relation between pan Y position and third of viewport height.
       *
       * When we are at initial position (center bounds) - the ratio is 0,
       * if position is shifted upwards - the ratio is negative,
       * if position is shifted downwards - the ratio is positive.
       *
       * @private
       * @param {number} panY The current pan Y position.
       */
      _getVerticalDragRatio(panY) {
        return (panY - this.pswp.currSlide.bounds.center.y)
                / (this.pswp.viewportSize.y / 3);
      }

      /**
       * Set pan position of the current slide.
       * Apply friction if the position is beyond the pan bounds,
       * or if custom friction is defined.
       *
       * @private
       * @param {'x' | 'y'} axis
       * @param {number} potentialPan
       * @param {number=} customFriction (0.1 - 1)
       */
      _setPanWithFriction(axis, potentialPan, customFriction) {
        const { pan, bounds } = this.pswp.currSlide;
        const correctedPan = bounds.correctPan(axis, potentialPan);
        // If we are out of pan bounds
        if (correctedPan !== potentialPan || customFriction) {
          const delta = Math.round(potentialPan - pan[axis]);
          pan[axis] += delta * (customFriction || PAN_END_FRICTION);
        } else {
          pan[axis] = potentialPan;
        }
      }
    }

    /** @typedef {import('../photoswipe.js').Point} Point */
    /** @typedef {import('./gestures.js').default} Gestures */

    const UPPER_ZOOM_FRICTION = 0.05;
    const LOWER_ZOOM_FRICTION = 0.15;


    /**
     * Get center point between two points
     *
     * @param {Point} p
     * @param {Point} p1
     * @param {Point} p2
     */
    function getZoomPointsCenter(p, p1, p2) {
      p.x = (p1.x + p2.x) / 2;
      p.y = (p1.y + p2.y) / 2;
      return p;
    }

    class ZoomHandler {
      /**
       * @param {Gestures} gestures
       */
      constructor(gestures) {
        this.gestures = gestures;
        this.pswp = this.gestures.pswp;
        /** @type {Point} */
        this._startPan = {};

        /** @type {Point} */
        this._startZoomPoint = {};
        /** @type {Point} */
        this._zoomPoint = {};
      }

      start() {
        this._startZoomLevel = this.pswp.currSlide.currZoomLevel;
        equalizePoints(this._startPan, this.pswp.currSlide.pan);
        this.pswp.animations.stopAllPan();
        this._wasOverFitZoomLevel = false;
      }

      change() {
        const { p1, startP1, p2, startP2, pswp } = this.gestures;
        const { currSlide } = pswp;
        const minZoomLevel = currSlide.zoomLevels.min;
        const maxZoomLevel = currSlide.zoomLevels.max;

        if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {
          return;
        }

        getZoomPointsCenter(this._startZoomPoint, startP1, startP2);
        getZoomPointsCenter(this._zoomPoint, p1, p2);

        let currZoomLevel = (1 / getDistanceBetween(startP1, startP2))
                          * getDistanceBetween(p1, p2)
                          * this._startZoomLevel;

        // slightly over the zoom.fit
        if (currZoomLevel > currSlide.zoomLevels.initial + (currSlide.zoomLevels.initial / 15)) {
          this._wasOverFitZoomLevel = true;
        }

        if (currZoomLevel < minZoomLevel) {
          if (pswp.options.pinchToClose
              && !this._wasOverFitZoomLevel
              && this._startZoomLevel <= currSlide.zoomLevels.initial) {
            // fade out background if zooming out
            const bgOpacity = 1 - ((minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2));
            if (!pswp.dispatch('pinchClose', { bgOpacity }).defaultPrevented) {
              pswp.applyBgOpacity(bgOpacity);
            }
          } else {
            // Apply the friction if zoom level is below the min
            currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;
          }
        } else if (currZoomLevel > maxZoomLevel) {
          // Apply the friction if zoom level is above the max
          currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;
        }

        currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);
        currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);

        currSlide.setZoomLevel(currZoomLevel);
        currSlide.applyCurrentZoomPan();
      }

      end() {
        const { pswp } = this;
        const { currSlide } = pswp;
        if (currSlide.currZoomLevel < currSlide.zoomLevels.initial
            && !this._wasOverFitZoomLevel
            && pswp.options.pinchToClose) {
          pswp.close();
        } else {
          this.correctZoomPan();
        }
      }

      /**
       * @private
       * @param {'x' | 'y'} axis
       * @param {number} currZoomLevel
       */
      _calculatePanForZoomLevel(axis, currZoomLevel) {
        const zoomFactor = currZoomLevel / this._startZoomLevel;
        return this._zoomPoint[axis]
                - ((this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor);
      }

      /**
       * Correct currZoomLevel and pan if they are
       * beyond minimum or maximum values.
       * With animation.
       *
       * @param {boolean=} ignoreGesture
       * Wether gesture coordinates should be ignored when calculating destination pan position.
       */
      correctZoomPan(ignoreGesture) {
        const { pswp } = this;
        const { currSlide } = pswp;

        if (!currSlide.isZoomable()) {
          return;
        }

        if (this._zoomPoint.x === undefined) {
          ignoreGesture = true;
        }

        const prevZoomLevel = currSlide.currZoomLevel;

        /** @type {number} */
        let destinationZoomLevel;
        let currZoomLevelNeedsChange = true;

        if (prevZoomLevel < currSlide.zoomLevels.initial) {
          destinationZoomLevel = currSlide.zoomLevels.initial;
          // zoom to min
        } else if (prevZoomLevel > currSlide.zoomLevels.max) {
          destinationZoomLevel = currSlide.zoomLevels.max;
          // zoom to max
        } else {
          currZoomLevelNeedsChange = false;
          destinationZoomLevel = prevZoomLevel;
        }

        const initialBgOpacity = pswp.bgOpacity;
        const restoreBgOpacity = pswp.bgOpacity < 1;

        const initialPan = equalizePoints({}, currSlide.pan);
        let destinationPan = equalizePoints({}, initialPan);

        if (ignoreGesture) {
          this._zoomPoint.x = 0;
          this._zoomPoint.y = 0;
          this._startZoomPoint.x = 0;
          this._startZoomPoint.y = 0;
          this._startZoomLevel = prevZoomLevel;
          equalizePoints(this._startPan, initialPan);
        }

        if (currZoomLevelNeedsChange) {
          destinationPan = {
            x: this._calculatePanForZoomLevel('x', destinationZoomLevel),
            y: this._calculatePanForZoomLevel('y', destinationZoomLevel)
          };
        }

        // set zoom level, so pan bounds are updated according to it
        currSlide.setZoomLevel(destinationZoomLevel);

        destinationPan = {
          x: currSlide.bounds.correctPan('x', destinationPan.x),
          y: currSlide.bounds.correctPan('y', destinationPan.y)
        };

        // return zoom level and its bounds to initial
        currSlide.setZoomLevel(prevZoomLevel);

        let panNeedsChange = true;
        if (pointsEqual(destinationPan, initialPan)) {
          panNeedsChange = false;
        }

        if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {
          // update resolution after gesture
          currSlide._setResolution(destinationZoomLevel);
          currSlide.applyCurrentZoomPan();

          // nothing to animate
          return;
        }

        pswp.animations.stopAllPan();

        pswp.animations.startSpring({
          isPan: true,
          start: 0,
          end: 1000,
          velocity: 0,
          dampingRatio: 1,
          naturalFrequency: 40,
          onUpdate: (now) => {
            now /= 1000; // 0 - start, 1 - end

            if (panNeedsChange || currZoomLevelNeedsChange) {
              if (panNeedsChange) {
                currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;
                currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;
              }

              if (currZoomLevelNeedsChange) {
                const newZoomLevel = prevZoomLevel
                            + (destinationZoomLevel - prevZoomLevel) * now;
                currSlide.setZoomLevel(newZoomLevel);
              }

              currSlide.applyCurrentZoomPan();
            }

            // Restore background opacity
            if (restoreBgOpacity && pswp.bgOpacity < 1) {
              // We clamp opacity to keep it between 0 and 1.
              // As progress ratio can be larger than 1 due to overshoot,
              // and we do not want to bounce opacity.
              pswp.applyBgOpacity(clamp(
                initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1
              ));
            }
          },
          onComplete: () => {
            // update resolution after transition ends
            currSlide._setResolution(destinationZoomLevel);
            currSlide.applyCurrentZoomPan();
          }
        });
      }
    }

    /**
     * @template T
     * @template P
     * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>
     */

    /** @typedef {import('./gestures.js').default} Gestures */

    /** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */
    /** @typedef {{ x?: number; y?: number }} Point */

    /**
     * Whether the tap was performed on the main slide
     * (rather than controls or caption).
     *
     * @param {PointerEvent} event
     */
    function didTapOnMainContent(event) {
      return !!(/** @type {HTMLElement} */ (event.target).closest('.pswp__container'));
    }

    /**
     * Tap, double-tap handler.
     */
    class TapHandler {
      /**
       * @param {Gestures} gestures
       */
      constructor(gestures) {
        this.gestures = gestures;
      }

      /**
       * @param {Point} point
       * @param {PointerEvent} originalEvent
       */
      click(point, originalEvent) {
        const targetClassList = /** @type {HTMLElement} */ (originalEvent.target).classList;
        const isImageClick = targetClassList.contains('pswp__img');
        const isBackgroundClick = targetClassList.contains('pswp__item')
                                  || targetClassList.contains('pswp__zoom-wrap');

        if (isImageClick) {
          this._doClickOrTapAction('imageClick', point, originalEvent);
        } else if (isBackgroundClick) {
          this._doClickOrTapAction('bgClick', point, originalEvent);
        }
      }

      /**
       * @param {Point} point
       * @param {PointerEvent} originalEvent
       */
      tap(point, originalEvent) {
        if (didTapOnMainContent(originalEvent)) {
          this._doClickOrTapAction('tap', point, originalEvent);
        }
      }

      /**
       * @param {Point} point
       * @param {PointerEvent} originalEvent
       */
      doubleTap(point, originalEvent) {
        if (didTapOnMainContent(originalEvent)) {
          this._doClickOrTapAction('doubleTap', point, originalEvent);
        }
      }

      /**
       * @param {Actions} actionName
       * @param {Point} point
       * @param {PointerEvent} originalEvent
       */
      _doClickOrTapAction(actionName, point, originalEvent) {
        const { pswp } = this.gestures;
        const { currSlide } = pswp;
        const actionFullName = /** @type {AddPostfix<Actions, 'Action'>} */ (actionName + 'Action');
        const optionValue = pswp.options[actionFullName];

        if (pswp.dispatch(actionFullName, { point, originalEvent }).defaultPrevented) {
          return;
        }

        if (typeof optionValue === 'function') {
          optionValue.call(pswp, point, originalEvent);
          return;
        }

        switch (optionValue) {
          case 'close':
          case 'next':
            pswp[optionValue]();
            break;
          case 'zoom':
            currSlide.toggleZoom(point);
            break;
          case 'zoom-or-close':
            // by default click zooms current image,
            // if it can not be zoomed - gallery will be closed
            if (currSlide.isZoomable()
                && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {
              currSlide.toggleZoom(point);
            } else if (pswp.options.clickToCloseNonZoomable) {
              pswp.close();
            }
            break;
          case 'toggle-controls':
            this.gestures.pswp.element.classList.toggle('pswp--ui-visible');
            // if (_controlsVisible) {
            //   _ui.hideControls();
            // } else {
            //   _ui.showControls();
            // }
            break;
        }
      }
    }

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../photoswipe.js').Point} Point */

    // How far should user should drag
    // until we can determine that the gesture is swipe and its direction
    const AXIS_SWIPE_HYSTERISIS = 10;
    //const PAN_END_FRICTION = 0.35;

    const DOUBLE_TAP_DELAY = 300; // ms
    const MIN_TAP_DISTANCE = 25; // px

    /**
     * Gestures class bind touch, pointer or mouse events
     * and emits drag to drag-handler and zoom events zoom-handler.
     *
     * Drag and zoom events are emited in requestAnimationFrame,
     * and only when one of pointers was actually changed.
     */
    class Gestures {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;

        /** @type {'x' | 'y'} */
        this.dragAxis = undefined;

        // point objects are defined once and reused
        // PhotoSwipe keeps track only of two pointers, others are ignored
        /** @type {Point} */
        this.p1 = {}; // the first pressed pointer
        /** @type {Point} */
        this.p2 = {}; // the second pressed pointer
        /** @type {Point} */
        this.prevP1 = {};
        /** @type {Point} */
        this.prevP2 = {};
        /** @type {Point} */
        this.startP1 = {};
        /** @type {Point} */
        this.startP2 = {};
        /** @type {Point} */
        this.velocity = {};

        /** @type {Point} */
        this._lastStartP1 = {};
        /** @type {Point} */
        this._intervalP1 = {};
        this._numActivePoints = 0;
        /** @type {Point[]} */
        this._ongoingPointers = [];

        this._touchEventEnabled = 'ontouchstart' in window;
        this._pointerEventEnabled = !!(window.PointerEvent);
        this.supportsTouch = this._touchEventEnabled
                              || (this._pointerEventEnabled && navigator.maxTouchPoints > 1);

        if (!this.supportsTouch) {
          // disable pan to next slide for non-touch devices
          pswp.options.allowPanToNext = false;
        }

        this.drag = new DragHandler(this);
        this.zoomLevels = new ZoomHandler(this);
        this.tapHandler = new TapHandler(this);

        pswp.on('bindEvents', () => {
          pswp.events.add(pswp.scrollWrap, 'click', e => this._onClick(e));

          if (this._pointerEventEnabled) {
            this._bindEvents('pointer', 'down', 'up', 'cancel');
          } else if (this._touchEventEnabled) {
            this._bindEvents('touch', 'start', 'end', 'cancel');

            // In previous versions we also bound mouse event here,
            // in case device supports both touch and mouse events,
            // but newer versions of browsers now support PointerEvent.

            // on iOS10 if you bind touchmove/end after touchstart,
            // and you don't preventDefault touchstart (which PhotoSwipe does),
            // preventDefault will have no effect on touchmove and touchend.
            // Unless you bind it previously.
            pswp.scrollWrap.ontouchmove = () => {}; // eslint-disable-line
            pswp.scrollWrap.ontouchend = () => {}; // eslint-disable-line
          } else {
            this._bindEvents('mouse', 'down', 'up');
          }
        });
      }

      /**
       *
       * @param {'mouse' | 'touch' | 'pointer'} pref
       * @param {'down' | 'start'} down
       * @param {'up' | 'end'} up
       * @param {'cancel'} [cancel]
       */
      _bindEvents(pref, down, up, cancel) {
        const { pswp } = this;
        const { events } = pswp;

        const cancelEvent = cancel ? pref + cancel : '';

        events.add(pswp.scrollWrap, pref + down, this.onPointerDown.bind(this));
        events.add(window, pref + 'move', this.onPointerMove.bind(this));
        events.add(window, pref + up, this.onPointerUp.bind(this));
        if (cancelEvent) {
          events.add(pswp.scrollWrap, cancelEvent, this.onPointerUp.bind(this));
        }
      }

      /**
       * @param {PointerEvent} e
       */
      onPointerDown(e) {
        // We do not call preventDefault for touch events
        // to allow browser to show native dialog on longpress
        // (the one that allows to save image or open it in new tab).
        //
        // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,
        // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.
        let isMousePointer;
        if (e.type === 'mousedown' || e.pointerType === 'mouse') {
          isMousePointer = true;
        }

        // Allow dragging only via left mouse button.
        // http://www.quirksmode.org/js/events_properties.html
        // https://developer.mozilla.org/en-US/docs/Web/API/event.button
        if (isMousePointer && e.button > 0) {
          return;
        }

        const { pswp } = this;

        // if PhotoSwipe is opening or closing
        if (!pswp.opener.isOpen) {
          e.preventDefault();
          return;
        }

        if (pswp.dispatch('pointerDown', { originalEvent: e }).defaultPrevented) {
          return;
        }

        if (isMousePointer) {
          pswp.mouseDetected();

          // preventDefault mouse event to prevent
          // browser image drag feature
          this._preventPointerEventBehaviour(e);
        }

        pswp.animations.stopAll();

        this._updatePoints(e, 'down');

        this.pointerDown = true;

        if (this._numActivePoints === 1) {
          this.dragAxis = null;
          // we need to store initial point to determine the main axis,
          // drag is activated only after the axis is determined
          equalizePoints(this.startP1, this.p1);
        }

        if (this._numActivePoints > 1) {
          // Tap or double tap should not trigger if more than one pointer
          this._clearTapTimer();
          this.isMultitouch = true;
        } else {
          this.isMultitouch = false;
        }
      }

      /**
       * @param {PointerEvent} e
       */
      onPointerMove(e) {
        e.preventDefault(); // always preventDefault move event

        if (!this._numActivePoints) {
          return;
        }

        this._updatePoints(e, 'move');

        if (this.pswp.dispatch('pointerMove', { originalEvent: e }).defaultPrevented) {
          return;
        }

        if (this._numActivePoints === 1 && !this.isDragging) {
          if (!this.dragAxis) {
            this._calculateDragDirection();
          }

          // Drag axis was detected, emit drag.start
          if (this.dragAxis && !this.isDragging) {
            if (this.isZooming) {
              this.isZooming = false;
              this.zoomLevels.end();
            }

            this.isDragging = true;
            this._clearTapTimer(); // Tap can not trigger after drag

            // Adjust starting point
            this._updateStartPoints();
            this._intervalTime = Date.now();
            //this._startTime = this._intervalTime;
            this._velocityCalculated = false;
            equalizePoints(this._intervalP1, this.p1);
            this.velocity.x = 0;
            this.velocity.y = 0;
            this.drag.start();

            this._rafStopLoop();
            this._rafRenderLoop();
          }
        } else if (this._numActivePoints > 1 && !this.isZooming) {
          this._finishDrag();

          this.isZooming = true;

          // Adjust starting points
          this._updateStartPoints();

          this.zoomLevels.start();

          this._rafStopLoop();
          this._rafRenderLoop();
        }
      }

      /**
       * @private
       */
      _finishDrag() {
        if (this.isDragging) {
          this.isDragging = false;

          // Try to calculate velocity,
          // if it wasn't calculated yet in drag.change
          if (!this._velocityCalculated) {
            this._updateVelocity(true);
          }

          this.drag.end();
          this.dragAxis = null;
        }
      }

      /**
       * @param {PointerEvent} e
       */
      onPointerUp(e) {
        if (!this._numActivePoints) {
          return;
        }

        this._updatePoints(e, 'up');

        if (this.pswp.dispatch('pointerUp', { originalEvent: e }).defaultPrevented) {
          return;
        }

        if (this._numActivePoints === 0) {
          this.pointerDown = false;
          this._rafStopLoop();

          if (this.isDragging) {
            this._finishDrag();
          } else if (!this.isZooming && !this.isMultitouch) {
            //this.zoomLevels.correctZoomPan();
            this._finishTap(e);
          }
        }

        if (this._numActivePoints < 2 && this.isZooming) {
          this.isZooming = false;
          this.zoomLevels.end();

          if (this._numActivePoints === 1) {
            // Since we have 1 point left, we need to reinitiate drag
            this.dragAxis = null;
            this._updateStartPoints();
          }
        }
      }

      /**
       * @private
       */
      _rafRenderLoop() {
        if (this.isDragging || this.isZooming) {
          this._updateVelocity();

          if (this.isDragging) {
            // make sure that pointer moved since the last update
            if (!pointsEqual(this.p1, this.prevP1)) {
              this.drag.change();
            }
          } else /* if (this.isZooming) */ {
            if (!pointsEqual(this.p1, this.prevP1)
                || !pointsEqual(this.p2, this.prevP2)) {
              this.zoomLevels.change();
            }
          }

          this._updatePrevPoints();
          this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));
        }
      }

      /**
       * Update velocity at 50ms interval
       *
       * @param {boolean=} force
       */
      _updateVelocity(force) {
        const time = Date.now();
        const duration = time - this._intervalTime;

        if (duration < 50 && !force) {
          return;
        }


        this.velocity.x = this._getVelocity('x', duration);
        this.velocity.y = this._getVelocity('y', duration);

        this._intervalTime = time;
        equalizePoints(this._intervalP1, this.p1);
        this._velocityCalculated = true;
      }

      /**
       * @private
       * @param {PointerEvent} e
       */
      _finishTap(e) {
        const { mainScroll } = this.pswp;

        // Do not trigger tap events if main scroll is shifted
        if (mainScroll.isShifted()) {
          // restore main scroll position
          // (usually happens if stopped in the middle of animation)
          mainScroll.moveIndexBy(0, true);
          return;
        }

        // Do not trigger tap for touchcancel or pointercancel
        if (e.type.indexOf('cancel') > 0) {
          return;
        }

        // Trigger click instead of tap for mouse events
        if (e.type === 'mouseup' || e.pointerType === 'mouse') {
          this.tapHandler.click(this.startP1, e);
          return;
        }

        // Disable delay if there is no doubleTapAction
        const tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0;

        // If tapTimer is defined - we tapped recently,
        // check if the current tap is close to the previous one,
        // if yes - trigger double tap
        if (this._tapTimer) {
          this._clearTapTimer();
          // Check if two taps were more or less on the same place
          if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {
            this.tapHandler.doubleTap(this.startP1, e);
          }
        } else {
          equalizePoints(this._lastStartP1, this.startP1);
          this._tapTimer = setTimeout(() => {
            this.tapHandler.tap(this.startP1, e);
            this._clearTapTimer();
          }, tapDelay);
        }
      }

      /**
       * @private
       */
      _clearTapTimer() {
        if (this._tapTimer) {
          clearTimeout(this._tapTimer);
          this._tapTimer = null;
        }
      }

      /**
       * Get velocity for axis
       *
       * @private
       * @param {'x' | 'y'} axis
       * @param {number} duration
       */
      _getVelocity(axis, duration) {
        // displacement is like distance, but can be negative.
        const displacement = this.p1[axis] - this._intervalP1[axis];

        if (Math.abs(displacement) > 1 && duration > 5) {
          return displacement / duration;
        }

        return 0;
      }

      /**
       * @private
       */
      _rafStopLoop() {
        if (this.raf) {
          cancelAnimationFrame(this.raf);
          this.raf = null;
        }
      }

      /**
       * @private
       * @param {PointerEvent} e
       */
      _preventPointerEventBehaviour(e) {
        // TODO find a way to disable e.preventDefault on some elements
        //      via event or some class or something
        e.preventDefault();
        return true;
      }

      /**
       * Parses and normalizes points from the touch, mouse or pointer event.
       * Updates p1 and p2.
       *
       * @private
       * @param {PointerEvent | TouchEvent} e
       * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
       */
      _updatePoints(e, pointerType) {
        if (this._pointerEventEnabled) {
          const pointerEvent = /** @type {PointerEvent} */ (e);
          // Try to find the current pointer in ongoing pointers by its ID
          const pointerIndex = this._ongoingPointers.findIndex((ongoingPoiner) => {
            return ongoingPoiner.id === pointerEvent.pointerId;
          });

          if (pointerType === 'up' && pointerIndex > -1) {
            // release the pointer - remove it from ongoing
            this._ongoingPointers.splice(pointerIndex, 1);
          } else if (pointerType === 'down' && pointerIndex === -1) {
            // add new pointer
            this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, {}));
          } else if (pointerIndex > -1) {
            // update existing pointer
            this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);
          }

          this._numActivePoints = this._ongoingPointers.length;

          // update points that PhotoSwipe uses
          // to calculate position and scale
          if (this._numActivePoints > 0) {
            equalizePoints(this.p1, this._ongoingPointers[0]);
          }

          if (this._numActivePoints > 1) {
            equalizePoints(this.p2, this._ongoingPointers[1]);
          }
        } else {
          const touchEvent = /** @type {TouchEvent} */ (e);

          this._numActivePoints = 0;
          if (touchEvent.type.indexOf('touch') > -1) {
            // Touch Event
            // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
            if (touchEvent.touches && touchEvent.touches.length > 0) {
              this._convertEventPosToPoint(touchEvent.touches[0], this.p1);
              this._numActivePoints++;
              if (touchEvent.touches.length > 1) {
                this._convertEventPosToPoint(touchEvent.touches[1], this.p2);
                this._numActivePoints++;
              }
            }
          } else {
            // Mouse Event
            this._convertEventPosToPoint(/** @type {PointerEvent} */ (e), this.p1);
            if (pointerType === 'up') {
              // clear all points on mouseup
              this._numActivePoints = 0;
            } else {
              this._numActivePoints++;
            }
          }
        }
      }

      // update points that were used during previous rAF tick
      _updatePrevPoints() {
        equalizePoints(this.prevP1, this.p1);
        equalizePoints(this.prevP2, this.p2);
      }

      // update points at the start of gesture
      _updateStartPoints() {
        equalizePoints(this.startP1, this.p1);
        equalizePoints(this.startP2, this.p2);
        this._updatePrevPoints();
      }

      _calculateDragDirection() {
        if (this.pswp.mainScroll.isShifted()) {
          // if main scroll position is shifted – direction is always horizontal
          this.dragAxis = 'x';
        } else {
          // calculate delta of the last touchmove tick
          const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);

          if (diff !== 0) {
            // check if pointer was shifted horizontally or vertically
            const axisToCheck = diff > 0 ? 'x' : 'y';

            if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {
              this.dragAxis = axisToCheck;
            }
          }
        }
      }

      /**
       * Converts touch, pointer or mouse event
       * to PhotoSwipe point.
       *
       * @private
       * @param {Touch | PointerEvent} e
       * @param {Point} p
       */
      _convertEventPosToPoint(e, p) {
        p.x = e.pageX - this.pswp.offset.x;
        p.y = e.pageY - this.pswp.offset.y;

        if ('pointerId' in e) {
          p.id = e.pointerId;
        } else if (e.identifier !== undefined) {
          p.id = e.identifier;
        }

        return p;
      }

      /**
       * @private
       * @param {PointerEvent} e
       */
      _onClick(e) {
        // Do not allow click event to pass through after drag
        if (this.pswp.mainScroll.isShifted()) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    }

    /** @typedef {import('./photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('./slide/slide.js').default} Slide */

    /** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */

    const MAIN_SCROLL_END_FRICTION = 0.35;


    // const MIN_SWIPE_TRANSITION_DURATION = 250;
    // const MAX_SWIPE_TRABSITION_DURATION = 500;
    // const DEFAULT_SWIPE_TRANSITION_DURATION = 333;

    /**
     * Handles movement of the main scrolling container
     * (for example, it repositions when user swipes left or right).
     *
     * Also stores its state.
     */
    class MainScroll {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;
        this.x = 0;

        /** @type {number} */
        this.slideWidth = undefined;

        /** @type {ItemHolder[]} */
        this.itemHolders = undefined;

        this.resetPosition();
      }

      /**
       * Position the scroller and slide containers
       * according to viewport size.
       *
       * @param {boolean=} resizeSlides Whether slides content should resized
       */
      resize(resizeSlides) {
        const { pswp } = this;
        const newSlideWidth = Math.round(
          pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing
        );
        // Mobile browsers might trigger a resize event during a gesture.
        // (due to toolbar appearing or hiding).
        // Avoid re-adjusting main scroll position if width wasn't changed
        const slideWidthChanged = (newSlideWidth !== this.slideWidth);

        if (slideWidthChanged) {
          this.slideWidth = newSlideWidth;
          this.moveTo(this.getCurrSlideX());
        }

        this.itemHolders.forEach((itemHolder, index) => {
          if (slideWidthChanged) {
            setTransform(itemHolder.el, (index + this._containerShiftIndex)
                                        * this.slideWidth);
          }

          if (resizeSlides && itemHolder.slide) {
            itemHolder.slide.resize();
          }
        });
      }

      /**
       * Reset X position of the main scroller to zero
       */
      resetPosition() {
        // Position on the main scroller (offset)
        // it is independent from slide index
        this._currPositionIndex = 0;
        this._prevPositionIndex = 0;

        // This will force recalculation of size on next resize()
        this.slideWidth = 0;

        // _containerShiftIndex*viewportSize will give you amount of transform of the current slide
        this._containerShiftIndex = -1;
      }

      /**
       * Create and append array of three items
       * that hold data about slides in DOM
       */
      appendHolders() {
        this.itemHolders = [];

        // append our three slide holders -
        // previous, current, and next
        for (let i = 0; i < 3; i++) {
          const el = createElement('pswp__item', false, this.pswp.container);
          el.setAttribute('role', 'group');
          el.setAttribute('aria-roledescription', 'slide');
          el.setAttribute('aria-hidden', 'true');

          // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)
          el.style.display = (i === 1) ? 'block' : 'none';

          this.itemHolders.push({
            el,
            //index: -1
          });
        }
      }

      /**
       * Whether the main scroll can be horizontally swiped to the next or previous slide.
       */
      canBeSwiped() {
        return this.pswp.getNumItems() > 1;
      }

      /**
       * Move main scroll by X amount of slides.
       * For example:
       *   `-1` will move to the previous slide,
       *    `0` will reset the scroll position of the current slide,
       *    `3` will move three slides forward
       *
       * If loop option is enabled - index will be automatically looped too,
       * (for example `-1` will move to the last slide of the gallery).
       *
       * @param {number} diff
       * @param {boolean=} animate
       * @param {number=} velocityX
       * @returns {boolean} whether index was changed or not
       */
      moveIndexBy(diff, animate, velocityX) {
        const { pswp } = this;
        let newIndex = pswp.potentialIndex + diff;
        const numSlides = pswp.getNumItems();

        if (pswp.canLoop()) {
          newIndex = pswp.getLoopedIndex(newIndex);
          const distance = (diff + numSlides) % numSlides;
          if (distance <= numSlides / 2) {
            // go forward
            diff = distance;
          } else {
            // go backwards
            diff = distance - numSlides;
          }
        } else {
          if (newIndex < 0) {
            newIndex = 0;
          } else if (newIndex >= numSlides) {
            newIndex = numSlides - 1;
          }
          diff = newIndex - pswp.potentialIndex;
        }

        pswp.potentialIndex = newIndex;
        this._currPositionIndex -= diff;

        pswp.animations.stopMainScroll();

        const destinationX = this.getCurrSlideX();
        if (!animate) {
          this.moveTo(destinationX);
          this.updateCurrItem();
        } else {
          pswp.animations.startSpring({
            isMainScroll: true,
            start: this.x,
            end: destinationX,
            velocity: velocityX || 0,
            naturalFrequency: 30,
            dampingRatio: 1, //0.7,
            onUpdate: (x) => {
              this.moveTo(x);
            },
            onComplete: () => {
              this.updateCurrItem();
              pswp.appendHeavy();
            }
          });

          let currDiff = pswp.potentialIndex - pswp.currIndex;
          if (pswp.canLoop()) {
            const currDistance = (currDiff + numSlides) % numSlides;
            if (currDistance <= numSlides / 2) {
              // go forward
              currDiff = currDistance;
            } else {
              // go backwards
              currDiff = currDistance - numSlides;
            }
          }

          // Force-append new slides during transition
          // if difference between slides is more than 1
          if (Math.abs(currDiff) > 1) {
            this.updateCurrItem();
          }
        }

        if (diff) {
          return true;
        }
      }

      /**
       * X position of the main scroll for the current slide
       * (ignores position during dragging)
       */
      getCurrSlideX() {
        return this.slideWidth * this._currPositionIndex;
      }

      /**
       * Whether scroll position is shifted.
       * For example, it will return true if the scroll is being dragged or animated.
       */
      isShifted() {
        return this.x !== this.getCurrSlideX();
      }

      /**
       * Update slides X positions and set their content
       */
      updateCurrItem() {
        const { pswp } = this;
        const positionDifference = this._prevPositionIndex - this._currPositionIndex;

        if (!positionDifference) {
          return;
        }

        this._prevPositionIndex = this._currPositionIndex;

        pswp.currIndex = pswp.potentialIndex;

        let diffAbs = Math.abs(positionDifference);
        let tempHolder;

        if (diffAbs >= 3) {
          this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);
          diffAbs = 3;
        }

        for (let i = 0; i < diffAbs; i++) {
          if (positionDifference > 0) {
            tempHolder = this.itemHolders.shift();
            this.itemHolders[2] = tempHolder; // move first to last

            this._containerShiftIndex++;

            setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);

            pswp.setContent(tempHolder, (pswp.currIndex - diffAbs) + i + 2);
          } else {
            tempHolder = this.itemHolders.pop();
            this.itemHolders.unshift(tempHolder); // move last to first

            this._containerShiftIndex--;

            setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);

            pswp.setContent(tempHolder, (pswp.currIndex + diffAbs) - i - 2);
          }
        }

        // Reset transfrom every 50ish navigations in one direction.
        //
        // Otherwise transform will keep growing indefinitely,
        // which might cause issues as browsers have a maximum transform limit.
        // I wasn't able to reach it, but just to be safe.
        // This should not cause noticable lag.
        if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {
          this.resetPosition();
          this.resize();
        }

        // Pan transition might be running (and consntantly updating pan position)
        pswp.animations.stopAllPan();

        this.itemHolders.forEach((itemHolder, i) => {
          if (itemHolder.slide) {
            // Slide in the 2nd holder is always active
            itemHolder.slide.setIsActive(i === 1);
          }
        });

        pswp.currSlide = this.itemHolders[1].slide;
        pswp.contentLoader.updateLazy(positionDifference);

        if (pswp.currSlide) {
          pswp.currSlide.applyCurrentZoomPan();
        }

        pswp.dispatch('change');
      }

      /**
       * Move the X position of the main scroll container
       *
       * @param {number} x
       * @param {boolean=} dragging
       */
      moveTo(x, dragging) {
        /** @type {number} */
        let newSlideIndexOffset;
        /** @type {number} */
        let delta;

        if (!this.pswp.canLoop() && dragging) {
          // Apply friction
          newSlideIndexOffset = ((this.slideWidth * this._currPositionIndex) - x) / this.slideWidth;
          newSlideIndexOffset += this.pswp.currIndex;
          delta = Math.round(x - this.x);

          if ((newSlideIndexOffset < 0 && delta > 0)
              || (newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0)) {
            x = this.x + (delta * MAIN_SCROLL_END_FRICTION);
          }
        }

        this.x = x;
        setTransform(this.pswp.container, x);

        this.pswp.dispatch('moveMainScroll', { x, dragging });
      }
    }

    /** @typedef {import('./photoswipe.js').default} PhotoSwipe */

    /**
     * @template T
     * @typedef {import('./types.js').Methods<T>} Methods<T>
     */

    /**
     * - Manages keyboard shortcuts.
     * - Heps trap focus within photoswipe.
     */
    class Keyboard {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;

        pswp.on('bindEvents', () => {
          // Dialog was likely opened by keyboard if initial point is not defined
          if (!pswp.options.initialPointerPos) {
            // focus causes layout,
            // which causes lag during the animation,
            // that's why we delay it until the opener transition ends
            this._focusRoot();
          }

          pswp.events.add(document, 'focusin', this._onFocusIn.bind(this));
          pswp.events.add(document, 'keydown', this._onKeyDown.bind(this));
        });

        const lastActiveElement = /** @type {HTMLElement} */ (document.activeElement);
        pswp.on('destroy', () => {
          if (pswp.options.returnFocus
              && lastActiveElement
              && this._wasFocused) {
            lastActiveElement.focus();
          }
        });
      }

      _focusRoot() {
        if (!this._wasFocused) {
          this.pswp.element.focus();
          this._wasFocused = true;
        }
      }

      /**
       * @param {KeyboardEvent} e
       */
      _onKeyDown(e) {
        const { pswp } = this;

        if (pswp.dispatch('keydown', { originalEvent: e }).defaultPrevented) {
          return;
        }

        if (specialKeyUsed(e)) {
          // don't do anything if special key pressed
          // to prevent from overriding default browser actions
          // for example, in Chrome on Mac cmd+arrow-left returns to previous page
          return;
        }

        /** @type {Methods<PhotoSwipe>} */
        let keydownAction;
        /** @type {'x' | 'y'} */
        let axis;
        let isForward;

        switch (e.keyCode) {
          case 27: // esc
            if (pswp.options.escKey) {
              keydownAction = 'close';
            }
            break;
          case 90: // z key
            keydownAction = 'toggleZoom';
            break;
          case 37: // left
            axis = 'x';
            break;
          case 38: // top
            axis = 'y';
            break;
          case 39: // right
            axis = 'x';
            isForward = true;
            break;
          case 40: // bottom
            isForward = true;
            axis = 'y';
            break;
          case 9: // tab
            this._focusRoot();
            break;
        }

        // if left/right/top/bottom key
        if (axis) {
          // prevent page scroll
          e.preventDefault();

          const { currSlide } = pswp;

          if (pswp.options.arrowKeys
              && axis === 'x'
              && pswp.getNumItems() > 1) {
            keydownAction = isForward ? 'next' : 'prev';
          } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {
            // up/down arrow keys pan the image vertically
            // left/right arrow keys pan horizontally.
            // Unless there is only one image,
            // or arrowKeys option is disabled
            currSlide.pan[axis] += isForward ? -80 : 80;
            currSlide.panTo(currSlide.pan.x, currSlide.pan.y);
          }
        }

        if (keydownAction) {
          e.preventDefault();
          pswp[keydownAction]();
        }
      }

      /**
       * Trap focus inside photoswipe
       *
       * @param {FocusEvent} e
       */
      _onFocusIn(e) {
        const { template } = this.pswp;
        if (document !== e.target
            && template !== e.target
            && !template.contains(/** @type {Node} */ (e.target))) {
          // focus root element
          template.focus();
        }
      }
    }

    const DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';

    /** @typedef {import('./animations.js').AnimationProps} AnimationProps */

    /**
     * Runs CSS transition.
     */
    class CSSAnimation {
      /**
       * onComplete can be unpredictable, be careful about current state
       *
       * @param {AnimationProps} props
       */
      constructor(props) {
        this.props = props;
        const {
          target,
          onComplete,
          transform,
          onFinish
          // opacity
        } = props;

        let {
          duration,
          easing,
        } = props;

        /** @type {() => void} */
        this.onFinish = onFinish;

        // support only transform and opacity
        const prop = transform ? 'transform' : 'opacity';
        const propValue = props[prop];

        /** @private */
        this._target = target;
        /** @private */
        this._onComplete = onComplete;

        duration = duration || 333;
        easing = easing || DEFAULT_EASING;

        /** @private */
        this._onTransitionEnd = this._onTransitionEnd.bind(this);

        // Using timeout hack to make sure that animation
        // starts even if the animated property was changed recently,
        // otherwise transitionend might not fire or transiton won't start.
        // https://drafts.csswg.org/css-transitions/#starting
        //
        // ¯\_(ツ)_/¯
        /** @private */
        this._helperTimeout = setTimeout(() => {
          setTransitionStyle(target, prop, duration, easing);
          this._helperTimeout = setTimeout(() => {
            target.addEventListener('transitionend', this._onTransitionEnd, false);
            target.addEventListener('transitioncancel', this._onTransitionEnd, false);

            // Safari occasionally does not emit transitionend event
            // if element propery was modified during the transition,
            // which may be caused by resize or third party component,
            // using timeout as a safety fallback
            this._helperTimeout = setTimeout(() => {
              this._finalizeAnimation();
            }, duration + 500);
            target.style[prop] = propValue;
          }, 30); // Do not reduce this number
        }, 0);
      }

      /**
       * @private
       * @param {TransitionEvent} e
       */
      _onTransitionEnd(e) {
        if (e.target === this._target) {
          this._finalizeAnimation();
        }
      }

      /**
       * @private
       */
      _finalizeAnimation() {
        if (!this._finished) {
          this._finished = true;
          this.onFinish();
          if (this._onComplete) {
            this._onComplete();
          }
        }
      }

      // Destroy is called automatically onFinish
      destroy() {
        if (this._helperTimeout) {
          clearTimeout(this._helperTimeout);
        }
        removeTransitionStyle(this._target);
        this._target.removeEventListener('transitionend', this._onTransitionEnd, false);
        this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);
        if (!this._finished) {
          this._finalizeAnimation();
        }
      }
    }

    const DEFAULT_NATURAL_FREQUENCY = 12;
    const DEFAULT_DAMPING_RATIO = 0.75;

    /**
     * Spring easing helper
     */
    class SpringEaser {
      /**
       * @param {number} initialVelocity Initial velocity, px per ms.
       *
       * @param {number} dampingRatio
       * Determines how bouncy animation will be.
       * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
       * "overshoot" refers to part of animation that
       * goes beyond the final value.
       *
       * @param {number} naturalFrequency
       * Determines how fast animation will slow down.
       * The higher value - the stiffer the transition will be,
       * and the faster it will slow down.
       * Recommended value from 10 to 50
       */
      constructor(initialVelocity, dampingRatio, naturalFrequency) {
        this.velocity = initialVelocity * 1000; // convert to "pixels per second"

        // https://en.wikipedia.org/wiki/Damping_ratio
        this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO;

        // https://en.wikipedia.org/wiki/Natural_frequency
        this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;

        if (this._dampingRatio < 1) {
          this._dampedFrequency = this._naturalFrequency
                             * Math.sqrt(1 - this._dampingRatio * this._dampingRatio);
        }
      }

      /**
       * @param {number} deltaPosition Difference between current and end position of the animation
       * @param {number} deltaTime Frame duration in milliseconds
       *
       * @returns {number} Displacement, relative to the end position.
       */
      easeFrame(deltaPosition, deltaTime) {
        // Inspired by Apple Webkit and Android spring function implementation
        // https://en.wikipedia.org/wiki/Oscillation
        // https://en.wikipedia.org/wiki/Damping_ratio
        // we ignore mass (assume that it's 1kg)

        let displacement = 0;
        let coeff;

        deltaTime /= 1000;

        const naturalDumpingPow = Math.E ** (-this._dampingRatio * this._naturalFrequency * deltaTime);

        if (this._dampingRatio === 1) {
          coeff = this.velocity + this._naturalFrequency * deltaPosition;

          displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;

          this.velocity = displacement
                            * (-this._naturalFrequency) + coeff
                            * naturalDumpingPow;
        } else if (this._dampingRatio < 1) {
          coeff = (1 / this._dampedFrequency)
                    * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);

          const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);
          const dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);

          displacement = naturalDumpingPow
                           * (deltaPosition * dumpedFCos + coeff * dumpedFSin);

          this.velocity = displacement
                            * (-this._naturalFrequency)
                            * this._dampingRatio
                            + naturalDumpingPow
                            * (-this._dampedFrequency * deltaPosition * dumpedFSin
                            + this._dampedFrequency * coeff * dumpedFCos);
        }

        // Overdamped (>1) damping ratio is not supported

        return displacement;
      }
    }

    /** @typedef {import('./animations.js').AnimationProps} AnimationProps */

    class SpringAnimation {
      /**
       * @param {AnimationProps} props
       */
      constructor(props) {
        this.props = props;

        const {
          start,
          end,
          velocity,
          onUpdate,
          onComplete,
          onFinish,
          dampingRatio,
          naturalFrequency
        } = props;

        /** @type {() => void} */
        this.onFinish = onFinish;

        const easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
        let prevTime = Date.now();
        let deltaPosition = start - end;

        const animationLoop = () => {
          if (this._raf) {
            deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime);

            // Stop the animation if velocity is low and position is close to end
            if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {
              // Finalize the animation
              onUpdate(end);
              if (onComplete) {
                onComplete();
              }
              this.onFinish();
            } else {
              prevTime = Date.now();
              onUpdate(deltaPosition + end);
              this._raf = requestAnimationFrame(animationLoop);
            }
          }
        };

        this._raf = requestAnimationFrame(animationLoop);
      }

      // Destroy is called automatically onFinish
      destroy() {
        if (this._raf >= 0) {
          cancelAnimationFrame(this._raf);
        }
        this._raf = null;
      }
    }

    /** @typedef {SpringAnimation | CSSAnimation} Animation */

    /**
     * @typedef {Object} AnimationProps
     *
     * @prop {HTMLElement=} target
     *
     * @prop {string=} name
     *
     * @prop {number=} start
     * @prop {number=} end
     * @prop {number=} duration
     * @prop {number=} velocity
     * @prop {number=} dampingRatio
     * @prop {number=} naturalFrequency
     *
     * @prop {(end: number) => void} [onUpdate]
     * @prop {() => void} [onComplete]
     * @prop {() => void} [onFinish]
     *
     * @prop {string=} transform
     * @prop {string=} opacity
     * @prop {string=} easing
     *
     * @prop {boolean=} isPan
     * @prop {boolean=} isMainScroll
     */

    /**
     * Manages animations
     */
    class Animations {
      constructor() {
        /** @type {Animation[]} */
        this.activeAnimations = [];
      }

      /**
       * @param {AnimationProps} props
       */
      startSpring(props) {
        this._start(props, true);
      }

      /**
       * @param {AnimationProps} props
       */
      startTransition(props) {
        this._start(props);
      }

      /**
       * @param {AnimationProps} props
       * @param {boolean=} isSpring
       */
      _start(props, isSpring) {
        /** @type {Animation} */
        let animation;
        if (isSpring) {
          animation = new SpringAnimation(props);
        } else {
          animation = new CSSAnimation(props);
        }

        this.activeAnimations.push(animation);
        animation.onFinish = () => this.stop(animation);

        return animation;
      }

      /**
       * @param {Animation} animation
       */
      stop(animation) {
        animation.destroy();
        const index = this.activeAnimations.indexOf(animation);
        if (index > -1) {
          this.activeAnimations.splice(index, 1);
        }
      }

      stopAll() { // _stopAllAnimations
        this.activeAnimations.forEach((animation) => {
          animation.destroy();
        });
        this.activeAnimations = [];
      }

      /**
       * Stop all pan or zoom transitions
       */
      stopAllPan() {
        this.activeAnimations = this.activeAnimations.filter((animation) => {
          if (animation.props.isPan) {
            animation.destroy();
            return false;
          }

          return true;
        });
      }

      stopMainScroll() {
        this.activeAnimations = this.activeAnimations.filter((animation) => {
          if (animation.props.isMainScroll) {
            animation.destroy();
            return false;
          }

          return true;
        });
      }

      /**
       * Returns true if main scroll transition is running
       */
      // isMainScrollRunning() {
      //   return this.activeAnimations.some((animation) => {
      //     return animation.props.isMainScroll;
      //   });
      // }

      /**
       * Returns true if any pan or zoom transition is running
       */
      isPanRunning() {
        return this.activeAnimations.some((animation) => {
          return animation.props.isPan;
        });
      }
    }

    /** @typedef {import('./photoswipe.js').default} PhotoSwipe */

    /**
     * Handles scroll wheel.
     * Can pan and zoom current slide image.
     */
    class ScrollWheel {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;
        pswp.events.add(pswp.element, 'wheel', this._onWheel.bind(this));
      }

      /**
       * @private
       * @param {WheelEvent} e
       */
      _onWheel(e) {
        e.preventDefault();
        const { currSlide } = this.pswp;
        let { deltaX, deltaY } = e;

        if (!currSlide) {
          return;
        }

        if (this.pswp.dispatch('wheel', { originalEvent: e }).defaultPrevented) {
          return;
        }

        if (e.ctrlKey || this.pswp.options.wheelToZoom) {
          // zoom
          if (currSlide.isZoomable()) {
            let zoomFactor = -deltaY;
            if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
              zoomFactor *= 0.05;
            } else {
              zoomFactor *= e.deltaMode ? 1 : 0.002;
            }
            zoomFactor = 2 ** zoomFactor;

            const destZoomLevel = currSlide.currZoomLevel * zoomFactor;
            currSlide.zoomTo(destZoomLevel, {
              x: e.clientX,
              y: e.clientY
            });
          }
        } else {
          // pan
          if (currSlide.isPannable()) {
            if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
              // 18 - average line height
              deltaX *= 18;
              deltaY *= 18;
            }

            currSlide.panTo(
              currSlide.pan.x - deltaX,
              currSlide.pan.y - deltaY
            );
          }
        }
      }
    }

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */

    /**
     * @template T
     * @typedef {import('../types.js').Methods<T>} Methods<T>
     */

    /**
     * @typedef {Object} UIElementMarkupProps
     * @prop {boolean=} isCustomSVG
     * @prop {string} inner
     * @prop {string=} outlineID
     * @prop {number | string} [size]
     */

    /**
     * @typedef {Object} UIElementData
     * @prop {DefaultUIElements | string} [name]
     * @prop {string=} className
     * @prop {UIElementMarkup=} html
     * @prop {boolean=} isButton
     * @prop {keyof HTMLElementTagNameMap} [tagName]
     * @prop {string=} title
     * @prop {string=} ariaLabel
     * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]
     * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]
     * @prop {'bar' | 'wrapper' | 'root'} [appendTo]
     * @prop {number=} order
     */

    /** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */

    /** @typedef {string | UIElementMarkupProps} UIElementMarkup */

    /**
     * @param {UIElementMarkup} [htmlData]
     */
    function addElementHTML(htmlData) {
      if (typeof htmlData === 'string') {
        // Allow developers to provide full svg,
        // For example:
        // <svg viewBox="0 0 32 32" width="32" height="32" aria-hidden="true" class="pswp__icn">
        //   <path d="..." />
        //   <circle ... />
        // </svg>
        // Can also be any HTML string.
        return htmlData;
      }

      if (!htmlData || !htmlData.isCustomSVG) {
        return '';
      }

      const svgData = htmlData;
      let out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
      // replace all %d with size
      out = out.split('%d').join(/** @type {string} */ (svgData.size || 32));

      // Icons may contain outline/shadow,
      // to make it we "clone" base icon shape and add border to it.
      // Icon itself and border are styled via CSS.
      //
      // Property shadowID defines ID of element that should be cloned.
      if (svgData.outlineID) {
        out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>';
      }

      out += svgData.inner;

      out += '</svg>';

      return out;
    }

    class UIElement {
      /**
       * @param {PhotoSwipe} pswp
       * @param {UIElementData} data
       */
      constructor(pswp, data) {
        const name = data.name || data.className;
        let elementHTML = data.html;

        // @ts-expect-error lookup only by `data.name` maybe?
        if (pswp.options[name] === false) {
          // exit if element is disabled from options
          return;
        }

        // Allow to override SVG icons from options
        // @ts-expect-error lookup only by `data.name` maybe?
        if (typeof pswp.options[name + 'SVG'] === 'string') {
          // arrowPrevSVG
          // arrowNextSVG
          // closeSVG
          // zoomSVG
          // @ts-expect-error lookup only by `data.name` maybe?
          elementHTML = pswp.options[name + 'SVG'];
        }

        pswp.dispatch('uiElementCreate', { data });

        let className = '';
        if (data.isButton) {
          className += 'pswp__button ';
          className += (data.className || `pswp__button--${data.name}`);
        } else {
          className += (data.className || `pswp__${data.name}`);
        }

        /** @type {HTMLElement} */
        let element;
        let tagName = data.isButton ? (data.tagName || 'button') : (data.tagName || 'div');
        tagName = /** @type {keyof HTMLElementTagNameMap} */ (tagName.toLowerCase());
        element = createElement(className, tagName);

        if (data.isButton) {
          // create button element
          element = createElement(className, tagName);
          if (tagName === 'button') {
            /** @type {HTMLButtonElement} */ (element).type = 'button';
          }

          let { title } = data;
          const { ariaLabel } = data;

          // @ts-expect-error lookup only by `data.name` maybe?
          if (typeof pswp.options[name + 'Title'] === 'string') {
            // @ts-expect-error lookup only by `data.name` maybe?
            title = pswp.options[name + 'Title'];
          }

          if (title) {
            element.title = title;
          }

          if (ariaLabel || title) {
            /** @type {HTMLElement} */ (element).setAttribute('aria-label', ariaLabel || title);
          }
        }

        element.innerHTML = addElementHTML(elementHTML);

        if (data.onInit) {
          data.onInit(element, pswp);
        }

        if (data.onClick) {
          element.onclick = (e) => {
            if (typeof data.onClick === 'string') {
              pswp[data.onClick]();
            } else {
              data.onClick(e, element, pswp);
            }
          };
        }

        // Top bar is default position
        const appendTo = data.appendTo || 'bar';
        let container;
        if (appendTo === 'bar') {
          if (!pswp.topBar) {
            pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);
          }
          container = pswp.topBar;
        } else {
          // element outside of top bar gets a secondary class
          // that makes element fade out on close
          element.classList.add('pswp__hide-on-close');

          if (appendTo === 'wrapper') {
            container = pswp.scrollWrap;
          } else {
            // root element
            container = pswp.element;
          }
        }

        container.appendChild(pswp.applyFilters('uiElement', element, data));
      }
    }

    /*
      Backward and forward arrow buttons
     */

    /** @typedef {import('./ui-element.js').UIElementData} UIElementData */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */

    /**
     *
     * @param {HTMLElement} element
     * @param {PhotoSwipe} pswp
     * @param {boolean=} isNextButton
     */
    function initArrowButton(element, pswp, isNextButton) {
      element.classList.add('pswp__button--arrow');
      // TODO: this should point to a unique id for this instance
      element.setAttribute('aria-controls', 'pswp__items');
      pswp.on('change', () => {
        if (!pswp.options.loop) {
          if (isNextButton) {
            /** @type {HTMLButtonElement} */
            (element).disabled = !(pswp.currIndex < pswp.getNumItems() - 1);
          } else {
            /** @type {HTMLButtonElement} */
            (element).disabled = !(pswp.currIndex > 0);
          }
        }
      });
    }

    /** @type {UIElementData} */
    const arrowPrev = {
      name: 'arrowPrev',
      className: 'pswp__button--arrow--prev',
      title: 'Previous',
      order: 10,
      isButton: true,
      appendTo: 'wrapper',
      html: {
        isCustomSVG: true,
        size: 60,
        inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
        outlineID: 'pswp__icn-arrow'
      },
      onClick: 'prev',
      onInit: initArrowButton
    };

    /** @type {UIElementData} */
    const arrowNext = {
      name: 'arrowNext',
      className: 'pswp__button--arrow--next',
      title: 'Next',
      order: 11,
      isButton: true,
      appendTo: 'wrapper',
      html: {
        isCustomSVG: true,
        size: 60,
        inner: '<use xlink:href="#pswp__icn-arrow"/>',
        outlineID: 'pswp__icn-arrow'
      },
      onClick: 'next',
      onInit: (el, pswp) => {
        initArrowButton(el, pswp, true);
      }
    };

    /** @type {import('./ui-element.js').UIElementData} UIElementData */
    const closeButton = {
      name: 'close',
      title: 'Close',
      order: 20,
      isButton: true,
      html: {
        isCustomSVG: true,
        inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
        outlineID: 'pswp__icn-close'
      },
      onClick: 'close'
    };

    /** @type {import('./ui-element.js').UIElementData} UIElementData */
    const zoomButton = {
      name: 'zoom',
      title: 'Zoom',
      order: 10,
      isButton: true,
      html: {
        isCustomSVG: true,
        // eslint-disable-next-line max-len
        inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/>'
              + '<path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/>'
              + '<path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
        outlineID: 'pswp__icn-zoom'
      },
      onClick: 'toggleZoom'
    };

    /** @type {import('./ui-element.js').UIElementData} UIElementData */
    const loadingIndicator = {
      name: 'preloader',
      appendTo: 'bar',
      order: 7,
      html: {
        isCustomSVG: true,
        // eslint-disable-next-line max-len
        inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
        outlineID: 'pswp__icn-loading'
      },
      onInit: (indicatorElement, pswp) => {
        /** @type {boolean} */
        let isVisible;
        /** @type {NodeJS.Timeout} */
        let delayTimeout;

        /**
         * @param {string} className
         * @param {boolean} add
         */
        const toggleIndicatorClass = (className, add) => {
          indicatorElement.classList[add ? 'add' : 'remove']('pswp__preloader--' + className);
        };

        /**
         * @param {boolean} visible
         */
        const setIndicatorVisibility = (visible) => {
          if (isVisible !== visible) {
            isVisible = visible;
            toggleIndicatorClass('active', visible);
          }
        };

        const updatePreloaderVisibility = () => {
          if (!pswp.currSlide.content.isLoading()) {
            setIndicatorVisibility(false);
            if (delayTimeout) {
              clearTimeout(delayTimeout);
              delayTimeout = null;
            }
            return;
          }

          if (!delayTimeout) {
            // display loading indicator with delay
            delayTimeout = setTimeout(() => {
              setIndicatorVisibility(pswp.currSlide.content.isLoading());
              delayTimeout = null;
            }, pswp.options.preloaderDelay);
          }
        };

        pswp.on('change', updatePreloaderVisibility);

        pswp.on('loadComplete', (e) => {
          if (pswp.currSlide === e.slide) {
            updatePreloaderVisibility();
          }
        });

        // expose the method
        pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;
      }
    };

    /** @type {import('./ui-element.js').UIElementData} UIElementData */
    const counterIndicator = {
      name: 'counter',
      order: 5,
      onInit: (counterElement, pswp) => {
        pswp.on('change', () => {
          counterElement.innerText = (pswp.currIndex + 1)
                                      + pswp.options.indexIndicatorSep
                                      + pswp.getNumItems();
        });
      }
    };

    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('./ui-element.js').UIElementData} UIElementData */

    /**
     * Set special class on element when image is zoomed.
     *
     * By default it is used to adjust
     * zoom icon and zoom cursor via CSS.
     *
     * @param {HTMLElement} el
     * @param {boolean} isZoomedIn
     */
    function setZoomedIn(el, isZoomedIn) {
      el.classList[isZoomedIn ? 'add' : 'remove']('pswp--zoomed-in');
    }

    class UI {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;

        /** @type {() => void} */
        this.updatePreloaderVisibility = undefined;

        /** @type {number} */
        this._lastUpdatedZoomLevel = undefined;
      }

      init() {
        const { pswp } = this;
        this.isRegistered = false;
        /** @type {UIElementData[]} */
        this.uiElementsData = [
          closeButton,
          arrowPrev,
          arrowNext,
          zoomButton,
          loadingIndicator,
          counterIndicator
        ];

        pswp.dispatch('uiRegister');

        // sort by order
        this.uiElementsData.sort((a, b) => {
          // default order is 0
          return (a.order || 0) - (b.order || 0);
        });

        /** @type {(UIElement | UIElementData)[]} */
        this.items = [];

        this.isRegistered = true;
        this.uiElementsData.forEach((uiElementData) => {
          this.registerElement(uiElementData);
        });

        pswp.on('change', () => {
          pswp.element.classList[pswp.getNumItems() === 1 ? 'add' : 'remove']('pswp--one-slide');
        });

        pswp.on('zoomPanUpdate', () => this._onZoomPanUpdate());
      }

      /**
       * @param {UIElementData} elementData
       */
      registerElement(elementData) {
        if (this.isRegistered) {
          this.items.push(
            new UIElement(this.pswp, elementData)
          );
        } else {
          this.uiElementsData.push(elementData);
        }
      }

      /**
       * Fired each time zoom or pan position is changed.
       * Update classes that control visibility of zoom button and cursor icon.
       */
      _onZoomPanUpdate() {
        const { template, currSlide, options } = this.pswp;
        let { currZoomLevel } = currSlide;

        if (this.pswp.opener.isClosing) {
          return;
        }

        // if not open yet - check against initial zoom level
        if (!this.pswp.opener.isOpen) {
          currZoomLevel = currSlide.zoomLevels.initial;
        }

        if (currZoomLevel === this._lastUpdatedZoomLevel) {
          return;
        }
        this._lastUpdatedZoomLevel = currZoomLevel;

        const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary;

        // Initial and secondary zoom levels are almost equal
        if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {
          // disable zoom
          setZoomedIn(template, false);
          template.classList.remove('pswp--zoom-allowed');
          return;
        }

        template.classList.add('pswp--zoom-allowed');

        const potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial
          ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;

        setZoomedIn(template, potentialZoomLevel <= currZoomLevel);

        if (options.imageClickAction === 'zoom'
            || options.imageClickAction === 'zoom-or-close') {
          template.classList.add('pswp--click-to-zoom');
        }
      }
    }

    /** @typedef {import('./slide.js').SlideData} SlideData */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */

    /** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */

    /**
     * @param {HTMLElement} el
     */
    function getBoundsByElement(el) {
      const thumbAreaRect = el.getBoundingClientRect();
      return {
        x: thumbAreaRect.left,
        y: thumbAreaRect.top,
        w: thumbAreaRect.width
      };
    }

    /**
     * @param {HTMLElement} el
     * @param {number} imageWidth
     * @param {number} imageHeight
     */
    function getCroppedBoundsByElement(el, imageWidth, imageHeight) {
      const thumbAreaRect = el.getBoundingClientRect();

      // fill image into the area
      // (do they same as object-fit:cover does to retrieve coordinates)
      const hRatio = thumbAreaRect.width / imageWidth;
      const vRatio = thumbAreaRect.height / imageHeight;
      const fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;

      const offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;
      const offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;

      /**
       * Coordinates of the image,
       * as if it was not cropped,
       * height is calculated automatically
       *
       * @type {Bounds}
       */
      const bounds = {
        x: thumbAreaRect.left + offsetX,
        y: thumbAreaRect.top + offsetY,
        w: imageWidth * fillZoomLevel
      };

      // Coordinates of inner crop area
      // relative to the image
      bounds.innerRect = {
        w: thumbAreaRect.width,
        h: thumbAreaRect.height,
        x: offsetX,
        y: offsetY
      };

      return bounds;
    }

    /**
     * Get dimensions of thumbnail image
     * (click on which opens photoswipe or closes photoswipe to)
     *
     * @param {number} index
     * @param {SlideData} itemData
     * @param {PhotoSwipe} instance PhotoSwipe instance
     * @returns {Bounds | undefined}
     */
    function getThumbBounds(index, itemData, instance) {
      // legacy event, before filters were introduced
      const event = instance.dispatch('thumbBounds', {
        index,
        itemData,
        instance
      });
      // @ts-expect-error
      if (event.thumbBounds) {
        // @ts-expect-error
        return event.thumbBounds;
      }

      const { element } = itemData;
      let thumbBounds;
      /** @type {HTMLElement} */
      let thumbnail;

      if (element && instance.options.thumbSelector !== false) {
        const thumbSelector = instance.options.thumbSelector || 'img';
        thumbnail = element.matches(thumbSelector)
          ? element : element.querySelector(thumbSelector);
      }

      thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);

      if (thumbnail) {
        if (!itemData.thumbCropped) {
          thumbBounds = getBoundsByElement(thumbnail);
        } else {
          thumbBounds = getCroppedBoundsByElement(
            thumbnail,
            itemData.width || itemData.w,
            itemData.height || itemData.h
          );
        }
      }

      return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);
    }

    /** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import('../photoswipe.js').DataSource} DataSource */
    /** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */
    /** @typedef {import('../slide/content.js').default} ContentDefault */
    /** @typedef {import('../slide/slide.js').default} Slide */
    /** @typedef {import('../slide/slide.js').SlideData} SlideData */
    /** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */
    /** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

    /**
     * Allow adding an arbitrary props to the Content
     * https://photoswipe.com/custom-content/#using-webp-image-format
     * @typedef {ContentDefault & Record<string, any>} Content
     */
    /** @typedef {{ x?: number; y?: number }} Point */

    /**
     * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
     *
     *
     * https://photoswipe.com/adding-ui-elements/
     *
     * @prop {undefined} uiRegister
     * @prop {{ data: UIElementData }} uiElementCreate
     *
     *
     * https://photoswipe.com/events/#initialization-events
     *
     * @prop {undefined} beforeOpen
     * @prop {undefined} firstUpdate
     * @prop {undefined} initialLayout
     * @prop {undefined} change
     * @prop {undefined} afterInit
     * @prop {undefined} bindEvents
     *
     *
     * https://photoswipe.com/events/#opening-or-closing-transition-events
     *
     * @prop {undefined} openingAnimationStart
     * @prop {undefined} openingAnimationEnd
     * @prop {undefined} closingAnimationStart
     * @prop {undefined} closingAnimationEnd
     *
     *
     * https://photoswipe.com/events/#closing-events
     *
     * @prop {undefined} close
     * @prop {undefined} destroy
     *
     *
     * https://photoswipe.com/events/#pointer-and-gesture-events
     *
     * @prop {{ originalEvent: PointerEvent }} pointerDown
     * @prop {{ originalEvent: PointerEvent }} pointerMove
     * @prop {{ originalEvent: PointerEvent }} pointerUp
     * @prop {{ bgOpacity: number }} pinchClose can be default prevented
     * @prop {{ panY: number }} verticalDrag can be default prevented
     *
     *
     * https://photoswipe.com/events/#slide-content-events
     *
     * @prop {{ content: Content }} contentInit
     * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
     * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
     * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
     * @prop {{ content: Content; slide: Slide }} loadError
     * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
     * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
     * @prop {{ content: Content }} contentLazyLoad can be default prevented
     * @prop {{ content: Content }} contentAppend can be default prevented
     * @prop {{ content: Content }} contentActivate can be default prevented
     * @prop {{ content: Content }} contentDeactivate can be default prevented
     * @prop {{ content: Content }} contentRemove can be default prevented
     * @prop {{ content: Content }} contentDestroy can be default prevented
     *
     *
     * undocumented
     *
     * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
     * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
     * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
     * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
     *
     * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
     * @prop {{ x: number; dragging: boolean }} moveMainScroll
     * @prop {{ slide: Slide }} firstZoomPan
     * @prop {{ slide: Slide, data: SlideData, index: number }} gettingData
     * @prop {undefined} beforeResize
     * @prop {undefined} resize
     * @prop {undefined} viewportSize
     * @prop {undefined} updateScrollOffset
     * @prop {{ slide: Slide }} slideInit
     * @prop {{ slide: Slide }} afterSetContent
     * @prop {{ slide: Slide }} slideLoad
     * @prop {{ slide: Slide }} appendHeavy can be default prevented
     * @prop {{ slide: Slide }} appendHeavyContent
     * @prop {{ slide: Slide }} slideActivate
     * @prop {{ slide: Slide }} slideDeactivate
     * @prop {{ slide: Slide }} slideDestroy
     * @prop {{ destZoomLevel: number, centerPoint: Point, transitionDuration: number | false }} beforeZoomTo
     * @prop {{ slide: Slide }} zoomPanUpdate
     * @prop {{ slide: Slide }} initialZoomPan
     * @prop {{ slide: Slide }} calcSlideSize
     * @prop {undefined} resolutionChanged
     * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
     * @prop {{ content: Content }} contentAppendImage can be default prevented
     * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
     * @prop {undefined} lazyLoad
     * @prop {{ slide: Slide }} calcBounds
     * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
     *
     *
     * legacy
     *
     * @prop {undefined} init
     * @prop {undefined} initialZoomIn
     * @prop {undefined} initialZoomOut
     * @prop {undefined} initialZoomInEnd
     * @prop {undefined} initialZoomOutEnd
     * @prop {{ dataSource: DataSource, numItems: number }} numItems
     * @prop {{ itemData: SlideData; index: number }} itemData
     * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
     */

    /**
     * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
     *
     * @prop {(numItems: number, dataSource: DataSource) => number} numItems
     * Modify the total amount of slides. Example on Data sources page.
     * https://photoswipe.com/filters/#numitems
     *
     * @prop {(itemData: SlideData, index: number) => SlideData} itemData
     * Modify slide item data. Example on Data sources page.
     * https://photoswipe.com/filters/#itemdata
     *
     * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
     * Modify item data when it's parsed from DOM element. Example on Data sources page.
     * https://photoswipe.com/filters/#domitemdata
     *
     * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
     * Modify clicked gallery item index.
     * https://photoswipe.com/filters/#clickedindex
     *
     * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
     * Modify placeholder image source.
     * https://photoswipe.com/filters/#placeholdersrc
     *
     * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
     * Modify if the content is currently loading.
     * https://photoswipe.com/filters/#iscontentloading
     *
     * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
     * Modify if the content can be zoomed.
     * https://photoswipe.com/filters/#iscontentzoomable
     *
     * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
     * Modify if the placeholder should be used for the content.
     * https://photoswipe.com/filters/#usecontentplaceholder
     *
     * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
     * Modify if the placeholder should be kept after the content is loaded.
     * https://photoswipe.com/filters/#iskeepingplaceholder
     *
     *
     * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
     * Modify an element when the content has error state (for example, if image cannot be loaded).
     * https://photoswipe.com/filters/#contenterrorelement
     *
     * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
     * Modify a UI element that's being created.
     * https://photoswipe.com/filters/#uielement
     *
     * @prop {(thumbnail: HTMLElement, itemData: SlideData, index: number) => HTMLElement} thumbEl
     * Modify the thubmnail element from which opening zoom animation starts or ends.
     * https://photoswipe.com/filters/#thumbel
     *
     * @prop {(thumbBounds: Bounds, itemData: SlideData, index: number) => Bounds} thumbBounds
     * Modify the thubmnail bounds from which opening zoom animation starts or ends.
     * https://photoswipe.com/filters/#thumbbounds
     *
     * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
     *
     */

    /**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter<T>
     */

    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
     */

    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @typedef {(event: AugmentedEvent<T>) => void} EventCallback<T>
     */

    /**
     * Base PhotoSwipe event object
     *
     * @template {keyof PhotoSwipeEventsMap} T
     */
    class PhotoSwipeEvent {
      /**
       * @param {T} type
       * @param {PhotoSwipeEventsMap[T]} [details]
       */
      constructor(type, details) {
        this.type = type;
        if (details) {
          Object.assign(this, details);
        }
      }

      preventDefault() {
        this.defaultPrevented = true;
      }
    }

    /**
     * PhotoSwipe base class that can listen and dispatch for events.
     * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
     */
    class Eventable {
      constructor() {
        /**
         * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
         */
        this._listeners = {};

        /**
         * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
         */
        this._filters = {};

        /** @type {PhotoSwipe=} */
        this.pswp = undefined;

        /** @type {PhotoSwipeOptions} */
        this.options = undefined;
      }

      /**
       * @template {keyof PhotoSwipeFiltersMap} T
       * @param {T} name
       * @param {PhotoSwipeFiltersMap[T]} fn
       * @param {number} priority
       */
      addFilter(name, fn, priority = 100) {
        if (!this._filters[name]) {
          this._filters[name] = [];
        }

        this._filters[name].push({ fn, priority });
        this._filters[name].sort((f1, f2) => f1.priority - f2.priority);

        if (this.pswp) {
          this.pswp.addFilter(name, fn, priority);
        }
      }

      /**
       * @template {keyof PhotoSwipeFiltersMap} T
       * @param {T} name
       * @param {PhotoSwipeFiltersMap[T]} fn
       */
      removeFilter(name, fn) {
        if (this._filters[name]) {
          // @ts-expect-error
          this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));
        }

        if (this.pswp) {
          this.pswp.removeFilter(name, fn);
        }
      }

      /**
       * @template {keyof PhotoSwipeFiltersMap} T
       * @param {T} name
       * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
       * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
       */
      applyFilters(name, ...args) {
        if (this._filters[name]) {
          this._filters[name].forEach((filter) => {
            // @ts-expect-error
            args[0] = filter.fn.apply(this, args);
          });
        }
        return args[0];
      }

      /**
       * @template {keyof PhotoSwipeEventsMap} T
       * @param {T} name
       * @param {EventCallback<T>} fn
       */
      on(name, fn) {
        if (!this._listeners[name]) {
          this._listeners[name] = [];
        }
        this._listeners[name].push(fn);

        // When binding events to lightbox,
        // also bind events to PhotoSwipe Core,
        // if it's open.
        if (this.pswp) {
          this.pswp.on(name, fn);
        }
      }

      /**
       * @template {keyof PhotoSwipeEventsMap} T
       * @param {T} name
       * @param {EventCallback<T>} fn
       */
      off(name, fn) {
        if (this._listeners[name]) {
          // @ts-expect-error
          this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));
        }

        if (this.pswp) {
          this.pswp.off(name, fn);
        }
      }

      /**
       * @template {keyof PhotoSwipeEventsMap} T
       * @param {T} name
       * @param {PhotoSwipeEventsMap[T]} [details]
       * @returns {AugmentedEvent<T>}
       */
      dispatch(name, details) {
        if (this.pswp) {
          return this.pswp.dispatch(name, details);
        }

        const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent(name, details));

        if (!this._listeners) {
          return event;
        }

        if (this._listeners[name]) {
          this._listeners[name].forEach((listener) => {
            listener.call(this, event);
          });
        }

        return event;
      }
    }

    class Placeholder {
      /**
       * @param {string | false} imageSrc
       * @param {HTMLElement} container
       */
      constructor(imageSrc, container) {
        // Create placeholder
        // (stretched thumbnail or simple div behind the main image)
        this.element = createElement(
          'pswp__img pswp__img--placeholder',
          imageSrc ? 'img' : '',
          container
        );

        if (imageSrc) {
          /** @type {HTMLImageElement} */
          (this.element).decoding = 'async';
          /** @type {HTMLImageElement} */
          (this.element).alt = '';
          /** @type {HTMLImageElement} */
          (this.element).src = imageSrc;
          this.element.setAttribute('role', 'presentation');
        }

        this.element.setAttribute('aria-hidden', 'true');
      }

      /**
       * @param {number} width
       * @param {number} height
       */
      setDisplayedSize(width, height) {
        if (!this.element) {
          return;
        }

        if (this.element.tagName === 'IMG') {
          // Use transform scale() to modify img placeholder size
          // (instead of changing width/height directly).
          // This helps with performance, specifically in iOS15 Safari.
          setWidthHeight(this.element, 250, 'auto');
          this.element.style.transformOrigin = '0 0';
          this.element.style.transform = toTransformString(0, 0, width / 250);
        } else {
          setWidthHeight(this.element, width, height);
        }
      }

      destroy() {
        if (this.element.parentNode) {
          this.element.remove();
        }
        this.element = null;
      }
    }

    /** @typedef {import('./slide.js').default} Slide */
    /** @typedef {import('./slide.js').SlideData} SlideData */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../util/util.js').LoadState} LoadState */

    class Content {
      /**
       * @param {SlideData} itemData Slide data
       * @param {PhotoSwipe} instance PhotoSwipe or PhotoSwipeLightbox instance
       * @param {number} index
       */
      constructor(itemData, instance, index) {
        this.instance = instance;
        this.data = itemData;
        this.index = index;

        /** @type {HTMLImageElement | HTMLDivElement} */
        this.element = undefined;

        this.displayedImageWidth = 0;
        this.displayedImageHeight = 0;

        this.width = Number(this.data.w) || Number(this.data.width) || 0;
        this.height = Number(this.data.h) || Number(this.data.height) || 0;

        this.isAttached = false;
        this.hasSlide = false;
        /** @type {LoadState} */
        this.state = LOAD_STATE.IDLE;

        if (this.data.type) {
          this.type = this.data.type;
        } else if (this.data.src) {
          this.type = 'image';
        } else {
          this.type = 'html';
        }

        this.instance.dispatch('contentInit', { content: this });
      }

      removePlaceholder() {
        if (this.placeholder && !this.keepPlaceholder()) {
          // With delay, as image might be loaded, but not rendered
          setTimeout(() => {
            if (this.placeholder) {
              this.placeholder.destroy();
              this.placeholder = null;
            }
          }, 1000);
        }
      }

      /**
       * Preload content
       *
       * @param {boolean=} isLazy
       * @param {boolean=} reload
       */
      load(isLazy, reload) {
        if (this.slide && this.usePlaceholder()) {
          if (!this.placeholder) {
            const placeholderSrc = this.instance.applyFilters(
              'placeholderSrc',
              // use  image-based placeholder only for the first slide,
              // as rendering (even small stretched thumbnail) is an expensive operation
              (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,
              this
            );
            this.placeholder = new Placeholder(
              placeholderSrc,
              this.slide.container
            );
          } else {
            const placeholderEl = this.placeholder.element;
            // Add placeholder to DOM if it was already created
            if (placeholderEl && !placeholderEl.parentElement) {
              this.slide.container.prepend(placeholderEl);
            }
          }
        }

        if (this.element && !reload) {
          return;
        }

        if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {
          return;
        }

        if (this.isImageContent()) {
          this.element = createElement('pswp__img', 'img');
          // Start loading only after width is defined, as sizes might depend on it.
          // Due to Safari feature, we must define sizes before srcset.
          if (this.displayedImageWidth) {
            this.loadImage(isLazy);
          }
        } else {
          this.element = createElement('pswp__content');
          this.element.innerHTML = this.data.html || '';
        }

        if (reload && this.slide) {
          this.slide.updateContentSize(true);
        }
      }

      /**
       * Preload image
       *
       * @param {boolean} isLazy
       */
      loadImage(isLazy) {
        const imageElement = /** @type HTMLImageElement */ (this.element);

        if (this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {
          return;
        }

        this.updateSrcsetSizes();

        if (this.data.srcset) {
          imageElement.srcset = this.data.srcset;
        }

        imageElement.src = this.data.src;

        imageElement.alt = this.data.alt || '';

        this.state = LOAD_STATE.LOADING;

        if (imageElement.complete) {
          this.onLoaded();
        } else {
          imageElement.onload = () => {
            this.onLoaded();
          };

          imageElement.onerror = () => {
            this.onError();
          };
        }
      }

      /**
       * Assign slide to content
       *
       * @param {Slide} slide
       */
      setSlide(slide) {
        this.slide = slide;
        this.hasSlide = true;
        this.instance = slide.pswp;

        // todo: do we need to unset slide?
      }

      /**
       * Content load success handler
       */
      onLoaded() {
        this.state = LOAD_STATE.LOADED;

        if (this.slide) {
          this.instance.dispatch('loadComplete', { slide: this.slide, content: this });

          // if content is reloaded
          if (this.slide.isActive
              && this.slide.heavyAppended
              && !this.element.parentNode) {
            this.append();
            this.slide.updateContentSize(true);
          }

          if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
            this.removePlaceholder();
          }
        }
      }

      /**
       * Content load error handler
       */
      onError() {
        this.state = LOAD_STATE.ERROR;

        if (this.slide) {
          this.displayError();
          this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });
          this.instance.dispatch('loadError', { slide: this.slide, content: this });
        }
      }

      /**
       * @returns {Boolean} If the content is currently loading
       */
      isLoading() {
        return this.instance.applyFilters(
          'isContentLoading',
          this.state === LOAD_STATE.LOADING,
          this
        );
      }

      isError() {
        return this.state === LOAD_STATE.ERROR;
      }

      /**
       * @returns {boolean} If the content is image
       */
      isImageContent() {
        return this.type === 'image';
      }

      /**
       * Update content size
       *
       * @param {Number} width
       * @param {Number} height
       */
      setDisplayedSize(width, height) {
        if (!this.element) {
          return;
        }

        if (this.placeholder) {
          this.placeholder.setDisplayedSize(width, height);
        }

        // eslint-disable-next-line max-len
        if (this.instance.dispatch('contentResize', { content: this, width, height }).defaultPrevented) {
          return;
        }

        setWidthHeight(this.element, width, height);

        if (this.isImageContent() && !this.isError()) {
          const isInitialSizeUpdate = (!this.displayedImageWidth && width);

          this.displayedImageWidth = width;
          this.displayedImageHeight = height;

          if (isInitialSizeUpdate) {
            this.loadImage(false);
          } else {
            this.updateSrcsetSizes();
          }

          if (this.slide) {
            // eslint-disable-next-line max-len
            this.instance.dispatch('imageSizeChange', { slide: this.slide, width, height, content: this });
          }
        }
      }

      /**
       * @returns {boolean} If the content can be zoomed
       */
      isZoomable() {
        return this.instance.applyFilters(
          'isContentZoomable',
          this.isImageContent() && (this.state !== LOAD_STATE.ERROR),
          this
        );
      }

      /**
       * Update image srcset sizes attribute based on width and height
       */
      updateSrcsetSizes() {
        // Handle srcset sizes attribute.
        //
        // Never lower quality, if it was increased previously.
        // Chrome does this automatically, Firefox and Safari do not,
        // so we store largest used size in dataset.
        // Handle srcset sizes attribute.
        //
        // Never lower quality, if it was increased previously.
        // Chrome does this automatically, Firefox and Safari do not,
        // so we store largest used size in dataset.
        if (this.data.srcset) {
          const image = /** @type HTMLImageElement */ (this.element);
          const sizesWidth = this.instance.applyFilters(
            'srcsetSizesWidth',
            this.displayedImageWidth,
            this
          );

          if (!image.dataset.largestUsedSize
              || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {
            image.sizes = sizesWidth + 'px';
            image.dataset.largestUsedSize = String(sizesWidth);
          }
        }
      }

      /**
       * @returns {boolean} If content should use a placeholder (from msrc by default)
       */
      usePlaceholder() {
        return this.instance.applyFilters(
          'useContentPlaceholder',
          this.isImageContent(),
          this
        );
      }

      /**
       * Preload content with lazy-loading param
       */
      lazyLoad() {
        if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {
          return;
        }

        this.load(true);
      }

      /**
       * @returns {boolean} If placeholder should be kept after content is loaded
       */
      keepPlaceholder() {
        return this.instance.applyFilters(
          'isKeepingPlaceholder',
          this.isLoading(),
          this
        );
      }

      /**
       * Destroy the content
       */
      destroy() {
        this.hasSlide = false;
        this.slide = null;

        if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {
          return;
        }

        this.remove();

        if (this.placeholder) {
          this.placeholder.destroy();
          this.placeholder = null;
        }

        if (this.isImageContent() && this.element) {
          this.element.onload = null;
          this.element.onerror = null;
          this.element = null;
        }
      }

      /**
       * Display error message
       */
      displayError() {
        if (this.slide) {
          /** @type {HTMLElement} */
          let errorMsgEl = createElement('pswp__error-msg');
          errorMsgEl.innerText = this.instance.options.errorMsg;
          errorMsgEl = this.instance.applyFilters(
            'contentErrorElement',
            errorMsgEl,
            this
          );
          this.element = createElement('pswp__content pswp__error-msg-container');
          this.element.appendChild(errorMsgEl);
          this.slide.container.innerText = '';
          this.slide.container.appendChild(this.element);
          this.slide.updateContentSize(true);
          this.removePlaceholder();
        }
      }

      /**
       * Append the content
       */
      append() {
        if (this.isAttached) {
          return;
        }

        this.isAttached = true;

        if (this.state === LOAD_STATE.ERROR) {
          this.displayError();
          return;
        }

        if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {
          return;
        }

        const supportsDecode = ('decode' in this.element);

        if (this.isImageContent()) {
          // Use decode() on nearby slides
          //
          // Nearby slide images are in DOM and not hidden via display:none.
          // However, they are placed offscreen (to the left and right side).
          //
          // Some browsers do not composite the image until it's actually visible,
          // using decode() helps.
          //
          // You might ask "why dont you just decode() and then append all images",
          // that's because I want to show image before it's fully loaded,
          // as browser can render parts of image while it is loading.
          // We do not do this in Safari due to partial loading bug.
          if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {
            this.isDecoding = true;
            // purposefully using finally instead of then,
            // as if srcset sizes changes dynamically - it may cause decode error
            /** @type {HTMLImageElement} */
            (this.element).decode().catch(() => {}).finally(() => {
              this.isDecoding = false;
              this.appendImage();
            });
          } else {
            this.appendImage();
          }
        } else if (this.element && !this.element.parentNode) {
          this.slide.container.appendChild(this.element);
        }
      }

      /**
       * Activate the slide,
       * active slide is generally the current one,
       * meaning the user can see it.
       */
      activate() {
        if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented) {
          return;
        }

        if (this.slide) {
          if (this.isImageContent() && this.isDecoding && !isSafari()) {
            // add image to slide when it becomes active,
            // even if it's not finished decoding
            this.appendImage();
          } else if (this.isError()) {
            this.load(false, true); // try to reload
          }

          if (this.slide.holderElement) {
            this.slide.holderElement.setAttribute('aria-hidden', 'false');
          }
        }
      }

      /**
       * Deactivate the content
       */
      deactivate() {
        this.instance.dispatch('contentDeactivate', { content: this });
        if (this.slide && this.slide.holderElement) {
          this.slide.holderElement.setAttribute('aria-hidden', 'true');
        }
      }


      /**
       * Remove the content from DOM
       */
      remove() {
        this.isAttached = false;

        if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {
          return;
        }

        if (this.element && this.element.parentNode) {
          this.element.remove();
        }

        if (this.placeholder && this.placeholder.element) {
          this.placeholder.element.remove();
        }
      }

      /**
       * Append the image content to slide container
       */
      appendImage() {
        if (!this.isAttached) {
          return;
        }

        if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {
          return;
        }

        // ensure that element exists and is not already appended
        if (this.slide && this.element && !this.element.parentNode) {
          this.slide.container.appendChild(this.element);
        }

        if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
          this.removePlaceholder();
        }
      }
    }

    /** @typedef {import('./content.js').default} Content */
    /** @typedef {import('./slide.js').default} Slide */
    /** @typedef {import('./slide.js').SlideData} SlideData */
    /** @typedef {import('../core/base.js').default} PhotoSwipeBase */
    /** @typedef {import('../photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */

    const MIN_SLIDES_TO_CACHE = 5;

    /**
     * Lazy-load an image
     * This function is used both by Lightbox and PhotoSwipe core,
     * thus it can be called before dialog is opened.
     *
     * @param {SlideData} itemData Data about the slide
     * @param {PhotoSwipe | PhotoSwipeLightbox | PhotoSwipeBase} instance PhotoSwipe instance
     * @param {number} index
     * @returns Image that is being decoded or false.
     */
    function lazyLoadData(itemData, instance, index) {
      // src/slide/content/content.js
      const content = instance.createContentFromData(itemData, index);

      if (!content || !content.lazyLoad) {
        return;
      }

      const { options } = instance;

      // We need to know dimensions of the image to preload it,
      // as it might use srcset and we need to define sizes
      // @ts-expect-error should provide pswp instance?
      const viewportSize = instance.viewportSize || getViewportSize(options, instance);
      const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);

      const zoomLevel = new ZoomLevel(options, itemData, -1);
      zoomLevel.update(content.width, content.height, panAreaSize);

      content.lazyLoad();
      content.setDisplayedSize(
        Math.ceil(content.width * zoomLevel.initial),
        Math.ceil(content.height * zoomLevel.initial)
      );

      return content;
    }


    /**
     * Lazy-loads specific slide.
     * This function is used both by Lightbox and PhotoSwipe core,
     * thus it can be called before dialog is opened.
     *
     * By default it loads image based on viewport size and initial zoom level.
     *
     * @param {number} index Slide index
     * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
     */
    function lazyLoadSlide(index, instance) {
      const itemData = instance.getItemData(index);

      if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {
        return;
      }

      return lazyLoadData(itemData, instance, index);
    }


    class ContentLoader {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;
        // Total amount of cached images
        this.limit = Math.max(
          pswp.options.preload[0] + pswp.options.preload[1] + 1,
          MIN_SLIDES_TO_CACHE
        );
        /** @type {Content[]} */
        this._cachedItems = [];
      }

      /**
       * Lazy load nearby slides based on `preload` option.
       *
       * @param {number=} diff Difference between slide indexes that was changed recently, or 0.
       */
      updateLazy(diff) {
        const { pswp } = this;

        if (pswp.dispatch('lazyLoad').defaultPrevented) {
          return;
        }

        const { preload } = pswp.options;
        const isForward = diff === undefined ? true : (diff >= 0);
        let i;

        // preload[1] - num items to preload in forward direction
        for (i = 0; i <= preload[1]; i++) {
          this.loadSlideByIndex(pswp.currIndex + (isForward ? i : (-i)));
        }

        // preload[0] - num items to preload in backward direction
        for (i = 1; i <= preload[0]; i++) {
          this.loadSlideByIndex(pswp.currIndex + (isForward ? (-i) : i));
        }
      }

      /**
       * @param {number} index
       */
      loadSlideByIndex(index) {
        index = this.pswp.getLoopedIndex(index);
        // try to get cached content
        let content = this.getContentByIndex(index);
        if (!content) {
          // no cached content, so try to load from scratch:
          content = lazyLoadSlide(index, this.pswp);
          // if content can be loaded, add it to cache:
          if (content) {
            this.addToCache(content);
          }
        }
      }

      /**
       * @param {Slide} slide
       */
      getContentBySlide(slide) {
        let content = this.getContentByIndex(slide.index);
        if (!content) {
          // create content if not found in cache
          content = this.pswp.createContentFromData(slide.data, slide.index);
          if (content) {
            this.addToCache(content);
          }
        }

        if (content) {
          // assign slide to content
          content.setSlide(slide);
        }
        return content;
      }

      /**
       * @param {Content} content
       */
      addToCache(content) {
        // move to the end of array
        this.removeByIndex(content.index);
        this._cachedItems.push(content);

        if (this._cachedItems.length > this.limit) {
          // Destroy the first content that's not attached
          const indexToRemove = this._cachedItems.findIndex((item) => {
            return !item.isAttached && !item.hasSlide;
          });
          if (indexToRemove !== -1) {
            const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];
            removedItem.destroy();
          }
        }
      }

      /**
       * Removes an image from cache, does not destroy() it, just removes.
       *
       * @param {number} index
       */
      removeByIndex(index) {
        const indexToRemove = this._cachedItems.findIndex(item => item.index === index);
        if (indexToRemove !== -1) {
          this._cachedItems.splice(indexToRemove, 1);
        }
      }

      /**
       * @param {number} index
       */
      getContentByIndex(index) {
        return this._cachedItems.find(content => content.index === index);
      }

      destroy() {
        this._cachedItems.forEach(content => content.destroy());
        this._cachedItems = null;
      }
    }

    /** @typedef {import("../photoswipe.js").default} PhotoSwipe */
    /** @typedef {import("../photoswipe.js").PhotoSwipeOptions} PhotoSwipeOptions */
    /** @typedef {import("../slide/slide.js").SlideData} SlideData */

    /**
     * PhotoSwipe base class that can retrieve data about every slide.
     * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
     */
    class PhotoSwipeBase extends Eventable {
      /**
       * Get total number of slides
       *
       * @returns {number}
       */
      getNumItems() {
        let numItems;
        const { dataSource } = this.options;
        if (!dataSource) {
          numItems = 0;
        } else if ('length' in dataSource) {
          // may be an array or just object with length property
          numItems = dataSource.length;
        } else if ('gallery' in dataSource) {
          // query DOM elements
          if (!dataSource.items) {
            dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
          }

          if (dataSource.items) {
            numItems = dataSource.items.length;
          }
        }

        // legacy event, before filters were introduced
        const event = this.dispatch('numItems', {
          dataSource,
          numItems
        });
        return this.applyFilters('numItems', event.numItems, dataSource);
      }

      /**
       * @param {SlideData} slideData
       * @param {number} index
       */
      createContentFromData(slideData, index) {
        // @ts-expect-error
        return new Content(slideData, this, index);
      }

      /**
       * Get item data by index.
       *
       * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
       * For example, it may contain properties like
       * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
       *
       * @param {number} index
       */
      getItemData(index) {
        const { dataSource } = this.options;
        let dataSourceItem;
        if (Array.isArray(dataSource)) {
          // Datasource is an array of elements
          dataSourceItem = dataSource[index];
        } else if (dataSource && dataSource.gallery) {
          // dataSource has gallery property,
          // thus it was created by Lightbox, based on
          // gallery and children options

          // query DOM elements
          if (!dataSource.items) {
            dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
          }

          dataSourceItem = dataSource.items[index];
        }

        let itemData = dataSourceItem;

        if (itemData instanceof Element) {
          itemData = this._domElementToItemData(itemData);
        }

        // Dispatching the itemData event,
        // it's a legacy verion before filters were introduced
        const event = this.dispatch('itemData', {
          itemData: itemData || {},
          index
        });

        return this.applyFilters('itemData', event.itemData, index);
      }

      /**
       * Get array of gallery DOM elements,
       * based on childSelector and gallery element.
       *
       * @param {HTMLElement} galleryElement
       */
      _getGalleryDOMElements(galleryElement) {
        if (this.options.children || this.options.childSelector) {
          return getElementsFromOption(
            this.options.children,
            this.options.childSelector,
            galleryElement
          ) || [];
        }

        return [galleryElement];
      }

      /**
       * Converts DOM element to item data object.
       *
       * @param {HTMLElement} element DOM element
       */
      // eslint-disable-next-line class-methods-use-this
      _domElementToItemData(element) {
        /** @type {SlideData} */
        const itemData = {
          element
        };

        // eslint-disable-next-line max-len
        const linkEl = /** @type {HTMLAnchorElement} */ (element.tagName === 'A' ? element : element.querySelector('a'));

        if (linkEl) {
          // src comes from data-pswp-src attribute,
          // if it's empty link href is used
          itemData.src = linkEl.dataset.pswpSrc || linkEl.href;

          if (linkEl.dataset.pswpSrcset) {
            itemData.srcset = linkEl.dataset.pswpSrcset;
          }

          itemData.width = parseInt(linkEl.dataset.pswpWidth, 10);
          itemData.height = parseInt(linkEl.dataset.pswpHeight, 10);

          // support legacy w & h properties
          itemData.w = itemData.width;
          itemData.h = itemData.height;

          if (linkEl.dataset.pswpType) {
            itemData.type = linkEl.dataset.pswpType;
          }

          const thumbnailEl = element.querySelector('img');

          if (thumbnailEl) {
            // msrc is URL to placeholder image that's displayed before large image is loaded
            // by default it's displayed only for the first slide
            itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
            itemData.alt = thumbnailEl.getAttribute('alt');
          }

          if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
            itemData.thumbCropped = true;
          }
        }

        return this.applyFilters('domItemData', itemData, element, linkEl);
      }

      /**
       * Lazy-load by slide data
       *
       * @param {SlideData} itemData Data about the slide
       * @param {number} index
       * @returns Image that is being decoded or false.
       */
      lazyLoadData(itemData, index) {
        return lazyLoadData(itemData, this, index);
      }
    }

    /** @typedef {import('./photoswipe.js').default} PhotoSwipe */
    /** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */
    /** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */

    // some browsers do not paint
    // elements which opacity is set to 0,
    // since we need to pre-render elements for the animation -
    // we set it to the minimum amount
    const MIN_OPACITY = 0.003;

    /**
     * Manages opening and closing transitions of the PhotoSwipe.
     *
     * It can perform zoom, fade or no transition.
     */
    class Opener {
      /**
       * @param {PhotoSwipe} pswp
       */
      constructor(pswp) {
        this.pswp = pswp;
        this.isClosed = true;
        this._prepareOpen = this._prepareOpen.bind(this);

        /** @type {false | Bounds} */
        this._thumbBounds = undefined;

        // Override initial zoom and pan position
        pswp.on('firstZoomPan', this._prepareOpen);
      }

      open() {
        this._prepareOpen();
        this._start();
      }

      close() {
        if (this.isClosed || this.isClosing || this.isOpening) {
          // if we close during opening animation
          // for now do nothing,
          // browsers aren't good at changing the direction of the CSS transition
          return false;
        }

        const slide = this.pswp.currSlide;

        this.isOpen = false;
        this.isOpening = false;
        this.isClosing = true;
        this._duration = this.pswp.options.hideAnimationDuration;

        if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {
          this._duration = 0;
        }

        this._applyStartProps();
        setTimeout(() => {
          this._start();
        }, this._croppedZoom ? 30 : 0);

        return true;
      }

      _prepareOpen() {
        this.pswp.off('firstZoomPan', this._prepareOpen);
        if (!this.isOpening) {
          const slide = this.pswp.currSlide;
          this.isOpening = true;
          this.isClosing = false;
          this._duration = this.pswp.options.showAnimationDuration;
          if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {
            this._duration = 0;
          }
          this._applyStartProps();
        }
      }

      _applyStartProps() {
        const { pswp } = this;
        const slide = this.pswp.currSlide;
        const { options } = pswp;

        if (options.showHideAnimationType === 'fade') {
          options.showHideOpacity = true;
          this._thumbBounds = false;
        } else if (options.showHideAnimationType === 'none') {
          options.showHideOpacity = false;
          this._duration = 0;
          this._thumbBounds = false;
        } else if (this.isOpening && pswp._initialThumbBounds) {
          // Use initial bounds if defined
          this._thumbBounds = pswp._initialThumbBounds;
        } else {
          this._thumbBounds = this.pswp.getThumbBounds();
        }

        this._placeholder = slide.getPlaceholderElement();

        pswp.animations.stopAll();

        // Discard animations when duration is less than 50ms
        this._useAnimation = (this._duration > 50);
        this._animateZoom = Boolean(this._thumbBounds)
                            && (slide.content && slide.content.usePlaceholder())
                            && (!this.isClosing || !pswp.mainScroll.isShifted());
        if (!this._animateZoom) {
          this._animateRootOpacity = true;

          if (this.isOpening) {
            slide.zoomAndPanToInitial();
            slide.applyCurrentZoomPan();
          }
        } else {
          this._animateRootOpacity = options.showHideOpacity;
        }
        this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;
        this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;

        if (!this._useAnimation) {
          this._duration = 0;
          this._animateZoom = false;
          this._animateBgOpacity = false;
          this._animateRootOpacity = true;
          if (this.isOpening) {
            pswp.element.style.opacity = String(MIN_OPACITY);
            pswp.applyBgOpacity(1);
          }
          return;
        }

        if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {
          // Properties are used when animation from cropped thumbnail
          this._croppedZoom = true;
          this._cropContainer1 = this.pswp.container;
          this._cropContainer2 = this.pswp.currSlide.holderElement;

          pswp.container.style.overflow = 'hidden';
          pswp.container.style.width = pswp.viewportSize.x + 'px';
        } else {
          this._croppedZoom = false;
        }

        if (this.isOpening) {
          // Apply styles before opening transition
          if (this._animateRootOpacity) {
            pswp.element.style.opacity = String(MIN_OPACITY);
            pswp.applyBgOpacity(1);
          } else {
            if (this._animateBgOpacity) {
              pswp.bg.style.opacity = String(MIN_OPACITY);
            }
            pswp.element.style.opacity = '1';
          }

          if (this._animateZoom) {
            this._setClosedStateZoomPan();
            if (this._placeholder) {
              // tell browser that we plan to animate the placeholder
              this._placeholder.style.willChange = 'transform';

              // hide placeholder to allow hiding of
              // elements that overlap it (such as icons over the thumbnail)
              this._placeholder.style.opacity = String(MIN_OPACITY);
            }
          }
        } else if (this.isClosing) {
          // hide nearby slides to make sure that
          // they are not painted during the transition
          pswp.mainScroll.itemHolders[0].el.style.display = 'none';
          pswp.mainScroll.itemHolders[2].el.style.display = 'none';

          if (this._croppedZoom) {
            if (pswp.mainScroll.x !== 0) {
              // shift the main scroller to zero position
              pswp.mainScroll.resetPosition();
              pswp.mainScroll.resize();
            }
          }
        }
      }

      _start() {
        if (this.isOpening
            && this._useAnimation
            && this._placeholder
            && this._placeholder.tagName === 'IMG') {
          // To ensure smooth animation
          // we wait till the current slide image placeholder is decoded,
          // but no longer than 250ms,
          // and no shorter than 50ms
          // (just using requestanimationframe is not enough in Firefox,
          // for some reason)
          new Promise((resolve) => {
            let decoded = false;
            let isDelaying = true;
            decodeImage(/** @type {HTMLImageElement} */ (this._placeholder)).finally(() => {
              decoded = true;
              if (!isDelaying) {
                resolve();
              }
            });
            setTimeout(() => {
              isDelaying = false;
              if (decoded) {
                resolve();
              }
            }, 50);
            setTimeout(resolve, 250);
          }).finally(() => this._initiate());
        } else {
          this._initiate();
        }
      }

      _initiate() {
        this.pswp.element.style.setProperty('--pswp-transition-duration', this._duration + 'ms');

        this.pswp.dispatch(
          this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'
        );

        // legacy event
        this.pswp.dispatch(
          /** @type {'initialZoomIn' | 'initialZoomOut'} */
          ('initialZoom' + (this.isOpening ? 'In' : 'Out'))
        );

        this.pswp.element.classList[this.isOpening ? 'add' : 'remove']('pswp--ui-visible');

        if (this.isOpening) {
          if (this._placeholder) {
            // unhide the placeholder
            this._placeholder.style.opacity = '1';
          }
          this._animateToOpenState();
        } else if (this.isClosing) {
          this._animateToClosedState();
        }

        if (!this._useAnimation) {
          this._onAnimationComplete();
        }
      }

      _onAnimationComplete() {
        const { pswp } = this;
        this.isOpen = this.isOpening;
        this.isClosed = this.isClosing;
        this.isOpening = false;
        this.isClosing = false;

        pswp.dispatch(
          this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'
        );

        // legacy event
        pswp.dispatch(
          /** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */
          ('initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'))
        );

        if (this.isClosed) {
          pswp.destroy();
        } else if (this.isOpen) {
          if (this._animateZoom) {
            pswp.container.style.overflow = 'visible';
            pswp.container.style.width = '100%';
          }
          pswp.currSlide.applyCurrentZoomPan();
        }
      }

      _animateToOpenState() {
        const { pswp } = this;
        if (this._animateZoom) {
          if (this._croppedZoom) {
            this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');
            this._animateTo(this._cropContainer2, 'transform', 'none');
          }

          pswp.currSlide.zoomAndPanToInitial();
          this._animateTo(
            pswp.currSlide.container,
            'transform',
            pswp.currSlide.getCurrentTransform()
          );
        }

        if (this._animateBgOpacity) {
          this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));
        }

        if (this._animateRootOpacity) {
          this._animateTo(pswp.element, 'opacity', '1');
        }
      }

      _animateToClosedState() {
        const { pswp } = this;

        if (this._animateZoom) {
          this._setClosedStateZoomPan(true);
        }

        if (this._animateBgOpacity
            && pswp.bgOpacity > 0.01) { // do not animate opacity if it's already at 0
          this._animateTo(pswp.bg, 'opacity', '0');
        }

        if (this._animateRootOpacity) {
          this._animateTo(pswp.element, 'opacity', '0');
        }
      }

      /**
       * @param {boolean=} animate
       */
      _setClosedStateZoomPan(animate) {
        if (!this._thumbBounds) return;

        const { pswp } = this;
        const { innerRect } = this._thumbBounds;
        const { currSlide, viewportSize } = pswp;

        if (this._croppedZoom) {
          const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;
          const containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;
          const containerTwoPanX = viewportSize.x - innerRect.w;
          const containerTwoPanY = viewportSize.y - innerRect.h;


          if (animate) {
            this._animateTo(
              this._cropContainer1,
              'transform',
              toTransformString(containerOnePanX, containerOnePanY)
            );

            this._animateTo(
              this._cropContainer2,
              'transform',
              toTransformString(containerTwoPanX, containerTwoPanY)
            );
          } else {
            setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);
            setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);
          }
        }

        equalizePoints(currSlide.pan, innerRect || this._thumbBounds);
        currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;

        if (animate) {
          this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());
        } else {
          currSlide.applyCurrentZoomPan();
        }
      }

      /**
       * @param {HTMLElement} target
       * @param {'transform' | 'opacity'} prop
       * @param {string} propValue
       */
      _animateTo(target, prop, propValue) {
        if (!this._duration) {
          target.style[prop] = propValue;
          return;
        }

        const { animations } = this.pswp;
        /** @type {AnimationProps} */
        const animProps = {
          duration: this._duration,
          easing: this.pswp.options.easing,
          onComplete: () => {
            if (!animations.activeAnimations.length) {
              this._onAnimationComplete();
            }
          },
          target,
        };
        animProps[prop] = propValue;
        animations.startTransition(animProps);
      }
    }

    /**
     * @template T
     * @typedef {import('./types.js').Type<T>} Type<T>
     */

    /** @typedef {import('./slide/slide.js').SlideData} SlideData */
    /** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */
    /** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */
    /** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */
    /** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */
    /** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */
    /**
     * @template T
     * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>
     */
    /**
     * @template T
     * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>
     */

    /** @typedef {{ x?: number; y?: number; id?: string | number }} Point */
    /** @typedef {{ x?: number; y?: number }} Size */
    /** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */
    /** @typedef {SlideData[]} DataSourceArray */
    /** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */
    /** @typedef {DataSourceArray | DataSourceObject} DataSource */
    /** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */
    /** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */
    /** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */
    /** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */

    /**
     * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider
     */

    /**
     * @typedef {Object} PhotoSwipeOptions https://photoswipe.com/options/
     *
     * @prop {DataSource=} dataSource
     * Pass an array of any items via dataSource option. Its length will determine amount of slides
     * (which may be modified further from numItems event).
     *
     * Each item should contain data that you need to generate slide
     * (for image slide it would be src (image URL), width (image width), height, srcset, alt).
     *
     * If these properties are not present in your initial array, you may "pre-parse" each item from itemData filter.
     *
     * @prop {number=} bgOpacity
     * Background backdrop opacity, always define it via this option and not via CSS rgba color.
     *
     * @prop {number=} spacing
     * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).
     *
     * @prop {boolean=} allowPanToNext
     * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.
     *
     * @prop {boolean=} loop
     * If set to true you'll be able to swipe from the last to the first image.
     * Option is always false when there are less than 3 slides.
     *
     * @prop {boolean=} wheelToZoom
     * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.
     *
     * @prop {boolean=} pinchToClose
     * Pinch touch gesture to close the gallery.
     *
     * @prop {boolean=} closeOnVerticalDrag
     * Vertical drag gesture to close the PhotoSwipe.
     *
     * @prop {Padding=} padding
     * Slide area padding (in pixels).
     *
     * @prop {(viewportSize: Size, itemData: SlideData, index: number) => Padding} [paddingFn]
     * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:
     *
     * @prop {number | false} [hideAnimationDuration]
     * Transition duration in milliseconds, can be 0.
     *
     * @prop {number | false} [showAnimationDuration]
     * Transition duration in milliseconds, can be 0.
     *
     * @prop {number | false} [zoomAnimationDuration]
     * Transition duration in milliseconds, can be 0.
     *
     * @prop {string=} easing
     * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.
     *
     * @prop {boolean=} escKey
     * Esc key to close.
     *
     * @prop {boolean=} arrowKeys
     * Left/right arrow keys for navigation.
     *
     * @prop {boolean=} returnFocus
     * Restore focus the last active element after PhotoSwipe is closed.
     *
     * @prop {boolean=} clickToCloseNonZoomable
     * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.
     *
     * @prop {ActionType | ActionFn | false} [imageClickAction]
     * Refer to click and tap actions page.
     *
     * @prop {ActionType | ActionFn | false} [bgClickAction]
     * Refer to click and tap actions page.
     *
     * @prop {ActionType | ActionFn | false} [tapAction]
     * Refer to click and tap actions page.
     *
     * @prop {ActionType | ActionFn | false} [doubleTapAction]
     * Refer to click and tap actions page.
     *
     * @prop {number=} preloaderDelay
     * Delay before the loading indicator will be displayed,
     * if image is loaded during it - the indicator will not be displayed at all. Can be zero.
     *
     * @prop {string=} indexIndicatorSep
     * Used for slide count indicator ("1 of 10 ").
     *
     * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipe) => { x: number; y: number }} [getViewportSizeFn]
     * A function that should return slide viewport width and height, in format {x: 100, y: 100}.
     *
     * @prop {string=} errorMsg
     * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.
     *
     * @prop {[number, number]=} preload
     * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,
     * first one - number of items to preload before the current image, second one - after the current image.
     * Two nearby images are always loaded.
     *
     * @prop {string=} mainClass
     * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.
     * Example on Styling page.
     *
     * @prop {HTMLElement=} appendToEl
     * Element to which PhotoSwipe dialog will be appended when it opens.
     *
     * @prop {number=} maxWidthToAnimate
     * Maximum width of image to animate, if initial rendered image width
     * is larger than this value - the opening/closing transition will be automatically disabled.
     *
     * @prop {string=} closeTitle
     * Translating
     *
     * @prop {string=} zoomTitle
     * Translating
     *
     * @prop {string=} arrowPrevTitle
     * Translating
     *
     * @prop {string=} arrowNextTitle
     * Translating
     *
     * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]
     * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).
     * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.
     *
     * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.
     *
     * @prop {number=} index
     * Defines start slide index.
     *
     * @prop {(e: MouseEvent) => number} [getClickedIndexFn]
     *
     * @prop {boolean=} arrowPrev
     * @prop {boolean=} arrowNext
     * @prop {boolean=} zoom
     * @prop {boolean=} close
     * @prop {boolean=} counter
     *
     * @prop {string=} arrowPrevSVG
     * @prop {string=} arrowNextSVG
     * @prop {string=} zoomSVG
     * @prop {string=} closeSVG
     * @prop {string=} counterSVG
     *
     * @prop {string=} arrowPrevTitle
     * @prop {string=} arrowNextTitle
     * @prop {string=} zoomTitle
     * @prop {string=} closeTitle
     * @prop {string=} counterTitle
     *
     * @prop {ZoomLevelOption=} initialZoomLevel
     * @prop {ZoomLevelOption=} secondaryZoomLevel
     * @prop {ZoomLevelOption=} maxZoomLevel
     *
     * @prop {boolean=} mouseMovePan
     * @prop {Point | null} [initialPointerPos]
     * @prop {boolean=} showHideOpacity
     *
     * @prop {PhotoSwipeModuleOption} [pswpModule]
     * @prop {() => Promise<any>} [openPromise]
     * @prop {boolean=} preloadFirstSlide
     * @prop {ElementProvider=} gallery
     * @prop {string=} gallerySelector
     * @prop {ElementProvider=} children
     * @prop {string=} childSelector
     * @prop {string | false} [thumbSelector]
     */

    /** @type {PhotoSwipeOptions} */
    const defaultOptions = {
      allowPanToNext: true,
      spacing: 0.1,
      loop: true,
      pinchToClose: true,
      closeOnVerticalDrag: true,
      hideAnimationDuration: 333,
      showAnimationDuration: 333,
      zoomAnimationDuration: 333,
      escKey: true,
      arrowKeys: true,
      returnFocus: true,
      maxWidthToAnimate: 4000,
      clickToCloseNonZoomable: true,
      imageClickAction: 'zoom-or-close',
      bgClickAction: 'close',
      tapAction: 'toggle-controls',
      doubleTapAction: 'zoom',
      indexIndicatorSep: ' / ',
      preloaderDelay: 2000,
      bgOpacity: 0.8,

      index: 0,
      errorMsg: 'The image cannot be loaded',
      preload: [1, 2],
      easing: 'cubic-bezier(.4,0,.22,1)'
    };

    /**
     * PhotoSwipe Core
     */
    class PhotoSwipe extends PhotoSwipeBase {
      /**
       * @param {PhotoSwipeOptions} options
       */
      constructor(options) {
        super();

        this._prepareOptions(options);

        /**
         * offset of viewport relative to document
         *
         * @type {{ x?: number; y?: number }}
         */
        this.offset = {};

        /**
         * @type {{ x?: number; y?: number }}
         * @private
         */
        this._prevViewportSize = {};

        /**
         * Size of scrollable PhotoSwipe viewport
         *
         * @type {{ x?: number; y?: number }}
         */
        this.viewportSize = {};

        /**
         * background (backdrop) opacity
         *
         * @type {number}
         */
        this.bgOpacity = 1;

        /** @type {HTMLDivElement} */
        this.topBar = undefined;

        this.events = new DOMEvents();

        /** @type {Animations} */
        this.animations = new Animations();

        this.mainScroll = new MainScroll(this);
        this.gestures = new Gestures(this);
        this.opener = new Opener(this);
        this.keyboard = new Keyboard(this);
        this.contentLoader = new ContentLoader(this);
      }

      init() {
        if (this.isOpen || this.isDestroying) {
          return;
        }

        this.isOpen = true;
        this.dispatch('init'); // legacy
        this.dispatch('beforeOpen');

        this._createMainStructure();

        // add classes to the root element of PhotoSwipe
        let rootClasses = 'pswp--open';
        if (this.gestures.supportsTouch) {
          rootClasses += ' pswp--touch';
        }
        if (this.options.mainClass) {
          rootClasses += ' ' + this.options.mainClass;
        }
        this.element.className += ' ' + rootClasses;

        this.currIndex = this.options.index || 0;
        this.potentialIndex = this.currIndex;
        this.dispatch('firstUpdate'); // starting index can be modified here

        // initialize scroll wheel handler to block the scroll
        this.scrollWheel = new ScrollWheel(this);

        // sanitize index
        if (Number.isNaN(this.currIndex)
            || this.currIndex < 0
            || this.currIndex >= this.getNumItems()) {
          this.currIndex = 0;
        }

        if (!this.gestures.supportsTouch) {
          // enable mouse features if no touch support detected
          this.mouseDetected();
        }

        // causes forced synchronous layout
        this.updateSize();

        this.offset.y = window.pageYOffset;

        this._initialItemData = this.getItemData(this.currIndex);
        this.dispatch('gettingData', {
          index: this.currIndex,
          data: this._initialItemData,
          slide: undefined
        });

        // *Layout* - calculate size and position of elements here
        this._initialThumbBounds = this.getThumbBounds();
        this.dispatch('initialLayout');

        this.on('openingAnimationEnd', () => {
          this.mainScroll.itemHolders[0].el.style.display = 'block';
          this.mainScroll.itemHolders[2].el.style.display = 'block';

          // Add content to the previous and next slide
          this.setContent(this.mainScroll.itemHolders[0], this.currIndex - 1);
          this.setContent(this.mainScroll.itemHolders[2], this.currIndex + 1);

          this.appendHeavy();

          this.contentLoader.updateLazy();

          this.events.add(window, 'resize', this._handlePageResize.bind(this));
          this.events.add(window, 'scroll', this._updatePageScrollOffset.bind(this));
          this.dispatch('bindEvents');
        });

        // set content for center slide (first time)
        this.setContent(this.mainScroll.itemHolders[1], this.currIndex);
        this.dispatch('change');

        this.opener.open();

        this.dispatch('afterInit');

        return true;
      }

      /**
       * Get looped slide index
       * (for example, -1 will return the last slide)
       *
       * @param {number} index
       */
      getLoopedIndex(index) {
        const numSlides = this.getNumItems();

        if (this.options.loop) {
          if (index > numSlides - 1) {
            index -= numSlides;
          }

          if (index < 0) {
            index += numSlides;
          }
        }

        index = clamp(index, 0, numSlides - 1);

        return index;
      }

      appendHeavy() {
        this.mainScroll.itemHolders.forEach((itemHolder) => {
          if (itemHolder.slide) {
            itemHolder.slide.appendHeavy();
          }
        });
      }

      /**
       * Change the slide
       * @param {number} index New index
       */
      goTo(index) {
        this.mainScroll.moveIndexBy(
          this.getLoopedIndex(index) - this.potentialIndex
        );
      }

      /**
       * Go to the next slide.
       */
      next() {
        this.goTo(this.potentialIndex + 1);
      }

      /**
       * Go to the previous slide.
       */
      prev() {
        this.goTo(this.potentialIndex - 1);
      }

      /**
       * @see slide/slide.js zoomTo
       *
       * @param {Parameters<Slide['zoomTo']>} args
       */
      zoomTo(...args) {
        this.currSlide.zoomTo(...args);
      }

      /**
       * @see slide/slide.js toggleZoom
       */
      toggleZoom() {
        this.currSlide.toggleZoom();
      }

      /**
       * Close the gallery.
       * After closing transition ends - destroy it
       */
      close() {
        if (!this.opener.isOpen || this.isDestroying) {
          return;
        }

        this.isDestroying = true;

        this.dispatch('close');

        this.events.removeAll();
        this.opener.close();
      }

      /**
       * Destroys the gallery:
       * - instantly closes the gallery
       * - unbinds events,
       * - cleans intervals and timeouts
       * - removes elements from DOM
       */
      destroy() {
        if (!this.isDestroying) {
          this.options.showHideAnimationType = 'none';
          this.close();
          return;
        }

        this.dispatch('destroy');

        this.listeners = null;

        this.scrollWrap.ontouchmove = null;
        this.scrollWrap.ontouchend = null;

        this.element.remove();

        this.mainScroll.itemHolders.forEach((itemHolder) => {
          if (itemHolder.slide) {
            itemHolder.slide.destroy();
          }
        });

        this.contentLoader.destroy();
        this.events.removeAll();
      }

      /**
       * Refresh/reload content of a slide by its index
       *
       * @param {number} slideIndex
       */
      refreshSlideContent(slideIndex) {
        this.contentLoader.removeByIndex(slideIndex);
        this.mainScroll.itemHolders.forEach((itemHolder, i) => {
          let potentialHolderIndex = this.currSlide.index - 1 + i;
          if (this.canLoop()) {
            potentialHolderIndex = this.getLoopedIndex(potentialHolderIndex);
          }
          if (potentialHolderIndex === slideIndex) {
            // set the new slide content
            this.setContent(itemHolder, slideIndex, true);

            // activate the new slide if it's current
            if (i === 1) {
              /** @type {Slide} */
              this.currSlide = itemHolder.slide;
              itemHolder.slide.setIsActive(true);
            }
          }
        });

        this.dispatch('change');
      }


      /**
       * Set slide content
       *
       * @param {ItemHolder} holder mainScroll.itemHolders array item
       * @param {number} index Slide index
       * @param {boolean=} force If content should be set even if index wasn't changed
       */
      setContent(holder, index, force) {
        if (this.canLoop()) {
          index = this.getLoopedIndex(index);
        }

        if (holder.slide) {
          if (holder.slide.index === index && !force) {
            // exit if holder already contains this slide
            // this could be common when just three slides are used
            return;
          }

          // destroy previous slide
          holder.slide.destroy();
          holder.slide = null;
        }

        // exit if no loop and index is out of bounds
        if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {
          return;
        }

        const itemData = this.getItemData(index);
        holder.slide = new Slide(itemData, index, this);

        // set current slide
        if (index === this.currIndex) {
          this.currSlide = holder.slide;
        }

        holder.slide.append(holder.el);
      }

      getViewportCenterPoint() {
        return {
          x: this.viewportSize.x / 2,
          y: this.viewportSize.y / 2
        };
      }

      /**
       * Update size of all elements.
       * Executed on init and on page resize.
       *
       * @param {boolean=} force Update size even if size of viewport was not changed.
       */
      updateSize(force) {
        // let item;
        // let itemIndex;

        if (this.isDestroying) {
          // exit if PhotoSwipe is closed or closing
          // (to avoid errors, as resize event might be delayed)
          return;
        }

        //const newWidth = this.scrollWrap.clientWidth;
        //const newHeight = this.scrollWrap.clientHeight;

        const newViewportSize = getViewportSize(this.options, this);

        if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {
          // Exit if dimensions were not changed
          return;
        }

        //this._prevViewportSize.x = newWidth;
        //this._prevViewportSize.y = newHeight;
        equalizePoints(this._prevViewportSize, newViewportSize);

        this.dispatch('beforeResize');

        equalizePoints(this.viewportSize, this._prevViewportSize);

        this._updatePageScrollOffset();

        this.dispatch('viewportSize');

        // Resize slides only after opener animation is finished
        // and don't re-calculate size on inital size update
        this.mainScroll.resize(this.opener.isOpen);

        if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {
          this.mouseDetected();
        }

        this.dispatch('resize');
      }

      /**
       * @param {number} opacity
       */
      applyBgOpacity(opacity) {
        this.bgOpacity = Math.max(opacity, 0);
        this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);
      }

      /**
       * Whether mouse is detected
       */
      mouseDetected() {
        if (!this.hasMouse) {
          this.hasMouse = true;
          this.element.classList.add('pswp--has_mouse');
        }
      }

      /**
       * Page resize event handler
       *
       * @private
       */
      _handlePageResize() {
        this.updateSize();

        // In iOS webview, if element size depends on document size,
        // it'll be measured incorrectly in resize event
        //
        // https://bugs.webkit.org/show_bug.cgi?id=170595
        // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d
        if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
          setTimeout(() => {
            this.updateSize();
          }, 500);
        }
      }

      /**
       * Page scroll offset is used
       * to get correct coordinates
       * relative to PhotoSwipe viewport.
       *
       * @private
       */
      _updatePageScrollOffset() {
        this.setScrollOffset(0, window.pageYOffset);
      }

      /**
       * @param {number} x
       * @param {number} y
       */
      setScrollOffset(x, y) {
        this.offset.x = x;
        this.offset.y = y;
        this.dispatch('updateScrollOffset');
      }

      /**
       * Create main HTML structure of PhotoSwipe,
       * and add it to DOM
       *
       * @private
       */
      _createMainStructure() {
        // root DOM element of PhotoSwipe (.pswp)
        this.element = createElement('pswp');
        this.element.setAttribute('tabindex', '-1');
        this.element.setAttribute('role', 'dialog');

        // template is legacy prop
        this.template = this.element;

        // Background is added as a separate element,
        // as animating opacity is faster than animating rgba()
        this.bg = createElement('pswp__bg', false, this.element);
        this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);
        this.container = createElement('pswp__container', false, this.scrollWrap);

        // aria pattern: carousel
        this.scrollWrap.setAttribute('aria-roledescription', 'carousel');
        this.container.setAttribute('aria-live', 'off');
        this.container.setAttribute('id', 'pswp__items');

        this.mainScroll.appendHolders();

        this.ui = new UI(this);
        this.ui.init();

        // append to DOM
        (this.options.appendToEl || document.body).appendChild(this.element);
      }


      /**
       * Get position and dimensions of small thumbnail
       *   {x:,y:,w:}
       *
       * Height is optional (calculated based on the large image)
       */
      getThumbBounds() {
        return getThumbBounds(
          this.currIndex,
          this.currSlide ? this.currSlide.data : this._initialItemData,
          this
        );
      }

      /**
       * If the PhotoSwipe can have continious loop
       * @returns Boolean
       */
      canLoop() {
        return (this.options.loop && this.getNumItems() > 2);
      }

      /**
       * @param {PhotoSwipeOptions} options
       * @private
       */
      _prepareOptions(options) {
        if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {
          options.showHideAnimationType = 'none';
          options.zoomAnimationDuration = 0;
        }

        /** @type {PhotoSwipeOptions}*/
        this.options = {
          ...defaultOptions,
          ...options
        };
      }
    }

    var css_248z$8 = "/*! PhotoSwipe main CSS by Dmytro Semenov | photoswipe.com */\r\n\r\n.pswp {\r\n  --pswp-bg: #000;\r\n  --pswp-placeholder-bg: #222;\r\n  \r\n\r\n  --pswp-root-z-index: 100000;\r\n  \r\n  --pswp-preloader-color: rgba(79, 79, 79, 0.4);\r\n  --pswp-preloader-color-secondary: rgba(255, 255, 255, 0.9);\r\n  \r\n  /* defined via js:\r\n  --pswp-transition-duration: 333ms; */\r\n  \r\n  --pswp-icon-color: #fff;\r\n  --pswp-icon-color-secondary: #4f4f4f;\r\n  --pswp-icon-stroke-color: #4f4f4f;\r\n  --pswp-icon-stroke-width: 2px;\r\n\r\n  --pswp-error-text-color: var(--pswp-icon-color);\r\n}\r\n\r\n\r\n/*\r\n\tStyles for basic PhotoSwipe (pswp) functionality (sliding area, open/close transitions)\r\n*/\r\n\r\n.pswp {\r\n\tposition: fixed;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tz-index: var(--pswp-root-z-index);\r\n\tdisplay: none;\r\n\ttouch-action: none;\r\n\toutline: 0;\r\n\topacity: 0.003;\r\n\tcontain: layout style size;\r\n\t-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n}\r\n\r\n/* Prevents focus outline on the root element,\r\n  (it may be focused initially) */\r\n.pswp:focus {\r\n  outline: 0;\r\n}\r\n\r\n.pswp * {\r\n  box-sizing: border-box;\r\n}\r\n\r\n.pswp img {\r\n  max-width: none;\r\n}\r\n\r\n.pswp--open {\r\n\tdisplay: block;\r\n}\r\n\r\n.pswp,\r\n.pswp__bg {\r\n\ttransform: translateZ(0);\r\n\twill-change: opacity;\r\n}\r\n\r\n.pswp__bg {\r\n  opacity: 0.005;\r\n\tbackground: var(--pswp-bg);\r\n}\r\n\r\n.pswp,\r\n.pswp__scroll-wrap {\r\n\toverflow: hidden;\r\n}\r\n\r\n.pswp__scroll-wrap,\r\n.pswp__bg,\r\n.pswp__container,\r\n.pswp__item,\r\n.pswp__content,\r\n.pswp__img,\r\n.pswp__zoom-wrap {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n}\r\n\r\n.pswp__img,\r\n.pswp__zoom-wrap {\r\n\twidth: auto;\r\n\theight: auto;\r\n}\r\n\r\n.pswp--click-to-zoom.pswp--zoom-allowed .pswp__img {\r\n\tcursor: zoom-in;\r\n}\r\n\r\n.pswp--click-to-zoom.pswp--zoomed-in .pswp__img {\r\n\tcursor: move;\r\n\tcursor: grab;\r\n}\r\n\r\n.pswp--click-to-zoom.pswp--zoomed-in .pswp__img:active {\r\n  cursor: grabbing;\r\n}\r\n\r\n/* :active to override grabbing cursor */\r\n.pswp--no-mouse-drag.pswp--zoomed-in .pswp__img,\r\n.pswp--no-mouse-drag.pswp--zoomed-in .pswp__img:active,\r\n.pswp__img {\r\n\tcursor: zoom-out;\r\n}\r\n\r\n\r\n/* Prevent selection and tap highlights */\r\n.pswp__container,\r\n.pswp__img,\r\n.pswp__button,\r\n.pswp__counter {\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\tuser-select: none;\r\n}\r\n\r\n.pswp__item {\r\n\t/* z-index for fade transition */\r\n\tz-index: 1;\r\n\toverflow: hidden;\r\n}\r\n\r\n.pswp__hidden {\r\n\tdisplay: none !important;\r\n}\r\n\r\n/* Allow to click through pswp__content element, but not its children */\r\n.pswp__content {\r\n  pointer-events: none;\r\n}\r\n.pswp__content > * {\r\n  pointer-events: auto;\r\n}\r\n\r\n\r\n/*\r\n\r\n  PhotoSwipe UI\r\n\r\n*/\r\n\r\n/*\r\n\tError message appears when image is not loaded\r\n\t(JS option errorMsg controls markup)\r\n*/\r\n.pswp__error-msg-container {\r\n  display: grid;\r\n}\r\n.pswp__error-msg {\r\n\tmargin: auto;\r\n\tfont-size: 1em;\r\n\tline-height: 1;\r\n\tcolor: var(--pswp-error-text-color);\r\n}\r\n\r\n/*\r\nclass pswp__hide-on-close is applied to elements that\r\nshould hide (for example fade out) when PhotoSwipe is closed\r\nand show (for example fade in) when PhotoSwipe is opened\r\n */\r\n.pswp .pswp__hide-on-close {\r\n\topacity: 0.005;\r\n\twill-change: opacity;\r\n\ttransition: opacity var(--pswp-transition-duration) cubic-bezier(0.4, 0, 0.22, 1);\r\n\tz-index: 10; /* always overlap slide content */\r\n\tpointer-events: none; /* hidden elements should not be clickable */\r\n}\r\n\r\n/* class pswp--ui-visible is added when opening or closing transition starts */\r\n.pswp--ui-visible .pswp__hide-on-close {\r\n\topacity: 1;\r\n\tpointer-events: auto;\r\n}\r\n\r\n/* <button> styles, including css reset */\r\n.pswp__button {\r\n\tposition: relative;\r\n\tdisplay: block;\r\n\twidth: 50px;\r\n\theight: 60px;\r\n\tpadding: 0;\r\n\tmargin: 0;\r\n\toverflow: hidden;\r\n\tcursor: pointer;\r\n\tbackground: none;\r\n\tborder: 0;\r\n\tbox-shadow: none;\r\n\topacity: 0.85;\r\n\t-webkit-appearance: none;\r\n\t-webkit-touch-callout: none;\r\n}\r\n\r\n.pswp__button:hover,\r\n.pswp__button:active,\r\n.pswp__button:focus {\r\n  transition: none;\r\n  padding: 0;\r\n  background: none;\r\n  border: 0;\r\n  box-shadow: none;\r\n  opacity: 1;\r\n}\r\n\r\n.pswp__button:disabled {\r\n  opacity: 0.3;\r\n  cursor: auto;\r\n}\r\n\r\n.pswp__icn {\r\n  fill: var(--pswp-icon-color);\r\n  color: var(--pswp-icon-color-secondary);\r\n  position: absolute;\r\n  top: 14px;\r\n  left: 9px;\r\n  width: 32px;\r\n  height: 32px;\r\n  overflow: hidden;\r\n  pointer-events: none;\r\n}\r\n\r\n.pswp__icn-shadow {\r\n  stroke: var(--pswp-icon-stroke-color);\r\n  stroke-width: var(--pswp-icon-stroke-width);\r\n  fill: none;\r\n}\r\n\r\n.pswp__icn:focus {\r\n\toutline: 0;\r\n}\r\n\r\n/*\r\n\tdiv element that matches size of large image,\r\n\tlarge image loads on top of it,\r\n\tused when msrc is not provided\r\n*/\r\ndiv.pswp__img--placeholder,\r\n.pswp__img--with-bg {\r\n\tbackground: var(--pswp-placeholder-bg);\r\n}\r\n\r\n.pswp__top-bar {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\twidth: 100%;\r\n\theight: 60px;\r\n\tdisplay: flex;\r\n  flex-direction: row;\r\n  justify-content: flex-end;\r\n\tz-index: 10;\r\n\r\n\t/* allow events to pass through top bar itself */\r\n\tpointer-events: none !important;\r\n}\r\n.pswp__top-bar > * {\r\n  pointer-events: auto;\r\n  /* this makes transition significantly more smooth,\r\n     even though inner elements are not animated */\r\n  will-change: opacity;\r\n}\r\n\r\n\r\n/*\r\n\r\n  Close button\r\n\r\n*/\r\n.pswp__button--close {\r\n  margin-right: 6px;\r\n}\r\n\r\n\r\n/*\r\n\r\n  Arrow buttons\r\n\r\n*/\r\n.pswp__button--arrow {\r\n  position: absolute;\r\n  top: 0;\r\n  width: 75px;\r\n  height: 100px;\r\n  top: 50%;\r\n  margin-top: -50px;\r\n}\r\n\r\n.pswp__button--arrow:disabled {\r\n  display: none;\r\n  cursor: default;\r\n}\r\n\r\n.pswp__button--arrow .pswp__icn {\r\n  top: 50%;\r\n  margin-top: -30px;\r\n  width: 60px;\r\n  height: 60px;\r\n  background: none;\r\n  border-radius: 0;\r\n}\r\n\r\n.pswp--one-slide .pswp__button--arrow {\r\n  display: none;\r\n}\r\n\r\n/* hide arrows on touch screens */\r\n.pswp--touch .pswp__button--arrow {\r\n  visibility: hidden;\r\n}\r\n\r\n/* show arrows only after mouse was used */\r\n.pswp--has_mouse .pswp__button--arrow {\r\n  visibility: visible;\r\n}\r\n\r\n.pswp__button--arrow--prev {\r\n  right: auto;\r\n  left: 0px;\r\n}\r\n\r\n.pswp__button--arrow--next {\r\n  right: 0px;\r\n}\r\n.pswp__button--arrow--next .pswp__icn {\r\n  left: auto;\r\n  right: 14px;\r\n  /* flip horizontally */\r\n  transform: scale(-1, 1);\r\n}\r\n\r\n/*\r\n\r\n  Zoom button\r\n\r\n*/\r\n.pswp__button--zoom {\r\n  display: none;\r\n}\r\n\r\n.pswp--zoom-allowed .pswp__button--zoom {\r\n  display: block;\r\n}\r\n\r\n/* \"+\" => \"-\" */\r\n.pswp--zoomed-in .pswp__zoom-icn-bar-v {\r\n  display: none;\r\n}\r\n\r\n\r\n/*\r\n\r\n  Loading indicator\r\n\r\n*/\r\n.pswp__preloader {\r\n  position: relative;\r\n  overflow: hidden;\r\n  width: 50px;\r\n  height: 60px;\r\n  margin-right: auto;\r\n}\r\n\r\n.pswp__preloader .pswp__icn {\r\n  opacity: 0;\r\n  transition: opacity 0.2s linear;\r\n  animation: pswp-clockwise 600ms linear infinite;\r\n}\r\n\r\n.pswp__preloader--active .pswp__icn {\r\n  opacity: 0.85;\r\n}\r\n\r\n@keyframes pswp-clockwise {\r\n  0% { transform: rotate(0deg); }\r\n  100% { transform: rotate(360deg); }\r\n}\r\n\r\n\r\n/*\r\n\r\n  \"1 of 10\" counter\r\n\r\n*/\r\n.pswp__counter {\r\n  height: 30px;\r\n  margin: 15px 0 0 20px;\r\n  font-size: 14px;\r\n  line-height: 30px;\r\n  color: var(--pswp-icon-color);\r\n  text-shadow: 1px 1px 3px var(--pswp-icon-color-secondary);\r\n  opacity: 0.85;\r\n}\r\n\r\n.pswp--one-slide .pswp__counter {\r\n  display: none;\r\n}\r\n";
    styleInject(css_248z$8,{"insertAt":"top"});

    var css_248z$7 = "";
    styleInject(css_248z$7,{"insertAt":"top"});

    var FileSaver_min = {exports: {}};

    (function (module, exports) {
    (function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


    }(FileSaver_min));

    var Download = function (_a) {
        var url = _a.url;
        var download = require$$0$1.useCallback(function (e) {
            e.preventDefault();
            FileSaver_min.exports.saveAs(url);
        }, [url]);
        return (require$$0__default["default"].createElement("button", { onClick: download },
            require$$0__default["default"].createElement("div", { className: "flex justify-center items-center bg-gray-200 p-2 rounded-full" },
                require$$0__default["default"].createElement(ArrowDownTrayIcon, { className: "h-4 w-4 text-gray-500" }))));
    };

    let random = bytes => crypto.getRandomValues(new Uint8Array(bytes));
    let customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1;
      let step = -~((1.6 * mask * defaultSize) / alphabet.length);
      return (size = defaultSize) => {
        let id = '';
        while (true) {
          let bytes = getRandom(step);
          let j = step;
          while (j--) {
            id += alphabet[bytes[j] & mask] || '';
            if (id.length === size) return id
          }
        }
      }
    };
    let customAlphabet = (alphabet, size = 21) =>
      customRandom(alphabet, size, random);

    var useFileUrl = function (url) {
        var rc = useRc().rc;
        return getFileUrl(rc.getHost() + url);
    };

    var ImageAttachment = function (_a) {
        var _b, _c, _d, _e, _f;
        var attachment = _a.attachment;
        var url = useFileUrl(attachment.image_url);
        var nanoid = customAlphabet('abcdefghijlmnoprstuw', 10);
        var uuid = require$$0$1.useMemo(function () { return nanoid(); }, []);
        require$$0$1.useEffect(function () {
            var lightbox = new PhotoSwipeLightbox({
                gallery: '#' + uuid,
                children: 'a',
                pswpModule: PhotoSwipe,
            });
            lightbox.init();
            return function () {
                lightbox.destroy();
                lightbox = null;
            };
        }, [uuid]);
        var aspectRatio = require$$0$1.useMemo(function () { var _a, _b; return ((_a = attachment.image_dimensions) === null || _a === void 0 ? void 0 : _a.width) / ((_b = attachment.image_dimensions) === null || _b === void 0 ? void 0 : _b.height); }, [(_b = attachment.image_dimensions) === null || _b === void 0 ? void 0 : _b.height, (_c = attachment.image_dimensions) === null || _c === void 0 ? void 0 : _c.width]);
        return (require$$0__default["default"].createElement(require$$0__default["default"].Fragment, null,
            require$$0__default["default"].createElement("div", { className: "px-4 pt-2 first:pt-4 pb-2 flex gap-4 " },
                require$$0__default["default"].createElement("div", { className: 'pswp-gallery flex shrink', id: uuid },
                    require$$0__default["default"].createElement("a", { style: {
                            aspectRatio: aspectRatio,
                        }, className: "max-w-[300px] overflow-hidden", href: url, "data-pswp-width": (_d = attachment.image_dimensions) === null || _d === void 0 ? void 0 : _d.width, "data-pswp-height": (_e = attachment.image_dimensions) === null || _e === void 0 ? void 0 : _e.height, key: uuid + '-' + attachment.image_url, target: "_blank", rel: "noreferrer" },
                        require$$0__default["default"].createElement("img", { src: url, alt: "", className: "box-content rounded-md object-cover block w-full h-full", style: {
                                width: (_f = attachment.image_dimensions) === null || _f === void 0 ? void 0 : _f.width,
                            } }))),
                require$$0__default["default"].createElement("div", { className: "flex basis-8" },
                    require$$0__default["default"].createElement(Download, { url: url }))),
            (attachment === null || attachment === void 0 ? void 0 : attachment.description) ? (require$$0__default["default"].createElement("div", { className: "flex px-4 !pb-2" }, attachment.description)) : null,
            require$$0__default["default"].createElement("div", null)));
    };

    var css_248z$6 = "";
    styleInject(css_248z$6,{"insertAt":"top"});

    var FileAttachment = function (_a) {
        var attachment = _a.attachment;
        var url = useFileUrl(attachment.title_link);
        return (require$$0__default["default"].createElement("div", { className: "px-4 pt-4 pb-2 flex items-center" },
            require$$0__default["default"].createElement(DocumentIcon, { className: "h-4 w-4 m-1 mr-2 text-indigo-500" }),
            require$$0__default["default"].createElement("span", { className: "text-sm leading-5 font-medium text-gray-900 mr-5" }, attachment.title),
            require$$0__default["default"].createElement(Download, { url: url })));
    };

    var css_248z$5 = ":root {\n  --plyr-range-fill-background: #4F46E5;\n}\n\n.message-owner {\n  --plyr-range-fill-background: #0284C7;\n}\n\n.plyr.plyr--video {\n  margin-right: 1.25em;\n  min-width: 100px;\n  max-width: 300px;\n}\n\n.plyr.plyr--video .plyr__controls {\n  background-color: transparent;\n  padding-left: 1em;\n  padding-right: 1em;\n  padding-top: 1em;\n  padding-bottom: 0.625em;\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__control {\n  border-radius: 9999px;\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__control {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__control .icon--pressed,\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__control .icon--not-pressed {\n  height: 0.625em;\n  width: 0.625em;\n  --tw-text-opacity: 1;\n  color: rgb(255 255 255 / var(--tw-text-opacity));\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__time--current.plyr__time {\n  min-width: 45px;\n  text-align: right;\n  font-size: 0.75em;\n  font-weight: 400;\n  line-height: 1rem;\n  --tw-text-opacity: 1;\n  color: rgb(199 210 254 / var(--tw-text-opacity));\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__time--current.plyr__time {\n  --tw-text-opacity: 1;\n  color: rgb(186 230 253 / var(--tw-text-opacity));\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-track {\n  background-color: rgb(199 210 254 / 0.75);\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-track {\n  background-color: rgb(199 210 254 / 0.75);\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-runnable-track {\n  background-color: rgb(199 210 254 / 0.75);\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-track {\n  background-color: rgb(186 230 253 / 0.75);\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-track {\n  background-color: rgb(186 230 253 / 0.75);\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-runnable-track {\n  background-color: rgb(186 230 253 / 0.75);\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.message-owner .plyr.plyr--video .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}";
    styleInject(css_248z$5,{"insertAt":"top"});

    var VideoAttachment = function (_a) {
        var attachment = _a.attachment;
        var url = useFileUrl(attachment.video_url);
        return (React.createElement("div", { className: "px-4 pt-4 pb-2.5 flex gap-4" },
            React.createElement("div", { className: "flex shrink" },
                React.createElement("video", { width: 300, controls: true },
                    React.createElement("source", { src: url, type: attachment.video_type }))),
            React.createElement("div", { className: "flex basis-8" },
                React.createElement(Download, { url: url }))));
    };

    var css_248z$4 = ":root {\n  --plyr-range-fill-background: #4F46E5;\n}\n\n.message-owner {\n  --plyr-range-fill-background: #0284C7;\n}\n\n.plyr.plyr--audio {\n  min-width: 120px;\n}\n\n.plyr.plyr--audio .plyr__controls {\n  background-color: transparent;\n  padding-left: 1em;\n  padding-right: 1em;\n  padding-top: 1em;\n  padding-bottom: 0.625em;\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__control {\n  border-radius: 9999px;\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__control {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__control .icon--pressed,\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__control .icon--not-pressed {\n  height: 0.625em;\n  width: 0.625em;\n  --tw-text-opacity: 1;\n  color: rgb(255 255 255 / var(--tw-text-opacity));\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__time--current.plyr__time {\n  min-width: 45px;\n  text-align: right;\n  font-size: 0.75em;\n  font-weight: 400;\n  line-height: 1rem;\n  --tw-text-opacity: 1;\n  color: rgb(55 48 163 / var(--tw-text-opacity));\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__time--current.plyr__time {\n  --tw-text-opacity: 1;\n  color: rgb(7 89 133 / var(--tw-text-opacity));\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-track {\n  background-color: rgb(199 210 254 / 0.75);\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-track {\n  background-color: rgb(199 210 254 / 0.75);\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-runnable-track {\n  background-color: rgb(199 210 254 / 0.75);\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-track {\n  background-color: rgb(186 230 253 / 0.75);\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-track {\n  background-color: rgb(186 230 253 / 0.75);\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-runnable-track {\n  background-color: rgb(186 230 253 / 0.75);\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(79 70 229 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-webkit-slider-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-ms-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.message-owner .plyr.plyr--audio .plyr__controls .plyr__controls__item.plyr__progress__container .plyr__progress>input[type=range]::-moz-range-thumb {\n  --tw-bg-opacity: 1;\n  background-color: rgb(2 132 199 / var(--tw-bg-opacity));\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}";
    styleInject(css_248z$4,{"insertAt":"top"});

    var AudioAttachment = function (_a) {
        var attachment = _a.attachment;
        var url = useFileUrl(attachment.audio_url);
        return (React.createElement("div", { className: "px-4 pt-4 pb-2.5 flex items-center" },
            React.createElement("audio", { controls: true },
                React.createElement("source", { src: url, type: attachment.audio_type }))));
    };

    var Attachment = function (_a) {
        var attachment = _a.attachment;
        if (attachment.image_url) {
            return require$$0__default["default"].createElement(ImageAttachment, { attachment: attachment });
        }
        if (attachment.video_url) {
            return require$$0__default["default"].createElement(VideoAttachment, { attachment: attachment });
        }
        if (attachment.audio_url) {
            return require$$0__default["default"].createElement(AudioAttachment, { attachment: attachment });
        }
        return require$$0__default["default"].createElement(FileAttachment, { attachment: attachment });
    };

    var Attachments = function (_a) {
        var attachments = _a.attachments;
        return (require$$0__default["default"].createElement(require$$0__default["default"].Fragment, null, attachments.map(function (attachment, id) { return (require$$0__default["default"].createElement(Attachment, { key: id, attachment: attachment })); })));
    };

    var css_248z$3 = "";
    styleInject(css_248z$3,{"insertAt":"top"});

    var Avatar = function (_a) {
        var username = _a.username, _b = _a.width, width = _b === void 0 ? 100 : _b, _c = _a.height, height = _c === void 0 ? 100 : _c;
        var url = useFileUrl('/avatar/' + username);
        return (require$$0__default["default"].createElement("div", { style: { width: width, height: height }, className: 'flex ' },
            require$$0__default["default"].createElement("img", { src: url, className: 'rounded-xl' })));
    };

    var i$2=Object.defineProperty;var d$1=(t,e,n)=>e in t?i$2(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var r$1=(t,e,n)=>(d$1(t,typeof e!="symbol"?e+"":e,n),n);class o$4{constructor(){r$1(this,"current",this.detect());r$1(this,"handoffState","pending");r$1(this,"currentId",0);}set(e){this.current!==e&&(this.handoffState="pending",this.currentId=0,this.current=e);}reset(){this.set(this.detect());}nextId(){return ++this.currentId}get isServer(){return this.current==="server"}get isClient(){return this.current==="client"}detect(){return typeof window=="undefined"||typeof document=="undefined"?"server":"client"}handoff(){this.handoffState==="pending"&&(this.handoffState="complete");}get isHandoffComplete(){return this.handoffState==="complete"}}let s$3=new o$4;

    let l$2=(e,f)=>{s$3.isServer?require$$0$1.useEffect(e,f):require$$0$1.useLayoutEffect(e,f);};

    function s$2(e){let r=require$$0$1.useRef(e);return l$2(()=>{r.current=e;},[e]),r}

    function t$2(e){typeof queueMicrotask=="function"?queueMicrotask(e):Promise.resolve().then(e).catch(o=>setTimeout(()=>{throw o}));}

    function m$1(){let n=[],i=[],r={enqueue(e){i.push(e);},addEventListener(e,t,a,o){return e.addEventListener(t,a,o),r.add(()=>e.removeEventListener(t,a,o))},requestAnimationFrame(...e){let t=requestAnimationFrame(...e);return r.add(()=>cancelAnimationFrame(t))},nextFrame(...e){return r.requestAnimationFrame(()=>r.requestAnimationFrame(...e))},setTimeout(...e){let t=setTimeout(...e);return r.add(()=>clearTimeout(t))},microTask(...e){let t={current:!0};return t$2(()=>{t.current&&e[0]();}),r.add(()=>{t.current=!1;})},add(e){return n.push(e),()=>{let t=n.indexOf(e);if(t>=0){let[a]=n.splice(t,1);a();}}},dispose(){for(let e of n.splice(0))e();},async workQueue(){for(let e of i.splice(0))await e();}};return r}

    function p$1(){let[e]=require$$0$1.useState(m$1);return require$$0$1.useEffect(()=>()=>e.dispose(),[e]),e}

    let o$3=function(t){let e=s$2(t);return require$$0__default["default"].useCallback((...r)=>e.current(...r),[e])};

    function l$1(){let[e,f]=require$$0$1.useState(s$3.isHandoffComplete);return e&&s$3.isHandoffComplete===!1&&f(!1),require$$0$1.useEffect(()=>{e!==!0&&f(!0);},[e]),require$$0$1.useEffect(()=>s$3.handoff(),[]),e}

    var o$2;let I$2=(o$2=require$$0__default["default"].useId)!=null?o$2:function(){let n=l$1(),[e,u]=require$$0__default["default"].useState(n?()=>s$3.nextId():null);return l$2(()=>{e===null&&u(s$3.nextId());},[e]),e!=null?""+e:void 0};

    function u$2(r,n,...a){if(r in n){let e=n[r];return typeof e=="function"?e(...a):e}let t=new Error(`Tried to handle "${r}" but there is no handler defined. Only defined handlers are: ${Object.keys(n).map(e=>`"${e}"`).join(", ")}.`);throw Error.captureStackTrace&&Error.captureStackTrace(t,u$2),t}

    function e$1(r){return s$3.isServer?null:r instanceof Node?r.ownerDocument:r!=null&&r.hasOwnProperty("current")&&r.current instanceof Node?r.current.ownerDocument:document}

    let f$3=["[contentEditable=true]","[tabindex]","a[href]","area[href]","button:not([disabled])","iframe","input:not([disabled])","select:not([disabled])","textarea:not([disabled])"].map(e=>`${e}:not([tabindex='-1'])`).join(",");var L$1=(r=>(r[r.First=1]="First",r[r.Previous=2]="Previous",r[r.Next=4]="Next",r[r.Last=8]="Last",r[r.WrapAround=16]="WrapAround",r[r.NoScroll=32]="NoScroll",r))(L$1||{}),N=(o=>(o[o.Error=0]="Error",o[o.Overflow=1]="Overflow",o[o.Success=2]="Success",o[o.Underflow=3]="Underflow",o))(N||{}),T$1=(n=>(n[n.Previous=-1]="Previous",n[n.Next=1]="Next",n))(T$1||{});function E(e=document.body){return e==null?[]:Array.from(e.querySelectorAll(f$3)).sort((t,n)=>Math.sign((t.tabIndex||Number.MAX_SAFE_INTEGER)-(n.tabIndex||Number.MAX_SAFE_INTEGER)))}var F$2=(n=>(n[n.Strict=0]="Strict",n[n.Loose=1]="Loose",n))(F$2||{});function h$1(e,t=0){var n;return e===((n=e$1(e))==null?void 0:n.body)?!1:u$2(t,{[0](){return e.matches(f$3)},[1](){let l=e;for(;l!==null;){if(l.matches(f$3))return !0;l=l.parentElement;}return !1}})}function g(e){let t=e$1(e);m$1().nextFrame(()=>{t&&!h$1(t.activeElement,0)&&S(e);});}function S(e){e==null||e.focus({preventScroll:!0});}let H=["textarea","input"].join(",");function w$1(e){var t,n;return (n=(t=e==null?void 0:e.matches)==null?void 0:t.call(e,H))!=null?n:!1}function A$1(e,t=n=>n){return e.slice().sort((n,l)=>{let o=t(n),i=t(l);if(o===null||i===null)return 0;let r=o.compareDocumentPosition(i);return r&Node.DOCUMENT_POSITION_FOLLOWING?-1:r&Node.DOCUMENT_POSITION_PRECEDING?1:0})}function v$1(e,t){return I$1(E(),t,{relativeTo:e})}function I$1(e,t,{sorted:n=!0,relativeTo:l=null,skipElements:o=[]}={}){let i=Array.isArray(e)?e.length>0?e[0].ownerDocument:document:e.ownerDocument,r=Array.isArray(e)?n?A$1(e):e:E(e);o.length>0&&r.length>1&&(r=r.filter(s=>!o.includes(s))),l=l!=null?l:i.activeElement;let d=(()=>{if(t&5)return 1;if(t&10)return -1;throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")})(),x=(()=>{if(t&1)return 0;if(t&2)return Math.max(0,r.indexOf(l))-1;if(t&4)return Math.max(0,r.indexOf(l))+1;if(t&8)return r.length-1;throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")})(),p=t&32?{preventScroll:!0}:{},c=0,a=r.length,u;do{if(c>=a||c+a<=0)return 0;let s=x+c;if(t&16)s=(s+a)%a;else {if(s<0)return 3;if(s>=a)return 1}u=r[s],u==null||u.focus(p),c+=d;}while(u!==i.activeElement);return t&6&&w$1(u)&&u.select(),u.hasAttribute("tabindex")||u.setAttribute("tabindex","0"),2}

    function d(e,r,n){let o=s$2(r);require$$0$1.useEffect(()=>{function t(u){o.current(u);}return document.addEventListener(e,t,n),()=>document.removeEventListener(e,t,n)},[e,n]);}

    function L(m,E,c=!0){let i=require$$0$1.useRef(!1);require$$0$1.useEffect(()=>{requestAnimationFrame(()=>{i.current=c;});},[c]);function f(e,o){if(!i.current||e.defaultPrevented)return;let l=function r(t){return typeof t=="function"?r(t()):Array.isArray(t)||t instanceof Set?t:[t]}(m),n=o(e);if(n!==null&&!!n.getRootNode().contains(n)){for(let r of l){if(r===null)continue;let t=r instanceof HTMLElement?r:r.current;if(t!=null&&t.contains(n)||e.composed&&e.composedPath().includes(t))return}return !h$1(n,F$2.Loose)&&n.tabIndex!==-1&&e.preventDefault(),E(e,n)}}let u=require$$0$1.useRef(null);d("mousedown",e=>{var o,l;i.current&&(u.current=((l=(o=e.composedPath)==null?void 0:o.call(e))==null?void 0:l[0])||e.target);},!0),d("click",e=>{!u.current||(f(e,()=>u.current),u.current=null);},!0),d("blur",e=>f(e,()=>window.document.activeElement instanceof HTMLIFrameElement?window.document.activeElement:null),!0);}

    function i$1(t){var n;if(t.type)return t.type;let e=(n=t.as)!=null?n:"button";if(typeof e=="string"&&e.toLowerCase()==="button")return "button"}function s$1(t,e){let[n,u]=require$$0$1.useState(()=>i$1(t));return l$2(()=>{u(i$1(t));},[t.type,t.as]),l$2(()=>{n||!e.current||e.current instanceof HTMLButtonElement&&!e.current.hasAttribute("type")&&u("button");},[n,e]),n}

    let u$1=Symbol();function y(...t){let n=require$$0$1.useRef(t);require$$0$1.useEffect(()=>{n.current=t;},[t]);let c=o$3(e=>{for(let o of n.current)o!=null&&(typeof o=="function"?o(e):o.current=e);});return t.every(e=>e==null||(e==null?void 0:e[u$1]))?void 0:c}

    function F$1({container:e,accept:t,walk:r,enabled:c=!0}){let o=require$$0$1.useRef(t),l=require$$0$1.useRef(r);require$$0$1.useEffect(()=>{o.current=t,l.current=r;},[t,r]),l$2(()=>{if(!e||!c)return;let n=e$1(e);if(!n)return;let f=o.current,p=l.current,d=Object.assign(i=>f(i),{acceptNode:f}),u=n.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,d,!1);for(;u.nextNode();)p(u.currentNode);},[e,c,o,l]);}

    function f$2(r){throw new Error("Unexpected object: "+r)}var a=(e=>(e[e.First=0]="First",e[e.Previous=1]="Previous",e[e.Next=2]="Next",e[e.Last=3]="Last",e[e.Specific=4]="Specific",e[e.Nothing=5]="Nothing",e))(a||{});function x(r,n){let t=n.resolveItems();if(t.length<=0)return null;let l=n.resolveActiveIndex(),s=l!=null?l:-1,d=(()=>{switch(r.focus){case 0:return t.findIndex(e=>!n.resolveDisabled(e));case 1:{let e=t.slice().reverse().findIndex((i,c,u)=>s!==-1&&u.length-c-1>=s?!1:!n.resolveDisabled(i));return e===-1?e:t.length-1-e}case 2:return t.findIndex((e,i)=>i<=s?!1:!n.resolveDisabled(e));case 3:{let e=t.slice().reverse().findIndex(i=>!n.resolveDisabled(i));return e===-1?e:t.length-1-e}case 4:return t.findIndex(e=>n.resolveId(e)===r.id);case 5:return null;default:f$2(r);}})();return d===-1?l:d}

    function e(...n){return n.filter(Boolean).join(" ")}

    var j=(a=>(a[a.None=0]="None",a[a.RenderStrategy=1]="RenderStrategy",a[a.Static=2]="Static",a))(j||{}),w=(e=>(e[e.Unmount=0]="Unmount",e[e.Hidden=1]="Hidden",e))(w||{});function X({ourProps:r,theirProps:t,slot:e,defaultTag:a,features:s,visible:n=!0,name:l}){let o=h(t,r);if(n)return m(o,e,a,l);let u=s!=null?s:0;if(u&2){let{static:i=!1,...d}=o;if(i)return m(d,e,a,l)}if(u&1){let{unmount:i=!0,...d}=o;return u$2(i?0:1,{[0](){return null},[1](){return m({...d,hidden:!0,style:{display:"none"}},e,a,l)}})}return m(o,e,a,l)}function m(r,t={},e$1,a){var y;let{as:s=e$1,children:n,refName:l="ref",...o}=T(r,["unmount","static"]),u=r.ref!==void 0?{[l]:r.ref}:{},i=typeof n=="function"?n(t):n;o.className&&typeof o.className=="function"&&(o.className=o.className(t));let d={};if(t){let f=!1,c=[];for(let[p,F]of Object.entries(t))typeof F=="boolean"&&(f=!0),F===!0&&c.push(p);f&&(d["data-headlessui-state"]=c.join(" "));}if(s===require$$0$1.Fragment&&Object.keys(P$1(o)).length>0){if(!require$$0$1.isValidElement(i)||Array.isArray(i)&&i.length>1)throw new Error(['Passing props on "Fragment"!',"",`The current component <${a} /> is rendering a "Fragment".`,"However we need to passthrough the following props:",Object.keys(o).map(p=>`  - ${p}`).join(`
`),"","You can apply a few solutions:",['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".',"Render a single element as the child so that we can forward the props onto that element."].map(p=>`  - ${p}`).join(`
`)].join(`
`));let f=e((y=i.props)==null?void 0:y.className,o.className),c=f?{className:f}:{};return require$$0$1.cloneElement(i,Object.assign({},h(i.props,P$1(T(o,["ref"]))),d,u,O$1(i.ref,u.ref),c))}return require$$0$1.createElement(s,Object.assign({},T(o,["ref"]),s!==require$$0$1.Fragment&&u,s!==require$$0$1.Fragment&&d),i)}function O$1(...r){return {ref:r.every(t=>t==null)?void 0:t=>{for(let e of r)e!=null&&(typeof e=="function"?e(t):e.current=t);}}}function h(...r){if(r.length===0)return {};if(r.length===1)return r[0];let t={},e={};for(let s of r)for(let n in s)n.startsWith("on")&&typeof s[n]=="function"?((e[n])!=null||(e[n]=[]),e[n].push(s[n])):t[n]=s[n];if(t.disabled||t["aria-disabled"])return Object.assign(t,Object.fromEntries(Object.keys(e).map(s=>[s,void 0])));for(let s in e)Object.assign(t,{[s](n,...l){let o=e[s];for(let u of o){if((n instanceof Event||(n==null?void 0:n.nativeEvent)instanceof Event)&&n.defaultPrevented)return;u(n,...l);}}});return t}function V(r){var t;return Object.assign(require$$0$1.forwardRef(r),{displayName:(t=r.displayName)!=null?t:r.name})}function P$1(r){let t=Object.assign({},r);for(let e in t)t[e]===void 0&&delete t[e];return t}function T(r,t=[]){let e=Object.assign({},r);for(let a of t)a in e&&delete e[a];return e}

    function r(n){let e=n.parentElement,l=null;for(;e&&!(e instanceof HTMLFieldSetElement);)e instanceof HTMLLegendElement&&(l=e),e=e.parentElement;let t=(e==null?void 0:e.getAttribute("disabled"))==="";return t&&i(l)?!1:t}function i(n){if(!n)return !1;let e=n.previousElementSibling;for(;e!==null;){if(e instanceof HTMLLegendElement)return !1;e=e.previousElementSibling;}return !0}

    let o$1=require$$0$1.createContext(null);o$1.displayName="OpenClosedContext";var p=(e=>(e[e.Open=0]="Open",e[e.Closed=1]="Closed",e))(p||{});function s(){return require$$0$1.useContext(o$1)}function C({value:t,children:n}){return require$$0__default["default"].createElement(o$1.Provider,{value:t},n)}

    var o=(r=>(r.Space=" ",r.Enter="Enter",r.Escape="Escape",r.Backspace="Backspace",r.Delete="Delete",r.ArrowLeft="ArrowLeft",r.ArrowUp="ArrowUp",r.ArrowRight="ArrowRight",r.ArrowDown="ArrowDown",r.Home="Home",r.End="End",r.PageUp="PageUp",r.PageDown="PageDown",r.Tab="Tab",r))(o||{});

    function t$1(e){return [e.screenX,e.screenY]}function u(){let e=require$$0$1.useRef([-1,-1]);return {wasMoved(r){let n=t$1(r);return e.current[0]===n[0]&&e.current[1]===n[1]?!1:(e.current=n,!0)},update(r){e.current=t$1(r);}}}

    function f$1(){let e=require$$0$1.useRef(!1);return l$2(()=>(e.current=!0,()=>{e.current=!1;}),[]),e}

    function n(...e){return require$$0$1.useMemo(()=>e$1(...e),[...e])}

    var pe=(o=>(o[o.Open=0]="Open",o[o.Closed=1]="Closed",o))(pe||{}),de$1=(o=>(o[o.Pointer=0]="Pointer",o[o.Other=1]="Other",o))(de$1||{}),me=(e=>(e[e.OpenMenu=0]="OpenMenu",e[e.CloseMenu=1]="CloseMenu",e[e.GoToItem=2]="GoToItem",e[e.Search=3]="Search",e[e.ClearSearch=4]="ClearSearch",e[e.RegisterItem=5]="RegisterItem",e[e.UnregisterItem=6]="UnregisterItem",e))(me||{});function U(t,i=o=>o){let o=t.activeItemIndex!==null?t.items[t.activeItemIndex]:null,s=A$1(i(t.items.slice()),u=>u.dataRef.current.domRef.current),a=o?s.indexOf(o):null;return a===-1&&(a=null),{items:s,activeItemIndex:a}}let fe={[1](t){return t.menuState===1?t:{...t,activeItemIndex:null,menuState:1}},[0](t){return t.menuState===0?t:{...t,menuState:0}},[2]:(t,i)=>{var a;let o=U(t),s=x(i,{resolveItems:()=>o.items,resolveActiveIndex:()=>o.activeItemIndex,resolveId:u=>u.id,resolveDisabled:u=>u.dataRef.current.disabled});return {...t,...o,searchQuery:"",activeItemIndex:s,activationTrigger:(a=i.trigger)!=null?a:1}},[3]:(t,i)=>{let s=t.searchQuery!==""?0:1,a=t.searchQuery+i.value.toLowerCase(),n=(t.activeItemIndex!==null?t.items.slice(t.activeItemIndex+s).concat(t.items.slice(0,t.activeItemIndex+s)):t.items).find(d=>{var l;return ((l=d.dataRef.current.textValue)==null?void 0:l.startsWith(a))&&!d.dataRef.current.disabled}),e=n?t.items.indexOf(n):-1;return e===-1||e===t.activeItemIndex?{...t,searchQuery:a}:{...t,searchQuery:a,activeItemIndex:e,activationTrigger:1}},[4](t){return t.searchQuery===""?t:{...t,searchQuery:"",searchActiveItemIndex:null}},[5]:(t,i)=>{let o=U(t,s=>[...s,{id:i.id,dataRef:i.dataRef}]);return {...t,...o}},[6]:(t,i)=>{let o=U(t,s=>{let a=s.findIndex(u=>u.id===i.id);return a!==-1&&s.splice(a,1),s});return {...t,...o,activationTrigger:1}}},G=require$$0$1.createContext(null);G.displayName="MenuContext";function O(t){let i=require$$0$1.useContext(G);if(i===null){let o=new Error(`<${t} /> is missing a parent <Menu /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(o,O),o}return i}function Te(t,i){return u$2(i.type,fe,t,i)}let ye=require$$0$1.Fragment,Ie=V(function(i,o){let s=require$$0$1.useReducer(Te,{menuState:1,buttonRef:require$$0$1.createRef(),itemsRef:require$$0$1.createRef(),items:[],searchQuery:"",activeItemIndex:null,activationTrigger:1}),[{menuState:a,itemsRef:u,buttonRef:n},e]=s,d=y(o);L([n,u],(R,A)=>{var g;e({type:1}),h$1(A,F$2.Loose)||(R.preventDefault(),(g=n.current)==null||g.focus());},a===0);let l=o$3(()=>{e({type:1});}),f=require$$0$1.useMemo(()=>({open:a===0,close:l}),[a,l]),M=i,T={ref:d};return require$$0__default["default"].createElement(G.Provider,{value:s},require$$0__default["default"].createElement(C,{value:u$2(a,{[0]:p.Open,[1]:p.Closed})},X({ourProps:T,theirProps:M,slot:f,defaultTag:ye,name:"Menu"})))}),ge$1="button",Me=V(function(i,o$1){var g;let s=I$2(),{id:a$1=`headlessui-menu-button-${s}`,...u}=i,[n,e]=O("Menu.Button"),d=y(n.buttonRef,o$1),l=p$1(),f=o$3(c=>{switch(c.key){case o.Space:case o.Enter:case o.ArrowDown:c.preventDefault(),c.stopPropagation(),e({type:0}),l.nextFrame(()=>e({type:2,focus:a.First}));break;case o.ArrowUp:c.preventDefault(),c.stopPropagation(),e({type:0}),l.nextFrame(()=>e({type:2,focus:a.Last}));break}}),M=o$3(c=>{switch(c.key){case o.Space:c.preventDefault();break}}),T=o$3(c=>{if(r(c.currentTarget))return c.preventDefault();i.disabled||(n.menuState===0?(e({type:1}),l.nextFrame(()=>{var b;return (b=n.buttonRef.current)==null?void 0:b.focus({preventScroll:!0})})):(c.preventDefault(),e({type:0})));}),R=require$$0$1.useMemo(()=>({open:n.menuState===0}),[n]),A={ref:d,id:a$1,type:s$1(i,n.buttonRef),"aria-haspopup":"menu","aria-controls":(g=n.itemsRef.current)==null?void 0:g.id,"aria-expanded":i.disabled?void 0:n.menuState===0,onKeyDown:f,onKeyUp:M,onClick:T};return X({ourProps:A,theirProps:u,slot:R,defaultTag:ge$1,name:"Menu.Button"})}),Re="div",be$1=j.RenderStrategy|j.Static,Ae=V(function(i,o$1){var b,S;let s$1=I$2(),{id:a$1=`headlessui-menu-items-${s$1}`,...u}=i,[n$1,e]=O("Menu.Items"),d=y(n$1.itemsRef,o$1),l=n(n$1.itemsRef),f=p$1(),M=s(),T=(()=>M!==null?M===p.Open:n$1.menuState===0)();require$$0$1.useEffect(()=>{let r=n$1.itemsRef.current;!r||n$1.menuState===0&&r!==(l==null?void 0:l.activeElement)&&r.focus({preventScroll:!0});},[n$1.menuState,n$1.itemsRef,l]),F$1({container:n$1.itemsRef.current,enabled:n$1.menuState===0,accept(r){return r.getAttribute("role")==="menuitem"?NodeFilter.FILTER_REJECT:r.hasAttribute("role")?NodeFilter.FILTER_SKIP:NodeFilter.FILTER_ACCEPT},walk(r){r.setAttribute("role","none");}});let R=o$3(r=>{var h,F;switch(f.dispose(),r.key){case o.Space:if(n$1.searchQuery!=="")return r.preventDefault(),r.stopPropagation(),e({type:3,value:r.key});case o.Enter:if(r.preventDefault(),r.stopPropagation(),e({type:1}),n$1.activeItemIndex!==null){let{dataRef:p}=n$1.items[n$1.activeItemIndex];(F=(h=p.current)==null?void 0:h.domRef.current)==null||F.click();}g(n$1.buttonRef.current);break;case o.ArrowDown:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:a.Next});case o.ArrowUp:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:a.Previous});case o.Home:case o.PageUp:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:a.First});case o.End:case o.PageDown:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:a.Last});case o.Escape:r.preventDefault(),r.stopPropagation(),e({type:1}),m$1().nextFrame(()=>{var p;return (p=n$1.buttonRef.current)==null?void 0:p.focus({preventScroll:!0})});break;case o.Tab:r.preventDefault(),r.stopPropagation(),e({type:1}),m$1().nextFrame(()=>{v$1(n$1.buttonRef.current,r.shiftKey?L$1.Previous:L$1.Next);});break;default:r.key.length===1&&(e({type:3,value:r.key}),f.setTimeout(()=>e({type:4}),350));break}}),A=o$3(r=>{switch(r.key){case o.Space:r.preventDefault();break}}),g$1=require$$0$1.useMemo(()=>({open:n$1.menuState===0}),[n$1]),c={"aria-activedescendant":n$1.activeItemIndex===null||(b=n$1.items[n$1.activeItemIndex])==null?void 0:b.id,"aria-labelledby":(S=n$1.buttonRef.current)==null?void 0:S.id,id:a$1,onKeyDown:R,onKeyUp:A,role:"menu",tabIndex:0,ref:d};return X({ourProps:c,theirProps:u,slot:g$1,defaultTag:Re,features:be$1,visible:T,name:"Menu.Items"})}),ve=require$$0$1.Fragment,Se$1=V(function(i,o){let s=I$2(),{id:a$1=`headlessui-menu-item-${s}`,disabled:u$1=!1,...n}=i,[e,d]=O("Menu.Item"),l=e.activeItemIndex!==null?e.items[e.activeItemIndex].id===a$1:!1,f=require$$0$1.useRef(null),M=y(o,f);l$2(()=>{if(e.menuState!==0||!l||e.activationTrigger===0)return;let p=m$1();return p.requestAnimationFrame(()=>{var v,B;(B=(v=f.current)==null?void 0:v.scrollIntoView)==null||B.call(v,{block:"nearest"});}),p.dispose},[f,l,e.menuState,e.activationTrigger,e.activeItemIndex]);let T=require$$0$1.useRef({disabled:u$1,domRef:f});l$2(()=>{T.current.disabled=u$1;},[T,u$1]),l$2(()=>{var p,v;T.current.textValue=(v=(p=f.current)==null?void 0:p.textContent)==null?void 0:v.toLowerCase();},[T,f]),l$2(()=>(d({type:5,id:a$1,dataRef:T}),()=>d({type:6,id:a$1})),[T,a$1]);let R=o$3(()=>{d({type:1});}),A=o$3(p=>{if(u$1)return p.preventDefault();d({type:1}),g(e.buttonRef.current);}),g$1=o$3(()=>{if(u$1)return d({type:2,focus:a.Nothing});d({type:2,focus:a.Specific,id:a$1});}),c=u(),b=o$3(p=>c.update(p)),S=o$3(p=>{!c.wasMoved(p)||u$1||l||d({type:2,focus:a.Specific,id:a$1,trigger:0});}),r=o$3(p=>{!c.wasMoved(p)||u$1||!l||d({type:2,focus:a.Nothing});}),h=require$$0$1.useMemo(()=>({active:l,disabled:u$1,close:R}),[l,u$1,R]);return X({ourProps:{id:a$1,ref:M,role:"menuitem",tabIndex:u$1===!0?void 0:-1,"aria-disabled":u$1===!0?!0:void 0,disabled:void 0,onClick:A,onFocus:g$1,onPointerEnter:b,onMouseEnter:b,onPointerMove:S,onMouseMove:S,onPointerLeave:r,onMouseLeave:r},theirProps:n,slot:h,defaultTag:ve,name:"Menu.Item"})}),Ze=Object.assign(Ie,{Button:Me,Items:Ae,Item:Se$1});

    function l(r){let e={called:!1};return (...t)=>{if(!e.called)return e.called=!0,r(...t)}}

    function v(t,...e){t&&e.length>0&&t.classList.add(...e);}function f(t,...e){t&&e.length>0&&t.classList.remove(...e);}function F(t,e){let n=m$1();if(!t)return n.dispose;let{transitionDuration:a,transitionDelay:i}=getComputedStyle(t),[m,d]=[a,i].map(o=>{let[r=0]=o.split(",").filter(Boolean).map(l=>l.includes("ms")?parseFloat(l):parseFloat(l)*1e3).sort((l,g)=>g-l);return r});if(m+d!==0){let o=n.addEventListener(t,"transitionend",r=>{r.target===r.currentTarget&&(e(),o());});}else e();return n.add(()=>e()),n.dispose}function M$1(t,e,n,a){let i=n?"enter":"leave",m=m$1(),d=a!==void 0?l(a):()=>{};i==="enter"&&(t.removeAttribute("hidden"),t.style.display="");let u=u$2(i,{enter:()=>e.enter,leave:()=>e.leave}),o=u$2(i,{enter:()=>e.enterTo,leave:()=>e.leaveTo}),r=u$2(i,{enter:()=>e.enterFrom,leave:()=>e.leaveFrom});return f(t,...e.enter,...e.enterTo,...e.enterFrom,...e.leave,...e.leaveFrom,...e.leaveTo,...e.entered),v(t,...u,...r),m.nextFrame(()=>{f(t,...r),v(t,...o),F(t,()=>(f(t,...u),v(t,...e.entered),d()));}),m.dispose}

    function D({container:i,direction:t,classes:o,onStart:s,onStop:u}){let a=f$1(),c=p$1(),r=s$2(t);l$2(()=>{let e=m$1();c.add(e.dispose);let n=i.current;if(!!n&&r.current!=="idle"&&!!a.current)return e.dispose(),s.current(r.current),e.add(M$1(n,o.current,r.current==="enter",()=>{e.dispose(),u.current(r.current);})),e.dispose},[t]);}

    function P(i=""){return i.split(" ").filter(e=>e.trim().length>1)}let A=require$$0$1.createContext(null);A.displayName="TransitionContext";var ge=(s=>(s.Visible="visible",s.Hidden="hidden",s))(ge||{});function be(){let i=require$$0$1.useContext(A);if(i===null)throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");return i}function Ee(){let i=require$$0$1.useContext(M);if(i===null)throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");return i}let M=require$$0$1.createContext(null);M.displayName="NestingContext";function I(i){return "children"in i?I(i.children):i.current.filter(({el:e})=>e.current!==null).filter(({state:e})=>e==="visible").length>0}function ne(i,e){let s=s$2(i),n=require$$0$1.useRef([]),m=f$1(),y=p$1(),b=o$3((l,r=w.Hidden)=>{let t=n.current.findIndex(({el:o})=>o===l);t!==-1&&(u$2(r,{[w.Unmount](){n.current.splice(t,1);},[w.Hidden](){n.current[t].state="hidden";}}),y.microTask(()=>{var o;!I(n)&&m.current&&((o=s.current)==null||o.call(s));}));}),E=o$3(l=>{let r=n.current.find(({el:t})=>t===l);return r?r.state!=="visible"&&(r.state="visible"):n.current.push({el:l,state:"visible"}),()=>b(l,w.Unmount)}),S=require$$0$1.useRef([]),u=require$$0$1.useRef(Promise.resolve()),p=require$$0$1.useRef({enter:[],leave:[],idle:[]}),d=o$3((l,r,t)=>{S.current.splice(0),e&&(e.chains.current[r]=e.chains.current[r].filter(([o])=>o!==l)),e==null||e.chains.current[r].push([l,new Promise(o=>{S.current.push(o);})]),e==null||e.chains.current[r].push([l,new Promise(o=>{Promise.all(p.current[r].map(([f,a])=>a)).then(()=>o());})]),r==="enter"?u.current=u.current.then(()=>e==null?void 0:e.wait.current).then(()=>t(r)):t(r);}),v=o$3((l,r,t)=>{Promise.all(p.current[r].splice(0).map(([o,f])=>f)).then(()=>{var o;(o=S.current.shift())==null||o();}).then(()=>t(r));});return require$$0$1.useMemo(()=>({children:n,register:E,unregister:b,onStart:d,onStop:v,wait:u,chains:p}),[E,b,n,d,v,p,u])}function Se(){}let xe=["beforeEnter","afterEnter","beforeLeave","afterLeave"];function re(i){var s;let e={};for(let n of xe)e[n]=(s=i[n])!=null?s:Se;return e}function Pe(i){let e=require$$0$1.useRef(re(i));return require$$0$1.useEffect(()=>{e.current=re(i);},[i]),e}let He="div",ie=j.RenderStrategy,oe=V(function(e$1,s){let{beforeEnter:n,afterEnter:m,beforeLeave:y$1,afterLeave:b,enter:E,enterFrom:S,enterTo:u,entered:p$1,leave:d,leaveFrom:v,leaveTo:l,...r}=e$1,t=require$$0$1.useRef(null),o=y(t,s),f=r.unmount?w.Unmount:w.Hidden,{show:a,appear:x,initial:se}=be(),[h,_]=require$$0$1.useState(a?"visible":"hidden"),K=Ee(),{register:D$1,unregister:V}=K,j=require$$0$1.useRef(null);require$$0$1.useEffect(()=>D$1(t),[D$1,t]),require$$0$1.useEffect(()=>{if(f===w.Hidden&&!!t.current){if(a&&h!=="visible"){_("visible");return}return u$2(h,{["hidden"]:()=>V(t),["visible"]:()=>D$1(t)})}},[h,t,D$1,V,a,f]);let U=s$2({enter:P(E),enterFrom:P(S),enterTo:P(u),entered:P(p$1),leave:P(d),leaveFrom:P(v),leaveTo:P(l)}),L=Pe({beforeEnter:n,afterEnter:m,beforeLeave:y$1,afterLeave:b}),k=l$1();require$$0$1.useEffect(()=>{if(k&&h==="visible"&&t.current===null)throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")},[t,h,k]);let G=se&&!x,le=(()=>!k||G||j.current===a?"idle":a?"enter":"leave")(),ae=o$3(C=>u$2(C,{enter:()=>L.current.beforeEnter(),leave:()=>L.current.beforeLeave(),idle:()=>{}})),ue=o$3(C=>u$2(C,{enter:()=>L.current.afterEnter(),leave:()=>L.current.afterLeave(),idle:()=>{}})),w$1=ne(()=>{_("hidden"),V(t);},K);D({container:t,classes:U,direction:le,onStart:s$2(C=>{w$1.onStart(t,C,ae);}),onStop:s$2(C=>{w$1.onStop(t,C,ue),C==="leave"&&!I(w$1)&&(_("hidden"),V(t));})}),require$$0$1.useEffect(()=>{!G||(f===w.Hidden?j.current=null:j.current=a);},[a,G,h]);let B=r,de={ref:o};return x&&a&&s$3.isServer&&(B={...B,className:e(r.className,...U.current.enter,...U.current.enterFrom)}),require$$0__default["default"].createElement(M.Provider,{value:w$1},require$$0__default["default"].createElement(C,{value:u$2(h,{["visible"]:p.Open,["hidden"]:p.Closed})},X({ourProps:de,theirProps:B,defaultTag:He,features:ie,visible:h==="visible",name:"Transition.Child"})))}),J=V(function(e,s$1){let{show:n,appear:m=!1,unmount:y$1,...b}=e,E=require$$0$1.useRef(null),S=y(E,s$1);l$1();let u=s();if(n===void 0&&u!==null&&(n=u$2(u,{[p.Open]:!0,[p.Closed]:!1})),![!0,!1].includes(n))throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");let[p$1,d]=require$$0$1.useState(n?"visible":"hidden"),v=ne(()=>{d("hidden");}),[l,r]=require$$0$1.useState(!0),t=require$$0$1.useRef([n]);l$2(()=>{l!==!1&&t.current[t.current.length-1]!==n&&(t.current.push(n),r(!1));},[t,n]);let o=require$$0$1.useMemo(()=>({show:n,appear:m,initial:l}),[n,m,l]);require$$0$1.useEffect(()=>{if(n)d("visible");else if(!I(v))d("hidden");else {let a=E.current;if(!a)return;let x=a.getBoundingClientRect();x.x===0&&x.y===0&&x.width===0&&x.height===0&&d("hidden");}},[n,v]);let f={unmount:y$1};return require$$0__default["default"].createElement(M.Provider,{value:v},require$$0__default["default"].createElement(A.Provider,{value:o},X({ourProps:{...f,as:require$$0$1.Fragment,children:require$$0__default["default"].createElement(oe,{ref:S,...f,...b})},theirProps:{},defaultTag:require$$0$1.Fragment,features:ie,visible:p$1==="visible",name:"Transition"})))}),Ne=V(function(e,s$1){let n=require$$0$1.useContext(A)!==null,m=s()!==null;return require$$0__default["default"].createElement(require$$0__default["default"].Fragment,null,!n&&m?require$$0__default["default"].createElement(J,{ref:s$1,...e}):require$$0__default["default"].createElement(oe,{ref:s$1,...e}))}),Ke=Object.assign(J,{Child:Ne,Root:J});

    var MessageDropdown = function (props) {
        var _a = require$$0$1.useState(false), isDropdownOpen = _a[0], setDropdownOpen = _a[1];
        var isMessageLong = require$$0$1.useMemo(function () { return props.messageLength > 25; }, []);
        return (require$$0__default["default"].createElement(Ze, { as: "div", className: classNames('absolute items-center group-hover:visible top-0 bottom-0 my-auto mx-0 h-min', props.myMessage ? '-left-8' : '-right-8', isDropdownOpen ? '!visible' : 'invisible') }, function (_a) {
            var open = _a.open;
            require$$0$1.useEffect(function () {
                setDropdownOpen(open);
            }, [open]);
            return (require$$0__default["default"].createElement(require$$0__default["default"].Fragment, null,
                require$$0__default["default"].createElement(Ze.Button
                // onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                //   e.stopPropagation()
                // }}
                , { 
                    // onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    //   e.stopPropagation()
                    // }}
                    className: "h-5 w-5 text-gray-500 hover:bg-gray-100 rounded-full my-auto" },
                    require$$0__default["default"].createElement(EllipsisHorizontalIcon, { className: "h-5 w-5" })),
                require$$0__default["default"].createElement(Ke, { as: require$$0$1.Fragment, enter: "transition ease-out duration-100", enterFrom: "transform opacity-0 scale-95", enterTo: "transform opacity-100 scale-100", leave: "transition ease-in duration-75", leaveFrom: "transform opacity-100 scale-100", leaveTo: "transform opacity-0 scale-95" },
                    require$$0__default["default"].createElement(Ze.Items, { className: classNames('absolute z-10 w-40 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none group-[:nth-last-child(2)]:bottom-[calc(100%_+_0.5rem)] @2xl:right-0 @2xl:left-auto', !isMessageLong && !props.isMediaAttached
                            ? '!left-auto !right-0'
                            : '', props.isMediaAttached
                            ? 'left-0 right-auto @2xl:!left-auto @2xl:!right-0'
                            : '') },
                        require$$0__default["default"].createElement("div", { className: "py-1" }, props.items.map(function (item, index) {
                            var disabled = false;
                            if ('isDisabled' in item) {
                                disabled = !!item.isDisabled;
                            }
                            return (require$$0__default["default"].createElement(Ze.Item, { disabled: disabled, key: index }, function (_a) {
                                var active = _a.active, disabled = _a.disabled;
                                return (require$$0__default["default"].createElement("span", { className: classNames(active
                                        ? 'bg-gray-100 text-gray-900'
                                        : 'text-gray-700', 'block px-4 py-2 text-sm cursor-pointer', (item === null || item === void 0 ? void 0 : item.textColorClass) ? item.textColorClass : '', disabled
                                        ? '!text-gray-400 !cursor-not-allowed'
                                        : ''), onClick: function (e) { return item.onClick(e); } }, item.label));
                            }));
                        }))))));
        }));
    };

    var Message = function (_a) {
        var _b, _c;
        var message = _a.message, _d = _a.divider, divider = _d === void 0 ? false : _d;
        var t = useTranslation().t;
        var rc = useRc().rc;
        var user = useAppSelector(function (state) { return state.user; }).user;
        var dispatch = useAppDispatch();
        var _e = useTheme(), theme = _e.theme, themes = _e.themes;
        var myMessage = require$$0$1.useMemo(function () {
            return (user === null || user === void 0 ? void 0 : user._id) === message.u._id;
        }, [user === null || user === void 0 ? void 0 : user._id, message.u._id]);
        var myMessageWrapperClasses = function () {
            if (myMessage) {
                return 'justify-end message-owner';
            }
            return '';
        };
        var myMessageContentClasses = function () {
            if (myMessage) {
                return theme === themes.TEAL ? '!bg-theme-teal-0' : '!bg-sky-50';
            }
            return '';
        };
        var items = [
            {
                label: t('DELETE'),
                onClick: function () { return __awaiter$5(void 0, void 0, void 0, function () {
                    return __generator$5(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, rc.deleteMessage(message.rid, message._id)];
                            case 1:
                                _a.sent();
                                dispatch(removeOne(message._id));
                                return [2 /*return*/];
                        }
                    });
                }); },
                isDisabled: false,
                textColorClass: '!text-red-500',
            },
        ];
        return (require$$0__default["default"].createElement("div", { className: classNames('message flex mb-2 w-100 mx-4 flex-wrap items-end group', myMessageWrapperClasses()) },
            divider ? require$$0__default["default"].createElement(MessageDivider, { message: message }) : null,
            !myMessage ? (require$$0__default["default"].createElement(Avatar, { height: 24, width: 24, username: message.u.username })) : null,
            require$$0__default["default"].createElement("div", { className: classNames('flex flex-col relative ml-2 bg-gray-100 rounded-md max-w-[calc(100%_-_2.31rem)]', myMessageContentClasses()) },
                ((_b = message.attachments) === null || _b === void 0 ? void 0 : _b.length) ? (require$$0__default["default"].createElement(Attachments, { attachments: message.attachments })) : null,
                message.msg ? require$$0__default["default"].createElement(MessageBody, { message: message }) : null,
                require$$0__default["default"].createElement(MessageFooter, { message: message }),
                myMessage ? (require$$0__default["default"].createElement(MessageDropdown, { isMediaAttached: ((_c = message.attachments) === null || _c === void 0 ? void 0 : _c.length) ? true : false, myMessage: myMessage, items: items, messageLength: message.msg ? message.msg.length : 0 })) : null)));
    };

    function Spinner(_a) {
        var _b = _a.cssClasses, cssClasses = _b === void 0 ? 'inline mr-3 text-gray-400 animate-spin fill-white' : _b, size = _a.size;
        if (!!size && size === 'small') {
            cssClasses += ' h-3 w-3 mb-0.5';
        }
        else {
            cssClasses += ' h-4 w-4';
        }
        return (React.createElement("svg", { role: "status", className: cssClasses, viewBox: "0 0 100 101", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            React.createElement("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor" }),
            React.createElement("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })));
    }

    var List = require$$0__default["default"].forwardRef(function (_a, ref) {
        var messages = _a.messages, loadMore = _a.loadMore, isLoading = _a.isLoading;
        var observerRef = require$$0$1.useRef(null);
        var _b = require$$0$1.useState(false), loadMoreVisible = _b[0], setLoadMoreVisible = _b[1];
        var _c = require$$0$1.useState(false), isReady = _c[0], setIsReady = _c[1];
        var observerHandler = function (entries) {
            var target = entries[0];
            if (target.isIntersecting) {
                setLoadMoreVisible(true);
            }
            else {
                setLoadMoreVisible(false);
            }
        };
        var scrollDown = require$$0$1.useCallback(function () {
            if (!(ref === null || ref === void 0 ? void 0 : ref.current))
                return;
            ref.current.scrollIntoView({});
        }, [ref]);
        require$$0$1.useEffect(function () {
            if (loadMoreVisible && isReady) {
                loadMore();
            }
        }, [loadMoreVisible]);
        require$$0$1.useEffect(function () {
            var observer = new IntersectionObserver(observerHandler, {
                threshold: 0
            });
            if (observerRef.current) {
                observer.observe(observerRef.current);
            }
            return function () {
                if (observerRef.current)
                    observer.unobserve(observerRef.current);
            };
        }, []);
        require$$0$1.useEffect(function () {
            if (messages.length) {
                setIsReady(true);
            }
        }, [messages.length]);
        require$$0$1.useEffect(function () {
            scrollDown();
        }, [isReady]);
        var isMessageNewDay = function (current, previous) {
            return !previous || !isSameDay(new Date(current.ts), new Date(previous.ts));
        };
        return (require$$0__default["default"].createElement("div", { className: '@container overflow-y-scroll overflow-x-hidden flex-1' },
            require$$0__default["default"].createElement("div", { className: 'loader h-20 flex justify-center items-center', ref: observerRef }, isLoading ? require$$0__default["default"].createElement(Spinner, null) : null),
            messages.map(function (message, index, list) {
                var prev = list[index > 0 ? index - 1 : 0];
                var isNewDay = isMessageNewDay(message, prev);
                return (require$$0__default["default"].createElement(Message, { key: message._id, divider: isNewDay, message: message }));
            }),
            require$$0__default["default"].createElement("div", { className: 'h-1', ref: ref })));
    });

    // src/subscribable.ts
    var Subscribable = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        this.listeners.add(listener);
        this.onSubscribe();
        return () => {
          this.listeners.delete(listener);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    };

    // src/utils.ts
    var isServer = typeof window === "undefined" || "Deno" in window;
    function noop$1() {
      return void 0;
    }
    function functionalUpdate(updater, input) {
      return typeof updater === "function" ? updater(input) : updater;
    }
    function isValidTimeout(value) {
      return typeof value === "number" && value >= 0 && value !== Infinity;
    }
    function timeUntilStale(updatedAt, staleTime) {
      return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
    }
    function matchQuery(filters, query) {
      const {
        type = "all",
        exact,
        fetchStatus,
        predicate,
        queryKey,
        stale
      } = filters;
      if (queryKey) {
        if (exact) {
          if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
            return false;
          }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
          return false;
        }
      }
      if (type !== "all") {
        const isActive = query.isActive();
        if (type === "active" && !isActive) {
          return false;
        }
        if (type === "inactive" && isActive) {
          return false;
        }
      }
      if (typeof stale === "boolean" && query.isStale() !== stale) {
        return false;
      }
      if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
        return false;
      }
      if (predicate && !predicate(query)) {
        return false;
      }
      return true;
    }
    function matchMutation(filters, mutation) {
      const { exact, status, predicate, mutationKey } = filters;
      if (mutationKey) {
        if (!mutation.options.mutationKey) {
          return false;
        }
        if (exact) {
          if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
            return false;
          }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
          return false;
        }
      }
      if (status && mutation.state.status !== status) {
        return false;
      }
      if (predicate && !predicate(mutation)) {
        return false;
      }
      return true;
    }
    function hashQueryKeyByOptions(queryKey, options) {
      const hashFn = options?.queryKeyHashFn || hashKey;
      return hashFn(queryKey);
    }
    function hashKey(queryKey) {
      return JSON.stringify(
        queryKey,
        (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
          result[key] = val[key];
          return result;
        }, {}) : val
      );
    }
    function partialMatchKey(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      if (a && b && typeof a === "object" && typeof b === "object") {
        return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));
      }
      return false;
    }
    function replaceEqualDeep(a, b) {
      if (a === b) {
        return a;
      }
      const array = isPlainArray(a) && isPlainArray(b);
      if (array || isPlainObject(a) && isPlainObject(b)) {
        const aSize = array ? a.length : Object.keys(a).length;
        const bItems = array ? b : Object.keys(b);
        const bSize = bItems.length;
        const copy = array ? [] : {};
        let equalItems = 0;
        for (let i = 0; i < bSize; i++) {
          const key = array ? i : bItems[i];
          copy[key] = replaceEqualDeep(a[key], b[key]);
          if (copy[key] === a[key]) {
            equalItems++;
          }
        }
        return aSize === bSize && equalItems === aSize ? a : copy;
      }
      return b;
    }
    function shallowEqualObjects(a, b) {
      if (a && !b || b && !a) {
        return false;
      }
      for (const key in a) {
        if (a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
    function isPlainArray(value) {
      return Array.isArray(value) && value.length === Object.keys(value).length;
    }
    function isPlainObject(o) {
      if (!hasObjectPrototype(o)) {
        return false;
      }
      const ctor = o.constructor;
      if (typeof ctor === "undefined") {
        return true;
      }
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    function replaceData(prevData, data, options) {
      if (typeof options.structuralSharing === "function") {
        return options.structuralSharing(prevData, data);
      } else if (options.structuralSharing !== false) {
        return replaceEqualDeep(prevData, data);
      }
      return data;
    }
    function addToEnd(items, item, max = 0) {
      const newItems = [...items, item];
      return max && newItems.length > max ? newItems.slice(1) : newItems;
    }
    function addToStart(items, item, max = 0) {
      const newItems = [item, ...items];
      return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
    }

    // src/focusManager.ts
    var FocusManager = class extends Subscribable {
      #focused;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onFocus) => {
          if (!isServer && window.addEventListener) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup) {
        this.#setup = setup;
        this.#cleanup?.();
        this.#cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.#focused !== focused;
        if (changed) {
          this.#focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        this.listeners.forEach((listener) => {
          listener();
        });
      }
      isFocused() {
        if (typeof this.#focused === "boolean") {
          return this.#focused;
        }
        return globalThis.document?.visibilityState !== "hidden";
      }
    };
    var focusManager = new FocusManager();

    // src/onlineManager.ts
    var OnlineManager = class extends Subscribable {
      #online = true;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onOnline) => {
          if (!isServer && window.addEventListener) {
            const onlineListener = () => onOnline(true);
            const offlineListener = () => onOnline(false);
            window.addEventListener("online", onlineListener, false);
            window.addEventListener("offline", offlineListener, false);
            return () => {
              window.removeEventListener("online", onlineListener);
              window.removeEventListener("offline", offlineListener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup) {
        this.#setup = setup;
        this.#cleanup?.();
        this.#cleanup = setup(this.setOnline.bind(this));
      }
      setOnline(online) {
        const changed = this.#online !== online;
        if (changed) {
          this.#online = online;
          this.listeners.forEach((listener) => {
            listener(online);
          });
        }
      }
      isOnline() {
        return this.#online;
      }
    };
    var onlineManager = new OnlineManager();

    // src/retryer.ts
    function defaultRetryDelay(failureCount) {
      return Math.min(1e3 * 2 ** failureCount, 3e4);
    }
    function canFetch(networkMode) {
      return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
    }
    var CancelledError = class {
      constructor(options) {
        this.revert = options?.revert;
        this.silent = options?.silent;
      }
    };
    function isCancelledError(value) {
      return value instanceof CancelledError;
    }
    function createRetryer(config) {
      let isRetryCancelled = false;
      let failureCount = 0;
      let isResolved = false;
      let continueFn;
      let promiseResolve;
      let promiseReject;
      const promise = new Promise((outerResolve, outerReject) => {
        promiseResolve = outerResolve;
        promiseReject = outerReject;
      });
      const cancel = (cancelOptions) => {
        if (!isResolved) {
          reject(new CancelledError(cancelOptions));
          config.abort?.();
        }
      };
      const cancelRetry = () => {
        isRetryCancelled = true;
      };
      const continueRetry = () => {
        isRetryCancelled = false;
      };
      const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
      const resolve = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onSuccess?.(value);
          continueFn?.();
          promiseResolve(value);
        }
      };
      const reject = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onError?.(value);
          continueFn?.();
          promiseReject(value);
        }
      };
      const pause = () => {
        return new Promise((continueResolve) => {
          continueFn = (value) => {
            const canContinue = isResolved || !shouldPause();
            if (canContinue) {
              continueResolve(value);
            }
            return canContinue;
          };
          config.onPause?.();
        }).then(() => {
          continueFn = void 0;
          if (!isResolved) {
            config.onContinue?.();
          }
        });
      };
      const run = () => {
        if (isResolved) {
          return;
        }
        let promiseOrValue;
        try {
          promiseOrValue = config.fn();
        } catch (error) {
          promiseOrValue = Promise.reject(error);
        }
        Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
          if (isResolved) {
            return;
          }
          const retry = config.retry ?? (isServer ? 0 : 3);
          const retryDelay = config.retryDelay ?? defaultRetryDelay;
          const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
          const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
          if (isRetryCancelled || !shouldRetry) {
            reject(error);
            return;
          }
          failureCount++;
          config.onFail?.(failureCount, error);
          sleep(delay).then(() => {
            if (shouldPause()) {
              return pause();
            }
            return;
          }).then(() => {
            if (isRetryCancelled) {
              reject(error);
            } else {
              run();
            }
          });
        });
      };
      if (canFetch(config.networkMode)) {
        run();
      } else {
        pause().then(run);
      }
      return {
        promise,
        cancel,
        continue: () => {
          const didContinue = continueFn?.();
          return didContinue ? promise : Promise.resolve();
        },
        cancelRetry,
        continueRetry
      };
    }

    // src/notifyManager.ts
    function createNotifyManager() {
      let queue = [];
      let transactions = 0;
      let notifyFn = (callback) => {
        callback();
      };
      let batchNotifyFn = (callback) => {
        callback();
      };
      let scheduleFn = (cb) => setTimeout(cb, 0);
      const setScheduler = (fn) => {
        scheduleFn = fn;
      };
      const batch = (callback) => {
        let result;
        transactions++;
        try {
          result = callback();
        } finally {
          transactions--;
          if (!transactions) {
            flush();
          }
        }
        return result;
      };
      const schedule = (callback) => {
        if (transactions) {
          queue.push(callback);
        } else {
          scheduleFn(() => {
            notifyFn(callback);
          });
        }
      };
      const batchCalls = (callback) => {
        return (...args) => {
          schedule(() => {
            callback(...args);
          });
        };
      };
      const flush = () => {
        const originalQueue = queue;
        queue = [];
        if (originalQueue.length) {
          scheduleFn(() => {
            batchNotifyFn(() => {
              originalQueue.forEach((callback) => {
                notifyFn(callback);
              });
            });
          });
        }
      };
      const setNotifyFunction = (fn) => {
        notifyFn = fn;
      };
      const setBatchNotifyFunction = (fn) => {
        batchNotifyFn = fn;
      };
      return {
        batch,
        batchCalls,
        schedule,
        setNotifyFunction,
        setBatchNotifyFunction,
        setScheduler
      };
    }
    var notifyManager = createNotifyManager();

    // src/removable.ts
    var Removable = class {
      #gcTimeout;
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (isValidTimeout(this.gcTime)) {
          this.#gcTimeout = setTimeout(() => {
            this.optionalRemove();
          }, this.gcTime);
        }
      }
      updateGcTime(newGcTime) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
        );
      }
      clearGcTimeout() {
        if (this.#gcTimeout) {
          clearTimeout(this.#gcTimeout);
          this.#gcTimeout = void 0;
        }
      }
    };

    // src/query.ts
    var Query = class extends Removable {
      constructor(config) {
        super();
        this.#abortSignalConsumed = false;
        this.#defaultOptions = config.defaultOptions;
        this.#setOptions(config.options);
        this.#observers = [];
        this.#cache = config.cache;
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.#initialState = config.state || getDefaultState$1(this.options);
        this.state = this.#initialState;
        this.scheduleGc();
      }
      #initialState;
      #revertState;
      #cache;
      #promise;
      #retryer;
      #observers;
      #defaultOptions;
      #abortSignalConsumed;
      get meta() {
        return this.options.meta;
      }
      #setOptions(options) {
        this.options = { ...this.#defaultOptions, ...options };
        this.updateGcTime(this.options.gcTime);
      }
      optionalRemove() {
        if (!this.#observers.length && this.state.fetchStatus === "idle") {
          this.#cache.remove(this);
        }
      }
      setData(newData, options) {
        const data = replaceData(this.state.data, newData, this.options);
        this.#dispatch({
          data,
          type: "success",
          dataUpdatedAt: options?.updatedAt,
          manual: options?.manual
        });
        return data;
      }
      setState(state, setStateOptions) {
        this.#dispatch({ type: "setState", state, setStateOptions });
      }
      cancel(options) {
        const promise = this.#promise;
        this.#retryer?.cancel(options);
        return promise ? promise.then(noop$1).catch(noop$1) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({ silent: true });
      }
      reset() {
        this.destroy();
        this.setState(this.#initialState);
      }
      isActive() {
        return this.#observers.some(
          (observer) => observer.options.enabled !== false
        );
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.#observers.some((observer) => observer.getCurrentResult().isStale);
      }
      isStaleByTime(staleTime = 0) {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus());
        observer?.refetch({ cancelRefetch: false });
        this.#retryer?.continue();
      }
      onOnline() {
        const observer = this.#observers.find((x) => x.shouldFetchOnReconnect());
        observer?.refetch({ cancelRefetch: false });
        this.#retryer?.continue();
      }
      addObserver(observer) {
        if (!this.#observers.includes(observer)) {
          this.#observers.push(observer);
          this.clearGcTimeout();
          this.#cache.notify({ type: "observerAdded", query: this, observer });
        }
      }
      removeObserver(observer) {
        if (this.#observers.includes(observer)) {
          this.#observers = this.#observers.filter((x) => x !== observer);
          if (!this.#observers.length) {
            if (this.#retryer) {
              if (this.#abortSignalConsumed) {
                this.#retryer.cancel({ revert: true });
              } else {
                this.#retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.#cache.notify({ type: "observerRemoved", query: this, observer });
        }
      }
      getObserversCount() {
        return this.#observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.#dispatch({ type: "invalidate" });
        }
      }
      fetch(options, fetchOptions) {
        if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {
            this.cancel({ silent: true });
          } else if (this.#promise) {
            this.#retryer?.continueRetry();
            return this.#promise;
          }
        }
        if (options) {
          this.#setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.#observers.find((x) => x.options.queryFn);
          if (observer) {
            this.#setOptions(observer.options);
          }
        }
        const abortController = new AbortController();
        const queryFnContext = {
          queryKey: this.queryKey,
          meta: this.meta
        };
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              this.#abortSignalConsumed = true;
              return abortController.signal;
            }
          });
        };
        addSignalProperty(queryFnContext);
        const fetchFn = () => {
          if (!this.options.queryFn) {
            return Promise.reject(
              new Error(`Missing queryFn: '${this.options.queryHash}'`)
            );
          }
          this.#abortSignalConsumed = false;
          if (this.options.persister) {
            return this.options.persister(
              this.options.queryFn,
              queryFnContext,
              this
            );
          }
          return this.options.queryFn(
            queryFnContext
          );
        };
        const context = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn
        };
        addSignalProperty(context);
        this.options.behavior?.onFetch(
          context,
          this
        );
        this.#revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
          this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
        }
        const onError = (error) => {
          if (!(isCancelledError(error) && error.silent)) {
            this.#dispatch({
              type: "error",
              error
            });
          }
          if (!isCancelledError(error)) {
            this.#cache.config.onError?.(
              error,
              this
            );
            this.#cache.config.onSettled?.(
              this.state.data,
              error,
              this
            );
          }
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        };
        this.#retryer = createRetryer({
          fn: context.fetchFn,
          abort: abortController.abort.bind(abortController),
          onSuccess: (data) => {
            if (typeof data === "undefined") {
              onError(new Error(`${this.queryHash} data is undefined`));
              return;
            }
            this.setData(data);
            this.#cache.config.onSuccess?.(data, this);
            this.#cache.config.onSettled?.(
              data,
              this.state.error,
              this
            );
            if (!this.isFetchingOptimistic) {
              this.scheduleGc();
            }
            this.isFetchingOptimistic = false;
          },
          onError,
          onFail: (failureCount, error) => {
            this.#dispatch({ type: "failed", failureCount, error });
          },
          onPause: () => {
            this.#dispatch({ type: "pause" });
          },
          onContinue: () => {
            this.#dispatch({ type: "continue" });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode
        });
        this.#promise = this.#retryer.promise;
        return this.#promise;
      }
      #dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: action.meta ?? null,
                fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
                ...!state.dataUpdatedAt && {
                  error: null,
                  status: "pending"
                }
              };
            case "success":
              return {
                ...state,
                data: action.data,
                dataUpdateCount: state.dataUpdateCount + 1,
                dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
            case "error":
              const error = action.error;
              if (isCancelledError(error) && error.revert && this.#revertState) {
                return { ...this.#revertState, fetchStatus: "idle" };
              }
              return {
                ...state,
                error,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.#observers.forEach((observer) => {
            observer.onQueryUpdate();
          });
          this.#cache.notify({ query: this, type: "updated", action });
        });
      }
    };
    function getDefaultState$1(options) {
      const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
      const hasData = typeof data !== "undefined";
      const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
      return {
        data,
        dataUpdateCount: 0,
        dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: false,
        status: hasData ? "success" : "pending",
        fetchStatus: "idle"
      };
    }

    // src/queryCache.ts
    var QueryCache = class extends Subscribable {
      constructor(config = {}) {
        super();
        this.config = config;
        this.#queries = /* @__PURE__ */ new Map();
      }
      #queries;
      build(client, options, state) {
        const queryKey = options.queryKey;
        const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
        let query = this.get(queryHash);
        if (!query) {
          query = new Query({
            cache: this,
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query);
        }
        return query;
      }
      add(query) {
        if (!this.#queries.has(query.queryHash)) {
          this.#queries.set(query.queryHash, query);
          this.notify({
            type: "added",
            query
          });
        }
      }
      remove(query) {
        const queryInMap = this.#queries.get(query.queryHash);
        if (queryInMap) {
          query.destroy();
          if (queryInMap === query) {
            this.#queries.delete(query.queryHash);
          }
          this.notify({ type: "removed", query });
        }
      }
      clear() {
        notifyManager.batch(() => {
          this.getAll().forEach((query) => {
            this.remove(query);
          });
        });
      }
      get(queryHash) {
        return this.#queries.get(queryHash);
      }
      getAll() {
        return [...this.#queries.values()];
      }
      find(filters) {
        const defaultedFilters = { exact: true, ...filters };
        return this.getAll().find(
          (query) => matchQuery(defaultedFilters, query)
        );
      }
      findAll(filters = {}) {
        const queries = this.getAll();
        return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.batch(() => {
          this.getAll().forEach((query) => {
            query.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.batch(() => {
          this.getAll().forEach((query) => {
            query.onOnline();
          });
        });
      }
    };

    // src/mutation.ts
    var Mutation = class extends Removable {
      constructor(config) {
        super();
        this.mutationId = config.mutationId;
        this.#defaultOptions = config.defaultOptions;
        this.#mutationCache = config.mutationCache;
        this.#observers = [];
        this.state = config.state || getDefaultState();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      #observers;
      #defaultOptions;
      #mutationCache;
      #retryer;
      setOptions(options) {
        this.options = { ...this.#defaultOptions, ...options };
        this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(observer) {
        if (!this.#observers.includes(observer)) {
          this.#observers.push(observer);
          this.clearGcTimeout();
          this.#mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.#observers = this.#observers.filter((x) => x !== observer);
        this.scheduleGc();
        this.#mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.#observers.length) {
          if (this.state.status === "pending") {
            this.scheduleGc();
          } else {
            this.#mutationCache.remove(this);
          }
        }
      }
      continue() {
        return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
        this.execute(this.state.variables);
      }
      async execute(variables) {
        const executeMutation = () => {
          this.#retryer = createRetryer({
            fn: () => {
              if (!this.options.mutationFn) {
                return Promise.reject(new Error("No mutationFn found"));
              }
              return this.options.mutationFn(variables);
            },
            onFail: (failureCount, error) => {
              this.#dispatch({ type: "failed", failureCount, error });
            },
            onPause: () => {
              this.#dispatch({ type: "pause" });
            },
            onContinue: () => {
              this.#dispatch({ type: "continue" });
            },
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode
          });
          return this.#retryer.promise;
        };
        const restored = this.state.status === "pending";
        try {
          if (!restored) {
            this.#dispatch({ type: "pending", variables });
            await this.#mutationCache.config.onMutate?.(
              variables,
              this
            );
            const context = await this.options.onMutate?.(variables);
            if (context !== this.state.context) {
              this.#dispatch({
                type: "pending",
                context,
                variables
              });
            }
          }
          const data = await executeMutation();
          await this.#mutationCache.config.onSuccess?.(
            data,
            variables,
            this.state.context,
            this
          );
          await this.options.onSuccess?.(data, variables, this.state.context);
          await this.#mutationCache.config.onSettled?.(
            data,
            null,
            this.state.variables,
            this.state.context,
            this
          );
          await this.options.onSettled?.(data, null, variables, this.state.context);
          this.#dispatch({ type: "success", data });
          return data;
        } catch (error) {
          try {
            await this.#mutationCache.config.onError?.(
              error,
              variables,
              this.state.context,
              this
            );
            await this.options.onError?.(
              error,
              variables,
              this.state.context
            );
            await this.#mutationCache.config.onSettled?.(
              void 0,
              error,
              this.state.variables,
              this.state.context,
              this
            );
            await this.options.onSettled?.(
              void 0,
              error,
              variables,
              this.state.context
            );
            throw error;
          } finally {
            this.#dispatch({ type: "error", error });
          }
        }
      }
      #dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state,
                isPaused: true
              };
            case "continue":
              return {
                ...state,
                isPaused: false
              };
            case "pending":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: !canFetch(this.options.networkMode),
                status: "pending",
                variables: action.variables,
                submittedAt: Date.now()
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.#observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.#mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    };
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: false,
        status: "idle",
        variables: void 0,
        submittedAt: 0
      };
    }

    // src/mutationCache.ts
    var MutationCache = class extends Subscribable {
      constructor(config = {}) {
        super();
        this.config = config;
        this.#mutations = [];
        this.#mutationId = 0;
      }
      #mutations;
      #mutationId;
      #resuming;
      build(client, options, state) {
        const mutation = new Mutation({
          mutationCache: this,
          mutationId: ++this.#mutationId,
          options: client.defaultMutationOptions(options),
          state
        });
        this.add(mutation);
        return mutation;
      }
      add(mutation) {
        this.#mutations.push(mutation);
        this.notify({ type: "added", mutation });
      }
      remove(mutation) {
        this.#mutations = this.#mutations.filter((x) => x !== mutation);
        this.notify({ type: "removed", mutation });
      }
      clear() {
        notifyManager.batch(() => {
          this.#mutations.forEach((mutation) => {
            this.remove(mutation);
          });
        });
      }
      getAll() {
        return this.#mutations;
      }
      find(filters) {
        const defaultedFilters = { exact: true, ...filters };
        return this.#mutations.find(
          (mutation) => matchMutation(defaultedFilters, mutation)
        );
      }
      findAll(filters = {}) {
        return this.#mutations.filter(
          (mutation) => matchMutation(filters, mutation)
        );
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        this.#resuming = (this.#resuming ?? Promise.resolve()).then(() => {
          const pausedMutations = this.#mutations.filter((x) => x.state.isPaused);
          return notifyManager.batch(
            () => pausedMutations.reduce(
              (promise, mutation) => promise.then(() => mutation.continue().catch(noop$1)),
              Promise.resolve()
            )
          );
        }).then(() => {
          this.#resuming = void 0;
        });
        return this.#resuming;
      }
    };

    // src/infiniteQueryBehavior.ts
    function infiniteQueryBehavior(pages) {
      return {
        onFetch: (context, query) => {
          const fetchFn = async () => {
            const options = context.options;
            const direction = context.fetchOptions?.meta?.fetchMore?.direction;
            const oldPages = context.state.data?.pages || [];
            const oldPageParams = context.state.data?.pageParams || [];
            const empty = { pages: [], pageParams: [] };
            let cancelled = false;
            const addSignalProperty = (object) => {
              Object.defineProperty(object, "signal", {
                enumerable: true,
                get: () => {
                  if (context.signal.aborted) {
                    cancelled = true;
                  } else {
                    context.signal.addEventListener("abort", () => {
                      cancelled = true;
                    });
                  }
                  return context.signal;
                }
              });
            };
            const queryFn = context.options.queryFn || (() => Promise.reject(
              new Error(`Missing queryFn: '${context.options.queryHash}'`)
            ));
            const fetchPage = async (data, param, previous) => {
              if (cancelled) {
                return Promise.reject();
              }
              if (param == null && data.pages.length) {
                return Promise.resolve(data);
              }
              const queryFnContext = {
                queryKey: context.queryKey,
                pageParam: param,
                direction: previous ? "backward" : "forward",
                meta: context.options.meta
              };
              addSignalProperty(queryFnContext);
              const page = await queryFn(
                queryFnContext
              );
              const { maxPages } = context.options;
              const addTo = previous ? addToStart : addToEnd;
              return {
                pages: addTo(data.pages, page, maxPages),
                pageParams: addTo(data.pageParams, param, maxPages)
              };
            };
            let result;
            if (direction && oldPages.length) {
              const previous = direction === "backward";
              const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
              const oldData = {
                pages: oldPages,
                pageParams: oldPageParams
              };
              const param = pageParamFn(options, oldData);
              result = await fetchPage(oldData, param, previous);
            } else {
              result = await fetchPage(
                empty,
                oldPageParams[0] ?? options.initialPageParam
              );
              const remainingPages = pages ?? oldPages.length;
              for (let i = 1; i < remainingPages; i++) {
                const param = getNextPageParam(options, result);
                result = await fetchPage(result, param);
              }
            }
            return result;
          };
          if (context.options.persister) {
            context.fetchFn = () => {
              return context.options.persister?.(
                fetchFn,
                {
                  queryKey: context.queryKey,
                  meta: context.options.meta,
                  signal: context.signal
                },
                query
              );
            };
          } else {
            context.fetchFn = fetchFn;
          }
        }
      };
    }
    function getNextPageParam(options, { pages, pageParams }) {
      const lastIndex = pages.length - 1;
      return options.getNextPageParam(
        pages[lastIndex],
        pages,
        pageParams[lastIndex],
        pageParams
      );
    }
    function getPreviousPageParam(options, { pages, pageParams }) {
      return options.getPreviousPageParam?.(
        pages[0],
        pages,
        pageParams[0],
        pageParams
      );
    }
    function hasNextPage(options, data) {
      if (!data)
        return false;
      return getNextPageParam(options, data) != null;
    }
    function hasPreviousPage(options, data) {
      if (!data || !options.getPreviousPageParam)
        return false;
      return getPreviousPageParam(options, data) != null;
    }

    // src/queryClient.ts
    var QueryClient = class {
      #queryCache;
      #mutationCache;
      #defaultOptions;
      #queryDefaults;
      #mutationDefaults;
      #mountCount;
      #unsubscribeFocus;
      #unsubscribeOnline;
      constructor(config = {}) {
        this.#queryCache = config.queryCache || new QueryCache();
        this.#mutationCache = config.mutationCache || new MutationCache();
        this.#defaultOptions = config.defaultOptions || {};
        this.#queryDefaults = /* @__PURE__ */ new Map();
        this.#mutationDefaults = /* @__PURE__ */ new Map();
        this.#mountCount = 0;
      }
      mount() {
        this.#mountCount++;
        if (this.#mountCount !== 1)
          return;
        this.#unsubscribeFocus = focusManager.subscribe(() => {
          if (focusManager.isFocused()) {
            this.resumePausedMutations();
            this.#queryCache.onFocus();
          }
        });
        this.#unsubscribeOnline = onlineManager.subscribe(() => {
          if (onlineManager.isOnline()) {
            this.resumePausedMutations();
            this.#queryCache.onOnline();
          }
        });
      }
      unmount() {
        this.#mountCount--;
        if (this.#mountCount !== 0)
          return;
        this.#unsubscribeFocus?.();
        this.#unsubscribeFocus = void 0;
        this.#unsubscribeOnline?.();
        this.#unsubscribeOnline = void 0;
      }
      isFetching(filters) {
        return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
      }
      isMutating(filters) {
        return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
      }
      getQueryData(queryKey) {
        return this.#queryCache.find({ queryKey })?.state.data;
      }
      ensureQueryData(options) {
        const cachedData = this.getQueryData(options.queryKey);
        return cachedData !== void 0 ? Promise.resolve(cachedData) : this.fetchQuery(options);
      }
      getQueriesData(filters) {
        return this.getQueryCache().findAll(filters).map(({ queryKey, state }) => {
          const data = state.data;
          return [queryKey, data];
        });
      }
      setQueryData(queryKey, updater, options) {
        const query = this.#queryCache.find({ queryKey });
        const prevData = query?.state.data;
        const data = functionalUpdate(updater, prevData);
        if (typeof data === "undefined") {
          return void 0;
        }
        const defaultedOptions = this.defaultQueryOptions({ queryKey });
        return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });
      }
      setQueriesData(filters, updater, options) {
        return notifyManager.batch(
          () => this.getQueryCache().findAll(filters).map(({ queryKey }) => [
            queryKey,
            this.setQueryData(queryKey, updater, options)
          ])
        );
      }
      getQueryState(queryKey) {
        return this.#queryCache.find({ queryKey })?.state;
      }
      removeQueries(filters) {
        const queryCache = this.#queryCache;
        notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            queryCache.remove(query);
          });
        });
      }
      resetQueries(filters, options) {
        const queryCache = this.#queryCache;
        const refetchFilters = {
          type: "active",
          ...filters
        };
        return notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(refetchFilters, options);
        });
      }
      cancelQueries(filters = {}, cancelOptions = {}) {
        const defaultedCancelOptions = { revert: true, ...cancelOptions };
        const promises = notifyManager.batch(
          () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
        );
        return Promise.all(promises).then(noop$1).catch(noop$1);
      }
      invalidateQueries(filters = {}, options = {}) {
        return notifyManager.batch(() => {
          this.#queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters.refetchType === "none") {
            return Promise.resolve();
          }
          const refetchFilters = {
            ...filters,
            type: filters.refetchType ?? filters.type ?? "active"
          };
          return this.refetchQueries(refetchFilters, options);
        });
      }
      refetchQueries(filters = {}, options) {
        const fetchOptions = {
          ...options,
          cancelRefetch: options?.cancelRefetch ?? true
        };
        const promises = notifyManager.batch(
          () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
            let promise = query.fetch(void 0, fetchOptions);
            if (!fetchOptions.throwOnError) {
              promise = promise.catch(noop$1);
            }
            return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
          })
        );
        return Promise.all(promises).then(noop$1);
      }
      fetchQuery(options) {
        const defaultedOptions = this.defaultQueryOptions(options);
        if (typeof defaultedOptions.retry === "undefined") {
          defaultedOptions.retry = false;
        }
        const query = this.#queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      }
      prefetchQuery(options) {
        return this.fetchQuery(options).then(noop$1).catch(noop$1);
      }
      fetchInfiniteQuery(options) {
        options.behavior = infiniteQueryBehavior(options.pages);
        return this.fetchQuery(options);
      }
      prefetchInfiniteQuery(options) {
        return this.fetchInfiniteQuery(options).then(noop$1).catch(noop$1);
      }
      resumePausedMutations() {
        return this.#mutationCache.resumePausedMutations();
      }
      getQueryCache() {
        return this.#queryCache;
      }
      getMutationCache() {
        return this.#mutationCache;
      }
      getDefaultOptions() {
        return this.#defaultOptions;
      }
      setDefaultOptions(options) {
        this.#defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        this.#queryDefaults.set(hashKey(queryKey), {
          queryKey,
          defaultOptions: options
        });
      }
      getQueryDefaults(queryKey) {
        const defaults = [...this.#queryDefaults.values()];
        let result = {};
        defaults.forEach((queryDefault) => {
          if (partialMatchKey(queryKey, queryDefault.queryKey)) {
            result = { ...result, ...queryDefault.defaultOptions };
          }
        });
        return result;
      }
      setMutationDefaults(mutationKey, options) {
        this.#mutationDefaults.set(hashKey(mutationKey), {
          mutationKey,
          defaultOptions: options
        });
      }
      getMutationDefaults(mutationKey) {
        const defaults = [...this.#mutationDefaults.values()];
        let result = {};
        defaults.forEach((queryDefault) => {
          if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
            result = { ...result, ...queryDefault.defaultOptions };
          }
        });
        return result;
      }
      defaultQueryOptions(options) {
        if (options?._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.#defaultOptions.queries,
          ...options?.queryKey && this.getQueryDefaults(options.queryKey),
          ...options,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash) {
          defaultedOptions.queryHash = hashQueryKeyByOptions(
            defaultedOptions.queryKey,
            defaultedOptions
          );
        }
        if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (typeof defaultedOptions.throwOnError === "undefined") {
          defaultedOptions.throwOnError = !!defaultedOptions.suspense;
        }
        if (typeof defaultedOptions.networkMode === "undefined" && defaultedOptions.persister) {
          defaultedOptions.networkMode = "offlineFirst";
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options?._defaulted) {
          return options;
        }
        return {
          ...this.#defaultOptions.mutations,
          ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
          ...options,
          _defaulted: true
        };
      }
      clear() {
        this.#queryCache.clear();
        this.#mutationCache.clear();
      }
    };

    // src/queryObserver.ts
    var QueryObserver = class extends Subscribable {
      constructor(client, options) {
        super();
        this.options = options;
        this.#client = client;
        this.#selectError = null;
        this.bindMethods();
        this.setOptions(options);
      }
      #client;
      #currentQuery = void 0;
      #currentQueryInitialState = void 0;
      #currentResult = void 0;
      #currentResultState;
      #currentResultOptions;
      #selectError;
      #selectFn;
      #selectResult;
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      #lastQueryWithDefinedData;
      #staleTimeoutId;
      #refetchIntervalId;
      #currentRefetchInterval;
      #trackedProps = /* @__PURE__ */ new Set();
      bindMethods() {
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.#currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.#currentQuery, this.options)) {
            this.#executeFetch();
          } else {
            this.updateResult();
          }
          this.#updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(
          this.#currentQuery,
          this.options,
          this.options.refetchOnReconnect
        );
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(
          this.#currentQuery,
          this.options,
          this.options.refetchOnWindowFocus
        );
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.#clearStaleTimeout();
        this.#clearRefetchInterval();
        this.#currentQuery.removeObserver(this);
      }
      setOptions(options, notifyOptions) {
        const prevOptions = this.options;
        const prevQuery = this.#currentQuery;
        this.options = this.#client.defaultQueryOptions(options);
        if (!shallowEqualObjects(prevOptions, this.options)) {
          this.#client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.#currentQuery,
            observer: this
          });
        }
        if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        if (!this.options.queryKey) {
          this.options.queryKey = prevOptions.queryKey;
        }
        this.#updateQuery();
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(
          this.#currentQuery,
          prevQuery,
          this.options,
          prevOptions
        )) {
          this.#executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.#updateStaleTimeout();
        }
        const nextRefetchInterval = this.#computeRefetchInterval();
        if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {
          this.#updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options) {
        const query = this.#client.getQueryCache().build(this.#client, options);
        const result = this.createResult(query, options);
        if (shouldAssignObserverCurrentProperties(this, result)) {
          this.#currentResult = result;
          this.#currentResultOptions = this.options;
          this.#currentResultState = this.#currentQuery.state;
        }
        return result;
      }
      getCurrentResult() {
        return this.#currentResult;
      }
      trackResult(result) {
        const trackedResult = {};
        Object.keys(result).forEach((key) => {
          Object.defineProperty(trackedResult, key, {
            configurable: false,
            enumerable: true,
            get: () => {
              this.#trackedProps.add(key);
              return result[key];
            }
          });
        });
        return trackedResult;
      }
      getCurrentQuery() {
        return this.#currentQuery;
      }
      refetch({ ...options } = {}) {
        return this.fetch({
          ...options
        });
      }
      fetchOptimistic(options) {
        const defaultedOptions = this.#client.defaultQueryOptions(options);
        const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
        query.isFetchingOptimistic = true;
        return query.fetch().then(() => this.createResult(query, defaultedOptions));
      }
      fetch(fetchOptions) {
        return this.#executeFetch({
          ...fetchOptions,
          cancelRefetch: fetchOptions.cancelRefetch ?? true
        }).then(() => {
          this.updateResult();
          return this.#currentResult;
        });
      }
      #executeFetch(fetchOptions) {
        this.#updateQuery();
        let promise = this.#currentQuery.fetch(
          this.options,
          fetchOptions
        );
        if (!fetchOptions?.throwOnError) {
          promise = promise.catch(noop$1);
        }
        return promise;
      }
      #updateStaleTimeout() {
        this.#clearStaleTimeout();
        if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
          return;
        }
        const time = timeUntilStale(
          this.#currentResult.dataUpdatedAt,
          this.options.staleTime
        );
        const timeout = time + 1;
        this.#staleTimeoutId = setTimeout(() => {
          if (!this.#currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      #computeRefetchInterval() {
        return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
      }
      #updateRefetchInterval(nextInterval) {
        this.#clearRefetchInterval();
        this.#currentRefetchInterval = nextInterval;
        if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
          return;
        }
        this.#refetchIntervalId = setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
            this.#executeFetch();
          }
        }, this.#currentRefetchInterval);
      }
      #updateTimers() {
        this.#updateStaleTimeout();
        this.#updateRefetchInterval(this.#computeRefetchInterval());
      }
      #clearStaleTimeout() {
        if (this.#staleTimeoutId) {
          clearTimeout(this.#staleTimeoutId);
          this.#staleTimeoutId = void 0;
        }
      }
      #clearRefetchInterval() {
        if (this.#refetchIntervalId) {
          clearInterval(this.#refetchIntervalId);
          this.#refetchIntervalId = void 0;
        }
      }
      createResult(query, options) {
        const prevQuery = this.#currentQuery;
        const prevOptions = this.options;
        const prevResult = this.#currentResult;
        const prevResultState = this.#currentResultState;
        const prevResultOptions = this.#currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
        const { state } = query;
        let { error, errorUpdatedAt, fetchStatus, status } = state;
        let isPlaceholderData = false;
        let data;
        if (options._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
          const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
            if (!state.dataUpdatedAt) {
              status = "pending";
            }
          }
          if (options._optimisticResults === "isRestoring") {
            fetchStatus = "idle";
          }
        }
        if (options.select && typeof state.data !== "undefined") {
          if (prevResult && state.data === prevResultState?.data && options.select === this.#selectFn) {
            data = this.#selectResult;
          } else {
            try {
              this.#selectFn = options.select;
              data = options.select(state.data);
              data = replaceData(prevResult?.data, data, options);
              this.#selectResult = data;
              this.#selectError = null;
            } catch (selectError) {
              this.#selectError = selectError;
            }
          }
        } else {
          data = state.data;
        }
        if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "pending") {
          let placeholderData;
          if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
              this.#lastQueryWithDefinedData?.state.data,
              this.#lastQueryWithDefinedData
            ) : options.placeholderData;
            if (options.select && typeof placeholderData !== "undefined") {
              try {
                placeholderData = options.select(placeholderData);
                this.#selectError = null;
              } catch (selectError) {
                this.#selectError = selectError;
              }
            }
          }
          if (typeof placeholderData !== "undefined") {
            status = "success";
            data = replaceData(
              prevResult?.data,
              placeholderData,
              options
            );
            isPlaceholderData = true;
          }
        }
        if (this.#selectError) {
          error = this.#selectError;
          data = this.#selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        const isFetching = fetchStatus === "fetching";
        const isPending = status === "pending";
        const isError = status === "error";
        const isLoading = isPending && isFetching;
        const result = {
          status,
          fetchStatus,
          isPending,
          isSuccess: status === "success",
          isError,
          isInitialLoading: isLoading,
          isLoading,
          data,
          dataUpdatedAt: state.dataUpdatedAt,
          error,
          errorUpdatedAt,
          failureCount: state.fetchFailureCount,
          failureReason: state.fetchFailureReason,
          errorUpdateCount: state.errorUpdateCount,
          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
          isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isPending,
          isLoadingError: isError && state.dataUpdatedAt === 0,
          isPaused: fetchStatus === "paused",
          isPlaceholderData,
          isRefetchError: isError && state.dataUpdatedAt !== 0,
          isStale: isStale(query, options),
          refetch: this.refetch
        };
        return result;
      }
      updateResult(notifyOptions) {
        const prevResult = this.#currentResult;
        const nextResult = this.createResult(this.#currentQuery, this.options);
        this.#currentResultState = this.#currentQuery.state;
        this.#currentResultOptions = this.options;
        if (this.#currentResultState.data !== void 0) {
          this.#lastQueryWithDefinedData = this.#currentQuery;
        }
        if (shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.#currentResult = nextResult;
        const defaultNotifyOptions = {};
        const shouldNotifyListeners = () => {
          if (!prevResult) {
            return true;
          }
          const { notifyOnChangeProps } = this.options;
          const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
          if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
            return true;
          }
          const includedProps = new Set(
            notifyOnChangePropsValue ?? this.#trackedProps
          );
          if (this.options.throwOnError) {
            includedProps.add("error");
          }
          return Object.keys(this.#currentResult).some((key) => {
            const typedKey = key;
            const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        };
        if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {
          defaultNotifyOptions.listeners = true;
        }
        this.#notify({ ...defaultNotifyOptions, ...notifyOptions });
      }
      #updateQuery() {
        const query = this.#client.getQueryCache().build(this.#client, this.options);
        if (query === this.#currentQuery) {
          return;
        }
        const prevQuery = this.#currentQuery;
        this.#currentQuery = query;
        this.#currentQueryInitialState = query.state;
        if (this.hasListeners()) {
          prevQuery?.removeObserver(this);
          query.addObserver(this);
        }
      }
      onQueryUpdate() {
        this.updateResult();
        if (this.hasListeners()) {
          this.#updateTimers();
        }
      }
      #notify(notifyOptions) {
        notifyManager.batch(() => {
          if (notifyOptions.listeners) {
            this.listeners.forEach((listener) => {
              listener(this.#currentResult);
            });
          }
          this.#client.getQueryCache().notify({
            query: this.#currentQuery,
            type: "observerResultsUpdated"
          });
        });
      }
    };
    function shouldLoadOnMount(query, options) {
      return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
    }
    function shouldFetchOnMount(query, options) {
      return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
    }
    function shouldFetchOn(query, options, field) {
      if (options.enabled !== false) {
        const value = typeof field === "function" ? field(query) : field;
        return value === "always" || value !== false && isStale(query, options);
      }
      return false;
    }
    function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
      return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
    }
    function isStale(query, options) {
      return query.isStaleByTime(options.staleTime);
    }
    function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
      if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
        return true;
      }
      return false;
    }

    // src/infiniteQueryObserver.ts
    var InfiniteQueryObserver = class extends QueryObserver {
      // eslint-disable-next-line @typescript-eslint/no-useless-constructor
      constructor(client, options) {
        super(client, options);
      }
      bindMethods() {
        super.bindMethods();
        this.fetchNextPage = this.fetchNextPage.bind(this);
        this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
      }
      setOptions(options, notifyOptions) {
        super.setOptions(
          {
            ...options,
            behavior: infiniteQueryBehavior()
          },
          notifyOptions
        );
      }
      getOptimisticResult(options) {
        options.behavior = infiniteQueryBehavior();
        return super.getOptimisticResult(options);
      }
      fetchNextPage(options) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: { direction: "forward" }
          }
        });
      }
      fetchPreviousPage(options) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: { direction: "backward" }
          }
        });
      }
      createResult(query, options) {
        const { state } = query;
        const result = super.createResult(query, options);
        const { isFetching, isRefetching } = result;
        const isFetchingNextPage = isFetching && state.fetchMeta?.fetchMore?.direction === "forward";
        const isFetchingPreviousPage = isFetching && state.fetchMeta?.fetchMore?.direction === "backward";
        return {
          ...result,
          fetchNextPage: this.fetchNextPage,
          fetchPreviousPage: this.fetchPreviousPage,
          hasNextPage: hasNextPage(options, state.data),
          hasPreviousPage: hasPreviousPage(options, state.data),
          isFetchingNextPage,
          isFetchingPreviousPage,
          isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
        };
      }
    };

    var QueryClientContext = require$$0__namespace.createContext(
      void 0
    );
    var useQueryClient = (queryClient) => {
      const client = require$$0__namespace.useContext(QueryClientContext);
      if (queryClient) {
        return queryClient;
      }
      if (!client) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return client;
    };
    var QueryClientProvider = ({
      client,
      children
    }) => {
      require$$0__namespace.useEffect(() => {
        client.mount();
        return () => {
          client.unmount();
        };
      }, [client]);
      return /* @__PURE__ */ require$$0__namespace.createElement(QueryClientContext.Provider, { value: client }, children);
    };

    var IsRestoringContext = require$$0__namespace.createContext(false);
    var useIsRestoring = () => require$$0__namespace.useContext(IsRestoringContext);
    IsRestoringContext.Provider;

    function createValue() {
      let isReset = false;
      return {
        clearReset: () => {
          isReset = false;
        },
        reset: () => {
          isReset = true;
        },
        isReset: () => {
          return isReset;
        }
      };
    }
    var QueryErrorResetBoundaryContext = require$$0__namespace.createContext(createValue());
    var useQueryErrorResetBoundary = () => require$$0__namespace.useContext(QueryErrorResetBoundaryContext);

    // src/utils.ts
    function shouldThrowError(throwError, params) {
      if (typeof throwError === "function") {
        return throwError(...params);
      }
      return !!throwError;
    }

    var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
      if (options.suspense || options.throwOnError) {
        if (!errorResetBoundary.isReset()) {
          options.retryOnMount = false;
        }
      }
    };
    var useClearResetErrorBoundary = (errorResetBoundary) => {
      require$$0__namespace.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
    };
    var getHasError = ({
      result,
      errorResetBoundary,
      throwOnError,
      query
    }) => {
      return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
    };

    // src/suspense.ts
    var ensureStaleTime = (defaultedOptions) => {
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
      }
    };
    var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
    var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
      errorResetBoundary.clearReset();
    });

    function useBaseQuery(options, Observer, queryClient) {
      const client = useQueryClient(queryClient);
      const isRestoring = useIsRestoring();
      const errorResetBoundary = useQueryErrorResetBoundary();
      const defaultedOptions = client.defaultQueryOptions(options);
      defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
      ensureStaleTime(defaultedOptions);
      ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
      useClearResetErrorBoundary(errorResetBoundary);
      const [observer] = require$$0__namespace.useState(
        () => new Observer(
          client,
          defaultedOptions
        )
      );
      const result = observer.getOptimisticResult(defaultedOptions);
      require$$0__namespace.useSyncExternalStore(
        require$$0__namespace.useCallback(
          (onStoreChange) => {
            const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
            observer.updateResult();
            return unsubscribe;
          },
          [observer, isRestoring]
        ),
        () => observer.getCurrentResult(),
        () => observer.getCurrentResult()
      );
      require$$0__namespace.useEffect(() => {
        observer.setOptions(defaultedOptions, { listeners: false });
      }, [defaultedOptions, observer]);
      if (shouldSuspend(defaultedOptions, result)) {
        throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
      }
      if (getHasError({
        result,
        errorResetBoundary,
        throwOnError: defaultedOptions.throwOnError,
        query: client.getQueryCache().get(defaultedOptions.queryHash)
      })) {
        throw result.error;
      }
      return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
    }

    function useInfiniteQuery(options, queryClient) {
      return useBaseQuery(
        options,
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        InfiniteQueryObserver,
        queryClient
      );
    }

    var lib = {};

    var TextareaAutosize$1 = {};

    var propTypes = {exports: {}};

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var ReactPropTypesSecret = ReactPropTypesSecret_1;

    function emptyFunction() {}
    function emptyFunctionWithReset() {}
    emptyFunctionWithReset.resetWarningCache = emptyFunction;

    var factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          // It is still safe when called from React.
          return;
        }
        var err = new Error(
          'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
          'Use PropTypes.checkPropTypes() to call them. ' +
          'Read more at http://fb.me/use-check-prop-types'
        );
        err.name = 'Invariant Violation';
        throw err;
      }  shim.isRequired = shim;
      function getShim() {
        return shim;
      }  // Important!
      // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,

        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,

        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };

      ReactPropTypes.PropTypes = ReactPropTypes;

      return ReactPropTypes;
    };

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    {
      // By explicitly using `prop-types` you are opting into new production behavior.
      // http://fb.me/prop-types-in-prod
      propTypes.exports = factoryWithThrowingShims();
    }

    var autosize$1 = {exports: {}};

    /*!
    	autosize 4.0.4
    	license: MIT
    	http://www.jacklmoore.com/autosize
    */

    (function (module, exports) {
    (function (global, factory) {
    	{
    		factory(module, exports);
    	}
    })(commonjsGlobal, function (module, exports) {

    	var map = typeof Map === "function" ? new Map() : function () {
    		var keys = [];
    		var values = [];

    		return {
    			has: function has(key) {
    				return keys.indexOf(key) > -1;
    			},
    			get: function get(key) {
    				return values[keys.indexOf(key)];
    			},
    			set: function set(key, value) {
    				if (keys.indexOf(key) === -1) {
    					keys.push(key);
    					values.push(value);
    				}
    			},
    			delete: function _delete(key) {
    				var index = keys.indexOf(key);
    				if (index > -1) {
    					keys.splice(index, 1);
    					values.splice(index, 1);
    				}
    			}
    		};
    	}();

    	var createEvent = function createEvent(name) {
    		return new Event(name, { bubbles: true });
    	};
    	try {
    		new Event('test');
    	} catch (e) {
    		// IE does not support `new Event()`
    		createEvent = function createEvent(name) {
    			var evt = document.createEvent('Event');
    			evt.initEvent(name, true, false);
    			return evt;
    		};
    	}

    	function assign(ta) {
    		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

    		var heightOffset = null;
    		var clientWidth = null;
    		var cachedHeight = null;

    		function init() {
    			var style = window.getComputedStyle(ta, null);

    			if (style.resize === 'vertical') {
    				ta.style.resize = 'none';
    			} else if (style.resize === 'both') {
    				ta.style.resize = 'horizontal';
    			}

    			if (style.boxSizing === 'content-box') {
    				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
    			} else {
    				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    			}
    			// Fix when a textarea is not on document body and heightOffset is Not a Number
    			if (isNaN(heightOffset)) {
    				heightOffset = 0;
    			}

    			update();
    		}

    		function changeOverflow(value) {
    			{
    				// Chrome/Safari-specific fix:
    				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
    				// made available by removing the scrollbar. The following forces the necessary text reflow.
    				var width = ta.style.width;
    				ta.style.width = '0px';
    				// Force reflow:
    				/* jshint ignore:start */
    				ta.offsetWidth;
    				/* jshint ignore:end */
    				ta.style.width = width;
    			}

    			ta.style.overflowY = value;
    		}

    		function getParentOverflows(el) {
    			var arr = [];

    			while (el && el.parentNode && el.parentNode instanceof Element) {
    				if (el.parentNode.scrollTop) {
    					arr.push({
    						node: el.parentNode,
    						scrollTop: el.parentNode.scrollTop
    					});
    				}
    				el = el.parentNode;
    			}

    			return arr;
    		}

    		function resize() {
    			if (ta.scrollHeight === 0) {
    				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
    				return;
    			}

    			var overflows = getParentOverflows(ta);
    			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

    			ta.style.height = '';
    			ta.style.height = ta.scrollHeight + heightOffset + 'px';

    			// used to check if an update is actually necessary on window.resize
    			clientWidth = ta.clientWidth;

    			// prevents scroll-position jumping
    			overflows.forEach(function (el) {
    				el.node.scrollTop = el.scrollTop;
    			});

    			if (docTop) {
    				document.documentElement.scrollTop = docTop;
    			}
    		}

    		function update() {
    			resize();

    			var styleHeight = Math.round(parseFloat(ta.style.height));
    			var computed = window.getComputedStyle(ta, null);

    			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
    			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

    			// The actual height not matching the style height (set via the resize method) indicates that 
    			// the max-height has been exceeded, in which case the overflow should be allowed.
    			if (actualHeight < styleHeight) {
    				if (computed.overflowY === 'hidden') {
    					changeOverflow('scroll');
    					resize();
    					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
    				}
    			} else {
    				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
    				if (computed.overflowY !== 'hidden') {
    					changeOverflow('hidden');
    					resize();
    					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
    				}
    			}

    			if (cachedHeight !== actualHeight) {
    				cachedHeight = actualHeight;
    				var evt = createEvent('autosize:resized');
    				try {
    					ta.dispatchEvent(evt);
    				} catch (err) {
    					// Firefox will throw an error on dispatchEvent for a detached element
    					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
    				}
    			}
    		}

    		var pageResize = function pageResize() {
    			if (ta.clientWidth !== clientWidth) {
    				update();
    			}
    		};

    		var destroy = function (style) {
    			window.removeEventListener('resize', pageResize, false);
    			ta.removeEventListener('input', update, false);
    			ta.removeEventListener('keyup', update, false);
    			ta.removeEventListener('autosize:destroy', destroy, false);
    			ta.removeEventListener('autosize:update', update, false);

    			Object.keys(style).forEach(function (key) {
    				ta.style[key] = style[key];
    			});

    			map.delete(ta);
    		}.bind(ta, {
    			height: ta.style.height,
    			resize: ta.style.resize,
    			overflowY: ta.style.overflowY,
    			overflowX: ta.style.overflowX,
    			wordWrap: ta.style.wordWrap
    		});

    		ta.addEventListener('autosize:destroy', destroy, false);

    		// IE9 does not fire onpropertychange or oninput for deletions,
    		// so binding to onkeyup to catch most of those events.
    		// There is no way that I know of to detect something like 'cut' in IE9.
    		if ('onpropertychange' in ta && 'oninput' in ta) {
    			ta.addEventListener('keyup', update, false);
    		}

    		window.addEventListener('resize', pageResize, false);
    		ta.addEventListener('input', update, false);
    		ta.addEventListener('autosize:update', update, false);
    		ta.style.overflowX = 'hidden';
    		ta.style.wordWrap = 'break-word';

    		map.set(ta, {
    			destroy: destroy,
    			update: update
    		});

    		init();
    	}

    	function destroy(ta) {
    		var methods = map.get(ta);
    		if (methods) {
    			methods.destroy();
    		}
    	}

    	function update(ta) {
    		var methods = map.get(ta);
    		if (methods) {
    			methods.update();
    		}
    	}

    	var autosize = null;

    	// Do nothing in Node.js environment and IE8 (or lower)
    	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
    		autosize = function autosize(el) {
    			return el;
    		};
    		autosize.destroy = function (el) {
    			return el;
    		};
    		autosize.update = function (el) {
    			return el;
    		};
    	} else {
    		autosize = function autosize(el, options) {
    			if (el) {
    				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
    					return assign(x);
    				});
    			}
    			return el;
    		};
    		autosize.destroy = function (el) {
    			if (el) {
    				Array.prototype.forEach.call(el.length ? el : [el], destroy);
    			}
    			return el;
    		};
    		autosize.update = function (el) {
    			if (el) {
    				Array.prototype.forEach.call(el.length ? el : [el], update);
    			}
    			return el;
    		};
    	}

    	exports.default = autosize;
    	module.exports = exports['default'];
    });
    }(autosize$1, autosize$1.exports));

    // This code has been refactored for 140 bytes
    // You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
    var computedStyle$1 = function (el, prop, getComputedStyle) {
      getComputedStyle = window.getComputedStyle;

      // In one fell swoop
      return (
        // If we have getComputedStyle
        getComputedStyle ?
          // Query it
          // TODO: From CSS-Query notes, we might need (node, null) for FF
          getComputedStyle(el) :

        // Otherwise, we are in IE and use currentStyle
          el.currentStyle
      )[
        // Switch to camelCase for CSSOM
        // DEV: Grabbed from jQuery
        // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
        // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
        prop.replace(/-(\w)/gi, function (word, letter) {
          return letter.toUpperCase();
        })
      ];
    };

    var computedStyle_commonjs = computedStyle$1;

    // Load in dependencies
    var computedStyle = computedStyle_commonjs;

    /**
     * Calculate the `line-height` of a given node
     * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
     * @returns {Number} `line-height` of the element in pixels
     */
    function lineHeight(node) {
      // Grab the line-height via style
      var lnHeightStr = computedStyle(node, 'line-height');
      var lnHeight = parseFloat(lnHeightStr, 10);

      // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')
      if (lnHeightStr === lnHeight + '') {
        // Save the old lineHeight style and update the em unit to the element
        var _lnHeightStyle = node.style.lineHeight;
        node.style.lineHeight = lnHeightStr + 'em';

        // Calculate the em based height
        lnHeightStr = computedStyle(node, 'line-height');
        lnHeight = parseFloat(lnHeightStr, 10);

        // Revert the lineHeight style
        if (_lnHeightStyle) {
          node.style.lineHeight = _lnHeightStyle;
        } else {
          delete node.style.lineHeight;
        }
      }

      // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
      // DEV: `em` units are converted to `pt` in IE6
      // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length
      if (lnHeightStr.indexOf('pt') !== -1) {
        lnHeight *= 4;
        lnHeight /= 3;
      // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
      } else if (lnHeightStr.indexOf('mm') !== -1) {
        lnHeight *= 96;
        lnHeight /= 25.4;
      // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
      } else if (lnHeightStr.indexOf('cm') !== -1) {
        lnHeight *= 96;
        lnHeight /= 2.54;
      // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
      } else if (lnHeightStr.indexOf('in') !== -1) {
        lnHeight *= 96;
      // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
      } else if (lnHeightStr.indexOf('pc') !== -1) {
        lnHeight *= 16;
      }

      // Continue our computation
      lnHeight = Math.round(lnHeight);

      // If the line-height is "normal", calculate by font-size
      if (lnHeightStr === 'normal') {
        // Create a temporary node
        var nodeName = node.nodeName;
        var _node = document.createElement(nodeName);
        _node.innerHTML = '&nbsp;';

        // If we have a text area, reset it to only 1 row
        // https://github.com/twolfson/line-height/issues/4
        if (nodeName.toUpperCase() === 'TEXTAREA') {
          _node.setAttribute('rows', '1');
        }

        // Set the font-size of the element
        var fontSizeStr = computedStyle(node, 'font-size');
        _node.style.fontSize = fontSizeStr;

        // Remove default padding/border which can affect offset height
        // https://github.com/twolfson/line-height/issues/4
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
        _node.style.padding = '0px';
        _node.style.border = '0px';

        // Append it to the body
        var body = document.body;
        body.appendChild(_node);

        // Assume the line height of the element is the height
        var height = _node.offsetHeight;
        lnHeight = height;

        // Remove our child from the DOM
        body.removeChild(_node);
      }

      // Return the calculated height
      return lnHeight;
    }

    // Export lineHeight
    var lineHeight_1 = lineHeight;

    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    TextareaAutosize$1.__esModule = true;
    var React$1 = require$$0__default["default"];
    var PropTypes = propTypes.exports;
    var autosize = autosize$1.exports;
    var _getLineHeight = lineHeight_1;
    var getLineHeight = _getLineHeight;
    var RESIZED = "autosize:resized";
    /**
     * A light replacement for built-in textarea component
     * which automaticaly adjusts its height to match the content
     */
    var TextareaAutosizeClass = /** @class */ (function (_super) {
        __extends(TextareaAutosizeClass, _super);
        function TextareaAutosizeClass() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                lineHeight: null
            };
            _this.textarea = null;
            _this.onResize = function (e) {
                if (_this.props.onResize) {
                    _this.props.onResize(e);
                }
            };
            _this.updateLineHeight = function () {
                if (_this.textarea) {
                    _this.setState({
                        lineHeight: getLineHeight(_this.textarea)
                    });
                }
            };
            _this.onChange = function (e) {
                var onChange = _this.props.onChange;
                _this.currentValue = e.currentTarget.value;
                onChange && onChange(e);
            };
            return _this;
        }
        TextareaAutosizeClass.prototype.componentDidMount = function () {
            var _this = this;
            var _a = this.props, maxRows = _a.maxRows, async = _a.async;
            if (typeof maxRows === "number") {
                this.updateLineHeight();
            }
            if (typeof maxRows === "number" || async) {
                /*
                  the defer is needed to:
                    - force "autosize" to activate the scrollbar when this.props.maxRows is passed
                    - support StyledComponents (see #71)
                */
                setTimeout(function () { return _this.textarea && autosize(_this.textarea); });
            }
            else {
                this.textarea && autosize(this.textarea);
            }
            if (this.textarea) {
                this.textarea.addEventListener(RESIZED, this.onResize);
            }
        };
        TextareaAutosizeClass.prototype.componentWillUnmount = function () {
            if (this.textarea) {
                this.textarea.removeEventListener(RESIZED, this.onResize);
                autosize.destroy(this.textarea);
            }
        };
        TextareaAutosizeClass.prototype.render = function () {
            var _this = this;
            var _a = this, _b = _a.props; _b.onResize; var maxRows = _b.maxRows; _b.onChange; var style = _b.style; _b.innerRef; var children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
            var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
            return (React$1.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {
                    _this.textarea = element;
                    if (typeof _this.props.innerRef === 'function') {
                        _this.props.innerRef(element);
                    }
                    else if (_this.props.innerRef) {
                        _this.props.innerRef.current = element;
                    }
                } }), children));
        };
        TextareaAutosizeClass.prototype.componentDidUpdate = function () {
            this.textarea && autosize.update(this.textarea);
        };
        TextareaAutosizeClass.defaultProps = {
            rows: 1,
            async: false
        };
        TextareaAutosizeClass.propTypes = {
            rows: PropTypes.number,
            maxRows: PropTypes.number,
            onResize: PropTypes.func,
            innerRef: PropTypes.any,
            async: PropTypes.bool
        };
        return TextareaAutosizeClass;
    }(React$1.Component));
    TextareaAutosize$1.TextareaAutosize = React$1.forwardRef(function (props, ref) {
        return React$1.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
    });

    (function (exports) {
    exports.__esModule = true;
    var TextareaAutosize_1 = TextareaAutosize$1;
    exports["default"] = TextareaAutosize_1.TextareaAutosize;
    }(lib));

    var TextareaAutosize = /*@__PURE__*/getDefaultExportFromCjs(lib);

    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;

        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var lodash_debounce = debounce;

    var useAudioRecorder = function () {
        var _a = require$$0$1.useState(false), isRecording = _a[0], setIsRecording = _a[1];
        var _b = require$$0$1.useState(0), recordingTime = _b[0], setRecordingTime = _b[1];
        var _c = require$$0$1.useState(), timerInterval = _c[0]; _c[1];
        var _d = require$$0$1.useState(), recordingFile = _d[0], setRecordingFile = _d[1];
        var _e = require$$0$1.useState(
        //new MicRecorder({bitRate: 128})
        ); _e[0]; _e[1];
        var startRecording = require$$0$1.useCallback(function () {
            if (timerInterval != null)
                return;
            // Mp3Recorder.start()
            //   .then(() => {
            //     setIsRecording(true)
            //     _startTimer()
            //   })
            //   .catch(e => {
            //     setIsRecording(false)
            //     setRecordingFile(null)
            //
            //     console.error(e)
            //   })
        }, [timerInterval]);
        var stopRecording = function () {
            // Mp3Recorder.stop()
            //   .getMp3()
            //   .then(([buffer, blob]) => {
            //     _stopTimer()
            //     const file = new File(buffer, 'record.mp3', {
            //       type: blob.type,
            //       lastModified: Date.now(),
            //     })
            //     setRecordingFile(file)
            //   })
            //   .catch(e => {
            //     _stopTimer()
            //     setRecordingFile(null)
            //     console.log(e)
            //   })
            setRecordingTime(0);
            setRecordingFile(null);
            setIsRecording(false);
        };
        return {
            startRecording: startRecording,
            stopRecording: stopRecording,
            recordingFile: recordingFile,
            isRecording: isRecording,
            recordingTime: recordingTime,
        };
    };

    var VoiceRecorder = function (_a) {
        var onRecordingComplete = _a.onRecordingComplete, setRecordingState = _a.setRecordingState;
        var _b = require$$0$1.useState(false), confirmRecording = _b[0], setConfirmRecording = _b[1];
        var _c = useAudioRecorder(), startRecording = _c.startRecording, stopRecording = _c.stopRecording, recordingFile = _c.recordingFile, isRecording = _c.isRecording, recordingTime = _c.recordingTime;
        require$$0$1.useEffect(function () {
            if (confirmRecording &&
                recordingFile != null &&
                onRecordingComplete != null) {
                onRecordingComplete(recordingFile);
                setConfirmRecording(false);
                setRecordingState(false);
            }
        }, [recordingFile, confirmRecording]);
        require$$0$1.useEffect(function () {
            if (isRecording) {
                setRecordingState(true);
            }
            else {
                setRecordingState(false);
            }
        }, [isRecording]);
        return isRecording ? (React.createElement("div", { className: "flex items-center" },
            React.createElement("button", { className: "p-2 cursor-pointer text-gray-500", onClick: function () {
                    stopRecording();
                } },
                React.createElement(XCircleIcon, { className: "text-red-600 h-[18px] w-[18px]" })),
            React.createElement("div", { className: "flex items-center " },
                React.createElement("div", { className: "h-2 w-2 rounded-full bg-red-600 mr-1" }),
                React.createElement("span", { className: "min-w-[43px] text-right" }, formatToMMSS(recordingTime))),
            React.createElement("button", { className: "p-2 cursor-pointer text-gray-500 mr-1.5" },
                React.createElement(CheckCircleIcon, { className: "text-green-600 h-[18px] w-[18px]", onClick: function () {
                        setConfirmRecording(true);
                        stopRecording();
                    } })))) : (React.createElement("button", { className: "p-2 cursor-pointer text-gray-500 mr-1.5", onClick: function () {
                startRecording();
                setConfirmRecording(false);
            } },
            React.createElement(MicrophoneIcon, { className: "h-[18px] w-[18px]" })));
    };

    var css_248z$2 = "";
    styleInject(css_248z$2,{"insertAt":"top"});

    var useFileUpload = function () {
        var rc = useRc().rc;
        var dispatch = useAppDispatch();
        var onUploadProgress = function (id, e) {
            dispatch(updateUploader({
                id: id,
                changes: {
                    progress: e.progress
                }
            }));
        };
        var onUploadError = function (_a) {
            // //File transfer was cancelled by user
            // if(!e){
            //     dispatch(removeUploader(id))
            //     return;
            // }
            var _b;
            var e = _a.e, id = _a.id;
            var canReUpload = true;
            if ((_b = e === null || e === void 0 ? void 0 : e.data) === null || _b === void 0 ? void 0 : _b.errorType) {
                switch (e.data.errorType) {
                    case 'error-invalid-file-type':
                        break;
                    default:
                        canReUpload = false;
                        break;
                }
            }
            dispatch(updateUploader({
                id: id,
                changes: {
                    canReUpload: canReUpload,
                    error: true,
                }
            }));
        };
        var onUploadSuccess = function (_a) {
            var id = _a.id; _a.res;
            dispatch(removeUploader(id));
            rc.abortUpload(id);
        };
        return function (rid, file, id) {
            var uploader = generateUploader(rid, file, id);
            dispatch(upsertUploader(uploader));
            rc.uploadFile(uploader.id, rid, file, onUploadProgress).then(onUploadSuccess).catch(onUploadError);
        };
    };

    var UploaderItem = function (_a) {
        var item = _a.item;
        var rc = useRc().rc;
        var t = useTranslation().t;
        var dispatch = useAppDispatch();
        var uploadFile = useFileUpload();
        var _b = useTheme(), theme = _b.theme, themes = _b.themes;
        var progress = require$$0$1.useMemo(function () {
            return Math.round(item.progress * 100);
        }, [item.progress]);
        var abortUpload = require$$0$1.useCallback(function () {
            rc.abortUpload(item.id);
            dispatch(removeUploader(item.id));
        }, []);
        var reUpload = require$$0$1.useCallback(function () {
            var file = rc.getUploadingFile(item.id);
            if (!file) {
                dispatch(removeUploader(item.id));
                return;
            }
            uploadFile(item.rid, file, item.id);
        }, []);
        return (require$$0__default["default"].createElement("div", { className: "pb-2 pt-2 flex items-center" },
            require$$0__default["default"].createElement(DocumentIcon, { className: classNames('h-4 w-4 m-2 ml-1 mr-2.5', theme === themes.TEAL ? 'text-theme-teal-1' : 'text-indigo-500') }),
            require$$0__default["default"].createElement("span", { className: "text-sm leading-5 font-medium text-gray-900 mr-5" }, item.name),
            require$$0__default["default"].createElement("div", { className: classNames('items-center text-sm leading-5 font-medium flex-1 flex justify-end', theme === themes.TEAL ? 'text-theme-teal-1' : 'text-sky-400') }, !item.error ? (require$$0__default["default"].createElement(require$$0__default["default"].Fragment, null,
                progress,
                "%",
                require$$0__default["default"].createElement("button", { onClick: abortUpload, className: 'ml-3' },
                    require$$0__default["default"].createElement(XMarkIcon, { className: "h-4 w-4 mx-1 my-2 text-red-500" })))) : (require$$0__default["default"].createElement(require$$0__default["default"].Fragment, null,
                require$$0__default["default"].createElement("span", { className: 'text-red-500' }, t('UPLOAD_FAILED')),
                item.canReUpload ? (require$$0__default["default"].createElement("button", { onClick: reUpload, className: 'ml-3 text-red-500' },
                    require$$0__default["default"].createElement(ArrowPathIcon, { className: "h-4 w-4 mx-1 my-2" }))) : null)))));
    };

    var useGetRoomId = function () {
        var rc = useRc().rc;
        var rid = useAppSelector(function (state) { return state.room; }).rid;
        var dispatch = useAppDispatch();
        var getRoomId = function () { return __awaiter$5(void 0, void 0, void 0, function () {
            var room;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!rid) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, rc.createImRoom()];
                    case 2:
                        room = _a.sent();
                        dispatch(setRoom(room));
                        return [2 /*return*/, room._id];
                    case 3:
                        _a.sent();
                        throw new Error('Cannot create im');
                    case 4: return [2 /*return*/, rid];
                }
            });
        }); };
        return getRoomId;
    };

    var Composer = function (_a) {
        var isTyping = _a.isTyping;
        var rid = useAppSelector(function (state) { return state.room; }).rid;
        var uploaders = useAppSelector(uploaderSelectors.selectAll);
        var rc = useRc().rc;
        var t = useTranslation().t;
        var queryClient = useQueryClient();
        var _b = require$$0$1.useState(''), message = _b[0], setMessage = _b[1];
        var getRoomId = useGetRoomId();
        var uploadFile = useFileUpload();
        var _c = require$$0$1.useState(false), isRecording = _c[0], setIsRecording = _c[1];
        var _d = useTheme(), theme = _d.theme, themes = _d.themes;
        var clear = require$$0$1.useCallback(function () {
            setMessage('');
        }, []);
        var send = require$$0$1.useCallback(function (e) { return __awaiter$5(void 0, void 0, void 0, function () {
            var currentRoomId, _rid;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (e)
                            e.preventDefault();
                        if (!message)
                            return [2 /*return*/];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        currentRoomId = rid;
                        return [4 /*yield*/, getRoomId()];
                    case 2:
                        _rid = _a.sent();
                        return [4 /*yield*/, rc.sendMessage(_rid, message)];
                    case 3:
                        _a.sent();
                        if (_rid !== currentRoomId) {
                            queryClient.resetQueries(['messages']);
                        }
                        disableIsTyping();
                        clear();
                        return [3 /*break*/, 5];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        }); }, [message, rid]);
        var debouncedCancelIsTyping = require$$0__default["default"].useRef(lodash_debounce(function () {
            disableIsTyping();
        }, 1000)).current;
        var onChange = function (e) {
            setMessage(e.target.value);
            enableIsTyping();
            debouncedCancelIsTyping();
        };
        var onKeyDown = function (e) {
            if (e.keyCode === 13 && !e.shiftKey) {
                e.preventDefault();
                send();
            }
        };
        var enableIsTyping = require$$0$1.useCallback(function () {
            if (!rid)
                return;
            rc.sendIsTyping(rid, true);
        }, [rid]);
        var disableIsTyping = require$$0$1.useCallback(function () {
            if (!rid)
                return;
            rc.sendIsTyping(rid, false);
        }, [rid]);
        var handleFileChange = require$$0$1.useCallback(function (_a) {
            var target = _a.target;
            return __awaiter$5(void 0, void 0, void 0, function () {
                var _rid_1;
                return __generator$5(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, getRoomId()];
                        case 1:
                            _rid_1 = _b.sent();
                            if (target.files) {
                                Array.from(target.files).forEach(function (file) {
                                    uploadFile(_rid_1, file);
                                });
                            }
                            target.value = '';
                            return [3 /*break*/, 3];
                        case 2:
                            _b.sent();
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        }, [rid]);
        var sendRecordedAudio = function (file) { return __awaiter$5(void 0, void 0, void 0, function () {
            var _rid;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, getRoomId()];
                    case 1:
                        _rid = _a.sent();
                        uploadFile(_rid, file);
                        return [3 /*break*/, 3];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); };
        return (require$$0__default["default"].createElement("div", { className: 'bg-white pb-4 pl-4 pr-4 relative' },
            require$$0__default["default"].createElement("div", null, uploaders.map(function (uploader) { return (require$$0__default["default"].createElement(UploaderItem, { key: uploader.id, item: uploader })); })),
            require$$0__default["default"].createElement("div", { className: 'flex pt-4' },
                require$$0__default["default"].createElement("div", { className: "flex flex-1 rounded-md outline outline-1 outline-gray-300" },
                    require$$0__default["default"].createElement(TextareaAutosize, { placeholder: t('MESSAGE') + '...', className: 'ja-chat-composer flex-1 p-2.5 !pl-3 text-sm leading-5 outline-none font-normal placeholder:text-gray-500', rows: 1, maxRows: 5, value: message, onKeyDown: onKeyDown, onChange: onChange }),
                    !isRecording ? (require$$0__default["default"].createElement("label", { htmlFor: "select-file", className: "p-2 px-1 cursor-pointer text-gray-500 relative flex items-center" },
                        require$$0__default["default"].createElement("input", { id: "select-file", className: 'hidden', onChange: handleFileChange, multiple: true, type: 'file' }),
                        require$$0__default["default"].createElement(PaperClipIcon, { className: "h-4 w-4 -rotate-45" }))) : null,
                    require$$0__default["default"].createElement(VoiceRecorder, { setRecordingState: function (state) {
                            setIsRecording(state);
                        }, onRecordingComplete: sendRecordedAudio })),
                require$$0__default["default"].createElement("button", { className: classNames('ml-1 p-2.5 cursor-pointer', message
                        ? theme === themes.TEAL
                            ? 'text-theme-teal-1'
                            : 'text-sky-500'
                        : 'text-gray-300'), disabled: !message, type: 'button', onClick: send },
                    require$$0__default["default"].createElement(PaperAirplaneIcon, { className: "h-[18px] w-[18px]" }))),
            isTyping.display ? (require$$0__default["default"].createElement("span", { className: 'text-[10px] absolute bottom-0 left-4' },
                isTyping.username,
                " ",
                t('IS_TYPING'),
                " ...")) : null));
    };

    var hasFocus = function () { return typeof document !== 'undefined' && document.hasFocus(); };
    var useWindowFocus = function () {
        var _a = require$$0$1.useState(hasFocus), focused = _a[0], setFocused = _a[1];
        require$$0$1.useEffect(function () {
            setFocused(hasFocus());
            var onFocus = function () { return setFocused(true); };
            var onBlur = function () { return setFocused(false); };
            window.addEventListener('focus', onFocus);
            window.addEventListener('blur', onBlur);
            return function () {
                window.removeEventListener('focus', onFocus);
                window.removeEventListener('blur', onBlur);
            };
        }, []);
        return focused;
    };

    var css_248z$1 = "";
    styleInject(css_248z$1,{"insertAt":"top"});

    var DropZone = function (_a) {
        var children = _a.children;
        var t = useTranslation().t;
        var getRoomId = useGetRoomId();
        var uploadFile = useFileUpload();
        var _b = useTheme(), theme = _b.theme, themes = _b.themes;
        var drag = require$$0__default["default"].useRef(null);
        var _c = require$$0$1.useState(false), dragging = _c[0], setDragging = _c[1];
        var handleDragOver = function (e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        };
        var handleDrop = function (e) { return __awaiter$5(void 0, void 0, void 0, function () {
            var files, rid;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        e.preventDefault();
                        e.stopPropagation();
                        files = Array.from(e.dataTransfer.files);
                        return [4 /*yield*/, getRoomId()];
                    case 1:
                        rid = _a.sent();
                        files.forEach(function (file) {
                            uploadFile(rid, file);
                        });
                        setDragging(false);
                        return [2 /*return*/];
                }
            });
        }); };
        var handleDragEnter = function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (e.target !== drag.current) {
                setDragging(true);
            }
        };
        var handleDragLeave = function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (e.target === drag.current) {
                setDragging(false);
            }
        };
        return (require$$0__default["default"].createElement("div", { onDragOver: handleDragOver, onDrop: handleDrop, onDragEnter: handleDragEnter, onDragLeave: handleDragLeave, className: 'ja-chat flex flex-col h-full overflow-hidden relative' },
            children,
            dragging ? (require$$0__default["default"].createElement("div", { ref: drag, "data-message": t('DROP_TO_UPLOAD_FILE'), className: classNames('absolute w-full h-full  bg-opacity-70 flex items-center justify-center text-white before:content-[attr(data-message)]', theme === themes.TEAL ? 'bg-theme-teal-1' : 'bg-sky-400') })) : null));
    };

    var NotificationButton = function () {
        var _a = require$$0$1.useState(localStorage.getItem('disablePushNotification') === '1' ? true : false), disablePushNotification = _a[0], setDisablePushNotification = _a[1];
        var t = useTranslation().t;
        var handleRequestPermission = function () {
            if (('Notification' in window && Notification.permission !== 'granted') ||
                !disablePushNotification) {
                Notification.requestPermission().then(function (permission) {
                    if (permission === 'granted') {
                        new Notification(t('THANKS_YOU_FOR_ENABLING_NOTIFICATION'));
                    }
                });
            }
        };
        var _b = useTheme(), theme = _b.theme, themes = _b.themes;
        var color = require$$0$1.useMemo(function () {
            return theme === themes.TEAL ? 'bg-theme-teal-1' : 'bg-sky-200';
        }, [theme]);
        var disableNotification = function () {
            setDisablePushNotification(true);
            localStorage.setItem('disablePushNotification', '1');
        };
        if ((Notification === null || Notification === void 0 ? void 0 : Notification.permission) === 'default' && !disablePushNotification) {
            return (React.createElement("div", { className: classNames('flex w-full justify-center items-center p-2', color) },
                React.createElement("button", { onClick: handleRequestPermission }, t('ENABLE_PUSH_NOTIFICATIONS')),
                React.createElement("div", { className: "flex justify-center hover:cursor-pointer ml-2 items-center h-4 w-4", onClick: disableNotification },
                    React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", className: "w-6 h-6" },
                        React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" })))));
        }
        else {
            return null;
        }
    };

    var useNotification = function (title, options) {
        if (options === void 0) { options = {}; }
        if (Notification.permission === 'granted') {
            return new Notification(title, __assign$6({}, options));
        }
    };

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }

    function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    var consoleLogger = {
      type: 'logger',
      log: function log(args) {
        this.output('log', args);
      },
      warn: function warn(args) {
        this.output('warn', args);
      },
      error: function error(args) {
        this.output('error', args);
      },
      output: function output(type, args) {
        if (console && console[type]) console[type].apply(console, args);
      }
    };
    var Logger = function () {
      function Logger(concreteLogger) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        _classCallCheck(this, Logger);
        this.init(concreteLogger, options);
      }
      _createClass(Logger, [{
        key: "init",
        value: function init(concreteLogger) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          this.prefix = options.prefix || 'i18next:';
          this.logger = concreteLogger || consoleLogger;
          this.options = options;
          this.debug = options.debug;
        }
      }, {
        key: "setDebug",
        value: function setDebug(bool) {
          this.debug = bool;
        }
      }, {
        key: "log",
        value: function log() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return this.forward(args, 'log', '', true);
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return this.forward(args, 'warn', '', true);
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return this.forward(args, 'error', '');
        }
      }, {
        key: "deprecate",
        value: function deprecate() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
        }
      }, {
        key: "forward",
        value: function forward(args, lvl, prefix, debugOnly) {
          if (debugOnly && !this.debug) return null;
          if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
          return this.logger[lvl](args);
        }
      }, {
        key: "create",
        value: function create(moduleName) {
          return new Logger(this.logger, _objectSpread$6(_objectSpread$6({}, {
            prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
          }), this.options));
        }
      }, {
        key: "clone",
        value: function clone(options) {
          options = options || this.options;
          options.prefix = options.prefix || this.prefix;
          return new Logger(this.logger, options);
        }
      }]);
      return Logger;
    }();
    var baseLogger = new Logger();

    var EventEmitter = function () {
      function EventEmitter() {
        _classCallCheck(this, EventEmitter);
        this.observers = {};
      }
      _createClass(EventEmitter, [{
        key: "on",
        value: function on(events, listener) {
          var _this = this;
          events.split(' ').forEach(function (event) {
            _this.observers[event] = _this.observers[event] || [];
            _this.observers[event].push(listener);
          });
          return this;
        }
      }, {
        key: "off",
        value: function off(event, listener) {
          if (!this.observers[event]) return;
          if (!listener) {
            delete this.observers[event];
            return;
          }
          this.observers[event] = this.observers[event].filter(function (l) {
            return l !== listener;
          });
        }
      }, {
        key: "emit",
        value: function emit(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (this.observers[event]) {
            var cloned = [].concat(this.observers[event]);
            cloned.forEach(function (observer) {
              observer.apply(void 0, args);
            });
          }
          if (this.observers['*']) {
            var _cloned = [].concat(this.observers['*']);
            _cloned.forEach(function (observer) {
              observer.apply(observer, [event].concat(args));
            });
          }
        }
      }]);
      return EventEmitter;
    }();

    function defer() {
      var res;
      var rej;
      var promise = new Promise(function (resolve, reject) {
        res = resolve;
        rej = reject;
      });
      promise.resolve = res;
      promise.reject = rej;
      return promise;
    }
    function makeString(object) {
      if (object == null) return '';
      return '' + object;
    }
    function copy(a, s, t) {
      a.forEach(function (m) {
        if (s[m]) t[m] = s[m];
      });
    }
    function getLastOfPath(object, path, Empty) {
      function cleanKey(key) {
        return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
      }
      function canNotTraverseDeeper() {
        return !object || typeof object === 'string';
      }
      var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
      while (stack.length > 1) {
        if (canNotTraverseDeeper()) return {};
        var key = cleanKey(stack.shift());
        if (!object[key] && Empty) object[key] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          object = object[key];
        } else {
          object = {};
        }
      }
      if (canNotTraverseDeeper()) return {};
      return {
        obj: object,
        k: cleanKey(stack.shift())
      };
    }
    function setPath(object, path, newValue) {
      var _getLastOfPath = getLastOfPath(object, path, Object),
        obj = _getLastOfPath.obj,
        k = _getLastOfPath.k;
      obj[k] = newValue;
    }
    function pushPath(object, path, newValue, concat) {
      var _getLastOfPath2 = getLastOfPath(object, path, Object),
        obj = _getLastOfPath2.obj,
        k = _getLastOfPath2.k;
      obj[k] = obj[k] || [];
      if (concat) obj[k] = obj[k].concat(newValue);
      if (!concat) obj[k].push(newValue);
    }
    function getPath(object, path) {
      var _getLastOfPath3 = getLastOfPath(object, path),
        obj = _getLastOfPath3.obj,
        k = _getLastOfPath3.k;
      if (!obj) return undefined;
      return obj[k];
    }
    function getPathWithDefaults(data, defaultData, key) {
      var value = getPath(data, key);
      if (value !== undefined) {
        return value;
      }
      return getPath(defaultData, key);
    }
    function deepExtend(target, source, overwrite) {
      for (var prop in source) {
        if (prop !== '__proto__' && prop !== 'constructor') {
          if (prop in target) {
            if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
              if (overwrite) target[prop] = source[prop];
            } else {
              deepExtend(target[prop], source[prop], overwrite);
            }
          } else {
            target[prop] = source[prop];
          }
        }
      }
      return target;
    }
    function regexEscape(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }
    var _entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '/': '&#x2F;'
    };
    function escape$1(data) {
      if (typeof data === 'string') {
        return data.replace(/[&<>"'\/]/g, function (s) {
          return _entityMap[s];
        });
      }
      return data;
    }
    var isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
    var chars = [' ', ',', '?', '!', ';'];
    function looksLikeObjectPath(key, nsSeparator, keySeparator) {
      nsSeparator = nsSeparator || '';
      keySeparator = keySeparator || '';
      var possibleChars = chars.filter(function (c) {
        return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
      });
      if (possibleChars.length === 0) return true;
      var r = new RegExp("(".concat(possibleChars.map(function (c) {
        return c === '?' ? '\\?' : c;
      }).join('|'), ")"));
      var matched = !r.test(key);
      if (!matched) {
        var ki = key.indexOf(keySeparator);
        if (ki > 0 && !r.test(key.substring(0, ki))) {
          matched = true;
        }
      }
      return matched;
    }

    function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
    function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    function deepFind(obj, path) {
      var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
      if (!obj) return undefined;
      if (obj[path]) return obj[path];
      var paths = path.split(keySeparator);
      var current = obj;
      for (var i = 0; i < paths.length; ++i) {
        if (!current) return undefined;
        if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
          return undefined;
        }
        if (current[paths[i]] === undefined) {
          var j = 2;
          var p = paths.slice(i, i + j).join(keySeparator);
          var mix = current[p];
          while (mix === undefined && paths.length > i + j) {
            j++;
            p = paths.slice(i, i + j).join(keySeparator);
            mix = current[p];
          }
          if (mix === undefined) return undefined;
          if (mix === null) return null;
          if (path.endsWith(p)) {
            if (typeof mix === 'string') return mix;
            if (p && typeof mix[p] === 'string') return mix[p];
          }
          var joinedPath = paths.slice(i + j).join(keySeparator);
          if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
          return undefined;
        }
        current = current[paths[i]];
      }
      return current;
    }
    var ResourceStore = function (_EventEmitter) {
      _inherits(ResourceStore, _EventEmitter);
      var _super = _createSuper$3(ResourceStore);
      function ResourceStore(data) {
        var _this;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          ns: ['translation'],
          defaultNS: 'translation'
        };
        _classCallCheck(this, ResourceStore);
        _this = _super.call(this);
        if (isIE10) {
          EventEmitter.call(_assertThisInitialized(_this));
        }
        _this.data = data || {};
        _this.options = options;
        if (_this.options.keySeparator === undefined) {
          _this.options.keySeparator = '.';
        }
        if (_this.options.ignoreJSONStructure === undefined) {
          _this.options.ignoreJSONStructure = true;
        }
        return _this;
      }
      _createClass(ResourceStore, [{
        key: "addNamespaces",
        value: function addNamespaces(ns) {
          if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
          }
        }
      }, {
        key: "removeNamespaces",
        value: function removeNamespaces(ns) {
          var index = this.options.ns.indexOf(ns);
          if (index > -1) {
            this.options.ns.splice(index, 1);
          }
        }
      }, {
        key: "getResource",
        value: function getResource(lng, ns, key) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
          var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
          var path = [lng, ns];
          if (key && typeof key !== 'string') path = path.concat(key);
          if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);
          if (lng.indexOf('.') > -1) {
            path = lng.split('.');
          }
          var result = getPath(this.data, path);
          if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
          return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
        }
      }, {
        key: "addResource",
        value: function addResource(lng, ns, key, value) {
          var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
            silent: false
          };
          var keySeparator = this.options.keySeparator;
          if (keySeparator === undefined) keySeparator = '.';
          var path = [lng, ns];
          if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
          if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            value = ns;
            ns = path[1];
          }
          this.addNamespaces(ns);
          setPath(this.data, path, value);
          if (!options.silent) this.emit('added', lng, ns, key, value);
        }
      }, {
        key: "addResources",
        value: function addResources(lng, ns, resources) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
            silent: false
          };
          for (var m in resources) {
            if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
              silent: true
            });
          }
          if (!options.silent) this.emit('added', lng, ns, resources);
        }
      }, {
        key: "addResourceBundle",
        value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
          var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
            silent: false
          };
          var path = [lng, ns];
          if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            deep = resources;
            resources = ns;
            ns = path[1];
          }
          this.addNamespaces(ns);
          var pack = getPath(this.data, path) || {};
          if (deep) {
            deepExtend(pack, resources, overwrite);
          } else {
            pack = _objectSpread$5(_objectSpread$5({}, pack), resources);
          }
          setPath(this.data, path, pack);
          if (!options.silent) this.emit('added', lng, ns, resources);
        }
      }, {
        key: "removeResourceBundle",
        value: function removeResourceBundle(lng, ns) {
          if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
          }
          this.removeNamespaces(ns);
          this.emit('removed', lng, ns);
        }
      }, {
        key: "hasResourceBundle",
        value: function hasResourceBundle(lng, ns) {
          return this.getResource(lng, ns) !== undefined;
        }
      }, {
        key: "getResourceBundle",
        value: function getResourceBundle(lng, ns) {
          if (!ns) ns = this.options.defaultNS;
          if (this.options.compatibilityAPI === 'v1') return _objectSpread$5(_objectSpread$5({}, {}), this.getResource(lng, ns));
          return this.getResource(lng, ns);
        }
      }, {
        key: "getDataByLanguage",
        value: function getDataByLanguage(lng) {
          return this.data[lng];
        }
      }, {
        key: "hasLanguageSomeTranslations",
        value: function hasLanguageSomeTranslations(lng) {
          var data = this.getDataByLanguage(lng);
          var n = data && Object.keys(data) || [];
          return !!n.find(function (v) {
            return data[v] && Object.keys(data[v]).length > 0;
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.data;
        }
      }]);
      return ResourceStore;
    }(EventEmitter);

    var postProcessor = {
      processors: {},
      addPostProcessor: function addPostProcessor(module) {
        this.processors[module.name] = module;
      },
      handle: function handle(processors, value, key, options, translator) {
        var _this = this;
        processors.forEach(function (processor) {
          if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
        });
        return value;
      }
    };

    function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
    function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    var checkedLoadedFor = {};
    var Translator = function (_EventEmitter) {
      _inherits(Translator, _EventEmitter);
      var _super = _createSuper$2(Translator);
      function Translator(services) {
        var _this;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        _classCallCheck(this, Translator);
        _this = _super.call(this);
        if (isIE10) {
          EventEmitter.call(_assertThisInitialized(_this));
        }
        copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this));
        _this.options = options;
        if (_this.options.keySeparator === undefined) {
          _this.options.keySeparator = '.';
        }
        _this.logger = baseLogger.create('translator');
        return _this;
      }
      _createClass(Translator, [{
        key: "changeLanguage",
        value: function changeLanguage(lng) {
          if (lng) this.language = lng;
        }
      }, {
        key: "exists",
        value: function exists(key) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            interpolation: {}
          };
          if (key === undefined || key === null) {
            return false;
          }
          var resolved = this.resolve(key, options);
          return resolved && resolved.res !== undefined;
        }
      }, {
        key: "extractFromKey",
        value: function extractFromKey(key, options) {
          var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
          if (nsSeparator === undefined) nsSeparator = ':';
          var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
          var namespaces = options.ns || this.options.defaultNS || [];
          var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
          var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
          if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
            var m = key.match(this.interpolator.nestingRegexp);
            if (m && m.length > 0) {
              return {
                key: key,
                namespaces: namespaces
              };
            }
            var parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
            key = parts.join(keySeparator);
          }
          if (typeof namespaces === 'string') namespaces = [namespaces];
          return {
            key: key,
            namespaces: namespaces
          };
        }
      }, {
        key: "translate",
        value: function translate(keys, options, lastKey) {
          var _this2 = this;
          if (_typeof$2(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
            options = this.options.overloadTranslationOptionHandler(arguments);
          }
          if (!options) options = {};
          if (keys === undefined || keys === null) return '';
          if (!Array.isArray(keys)) keys = [String(keys)];
          var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
          var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
          var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
            key = _this$extractFromKey.key,
            namespaces = _this$extractFromKey.namespaces;
          var namespace = namespaces[namespaces.length - 1];
          var lng = options.lng || this.language;
          var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
          if (lng && lng.toLowerCase() === 'cimode') {
            if (appendNamespaceToCIMode) {
              var nsSeparator = options.nsSeparator || this.options.nsSeparator;
              if (returnDetails) {
                resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
                return resolved;
              }
              return "".concat(namespace).concat(nsSeparator).concat(key);
            }
            if (returnDetails) {
              resolved.res = key;
              return resolved;
            }
            return key;
          }
          var resolved = this.resolve(keys, options);
          var res = resolved && resolved.res;
          var resUsedKey = resolved && resolved.usedKey || key;
          var resExactUsedKey = resolved && resolved.exactUsedKey || key;
          var resType = Object.prototype.toString.apply(res);
          var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
          var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
          var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
          var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';
          if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
            if (!options.returnObjects && !this.options.returnObjects) {
              if (!this.options.returnedObjectHandler) {
                this.logger.warn('accessing an object - but returnObjects options is not enabled!');
              }
              var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$4(_objectSpread$4({}, options), {}, {
                ns: namespaces
              })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
              if (returnDetails) {
                resolved.res = r;
                return resolved;
              }
              return r;
            }
            if (keySeparator) {
              var resTypeIsArray = resType === '[object Array]';
              var copy = resTypeIsArray ? [] : {};
              var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
              for (var m in res) {
                if (Object.prototype.hasOwnProperty.call(res, m)) {
                  var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                  copy[m] = this.translate(deepKey, _objectSpread$4(_objectSpread$4({}, options), {
                    joinArrays: false,
                    ns: namespaces
                  }));
                  if (copy[m] === deepKey) copy[m] = res[m];
                }
              }
              res = copy;
            }
          } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
            res = res.join(joinArrays);
            if (res) res = this.extendTranslation(res, keys, options, lastKey);
          } else {
            var usedDefault = false;
            var usedKey = false;
            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
            var hasDefaultValue = Translator.hasDefaultValue(options);
            var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
            var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
            if (!this.isValidLookup(res) && hasDefaultValue) {
              usedDefault = true;
              res = defaultValue;
            }
            if (!this.isValidLookup(res)) {
              usedKey = true;
              res = key;
            }
            var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
            var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
            var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
              this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
              if (keySeparator) {
                var fk = this.resolve(key, _objectSpread$4(_objectSpread$4({}, options), {}, {
                  keySeparator: false
                }));
                if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
              }
              var lngs = [];
              var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
              if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                for (var i = 0; i < fallbackLngs.length; i++) {
                  lngs.push(fallbackLngs[i]);
                }
              } else if (this.options.saveMissingTo === 'all') {
                lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
              } else {
                lngs.push(options.lng || this.language);
              }
              var send = function send(l, k, specificDefaultValue) {
                var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                if (_this2.options.missingKeyHandler) {
                  _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
                } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                  _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
                }
                _this2.emit('missingKey', l, namespace, k, res);
              };
              if (this.options.saveMissing) {
                if (this.options.saveMissingPlurals && needsPluralHandling) {
                  lngs.forEach(function (language) {
                    _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {
                      send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                    });
                  });
                } else {
                  send(lngs, key, defaultValue);
                }
              }
            }
            res = this.extendTranslation(res, keys, options, resolved, lastKey);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
              if (this.options.compatibilityAPI !== 'v1') {
                res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : undefined);
              } else {
                res = this.options.parseMissingKeyHandler(res);
              }
            }
          }
          if (returnDetails) {
            resolved.res = res;
            return resolved;
          }
          return res;
        }
      }, {
        key: "extendTranslation",
        value: function extendTranslation(res, key, options, resolved, lastKey) {
          var _this3 = this;
          if (this.i18nFormat && this.i18nFormat.parse) {
            res = this.i18nFormat.parse(res, _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
              resolved: resolved
            });
          } else if (!options.skipInterpolation) {
            if (options.interpolation) this.interpolator.init(_objectSpread$4(_objectSpread$4({}, options), {
              interpolation: _objectSpread$4(_objectSpread$4({}, this.options.interpolation), options.interpolation)
            }));
            var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            var nestBef;
            if (skipOnVariables) {
              var nb = res.match(this.interpolator.nestingRegexp);
              nestBef = nb && nb.length;
            }
            var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
            if (this.options.interpolation.defaultVariables) data = _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), data);
            res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
            if (skipOnVariables) {
              var na = res.match(this.interpolator.nestingRegexp);
              var nestAft = na && na.length;
              if (nestBef < nestAft) options.nest = false;
            }
            if (options.nest !== false) res = this.interpolator.nest(res, function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (lastKey && lastKey[0] === args[0] && !options.context) {
                _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
                return null;
              }
              return _this3.translate.apply(_this3, args.concat([key]));
            }, options);
            if (options.interpolation) this.interpolator.reset();
          }
          var postProcess = options.postProcess || this.options.postProcess;
          var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;
          if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$4({
              i18nResolved: resolved
            }, options) : options, this);
          }
          return res;
        }
      }, {
        key: "resolve",
        value: function resolve(keys) {
          var _this4 = this;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var found;
          var usedKey;
          var exactUsedKey;
          var usedLng;
          var usedNS;
          if (typeof keys === 'string') keys = [keys];
          keys.forEach(function (k) {
            if (_this4.isValidLookup(found)) return;
            var extracted = _this4.extractFromKey(k, options);
            var key = extracted.key;
            usedKey = key;
            var namespaces = extracted.namespaces;
            if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
            var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
            var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
            var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
            namespaces.forEach(function (ns) {
              if (_this4.isValidLookup(found)) return;
              usedNS = ns;
              if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
                checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
                _this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
              }
              codes.forEach(function (code) {
                if (_this4.isValidLookup(found)) return;
                usedLng = code;
                var finalKeys = [key];
                if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                  _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
                } else {
                  var pluralSuffix;
                  if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
                  var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
                  if (needsPluralHandling) {
                    finalKeys.push(key + pluralSuffix);
                    if (needsZeroSuffixLookup) {
                      finalKeys.push(key + zeroSuffix);
                    }
                  }
                  if (needsContextHandling) {
                    var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                    finalKeys.push(contextKey);
                    if (needsPluralHandling) {
                      finalKeys.push(contextKey + pluralSuffix);
                      if (needsZeroSuffixLookup) {
                        finalKeys.push(contextKey + zeroSuffix);
                      }
                    }
                  }
                }
                var possibleKey;
                while (possibleKey = finalKeys.pop()) {
                  if (!_this4.isValidLookup(found)) {
                    exactUsedKey = possibleKey;
                    found = _this4.getResource(code, ns, possibleKey, options);
                  }
                }
              });
            });
          });
          return {
            res: found,
            usedKey: usedKey,
            exactUsedKey: exactUsedKey,
            usedLng: usedLng,
            usedNS: usedNS
          };
        }
      }, {
        key: "isValidLookup",
        value: function isValidLookup(res) {
          return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
        }
      }, {
        key: "getResource",
        value: function getResource(code, ns, key) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
          return this.resourceStore.getResource(code, ns, key, options);
        }
      }], [{
        key: "hasDefaultValue",
        value: function hasDefaultValue(options) {
          var prefix = 'defaultValue';
          for (var option in options) {
            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
              return true;
            }
          }
          return false;
        }
      }]);
      return Translator;
    }(EventEmitter);

    function capitalize(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    var LanguageUtil = function () {
      function LanguageUtil(options) {
        _classCallCheck(this, LanguageUtil);
        this.options = options;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger.create('languageUtils');
      }
      _createClass(LanguageUtil, [{
        key: "getScriptPartFromCode",
        value: function getScriptPartFromCode(code) {
          if (!code || code.indexOf('-') < 0) return null;
          var p = code.split('-');
          if (p.length === 2) return null;
          p.pop();
          if (p[p.length - 1].toLowerCase() === 'x') return null;
          return this.formatLanguageCode(p.join('-'));
        }
      }, {
        key: "getLanguagePartFromCode",
        value: function getLanguagePartFromCode(code) {
          if (!code || code.indexOf('-') < 0) return code;
          var p = code.split('-');
          return this.formatLanguageCode(p[0]);
        }
      }, {
        key: "formatLanguageCode",
        value: function formatLanguageCode(code) {
          if (typeof code === 'string' && code.indexOf('-') > -1) {
            var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
            var p = code.split('-');
            if (this.options.lowerCaseLng) {
              p = p.map(function (part) {
                return part.toLowerCase();
              });
            } else if (p.length === 2) {
              p[0] = p[0].toLowerCase();
              p[1] = p[1].toUpperCase();
              if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
            } else if (p.length === 3) {
              p[0] = p[0].toLowerCase();
              if (p[1].length === 2) p[1] = p[1].toUpperCase();
              if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
              if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
              if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
            }
            return p.join('-');
          }
          return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
        }
      }, {
        key: "isSupportedCode",
        value: function isSupportedCode(code) {
          if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
            code = this.getLanguagePartFromCode(code);
          }
          return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
        }
      }, {
        key: "getBestMatchFromCodes",
        value: function getBestMatchFromCodes(codes) {
          var _this = this;
          if (!codes) return null;
          var found;
          codes.forEach(function (code) {
            if (found) return;
            var cleanedLng = _this.formatLanguageCode(code);
            if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
          });
          if (!found && this.options.supportedLngs) {
            codes.forEach(function (code) {
              if (found) return;
              var lngOnly = _this.getLanguagePartFromCode(code);
              if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
              found = _this.options.supportedLngs.find(function (supportedLng) {
                if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
              });
            });
          }
          if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
          return found;
        }
      }, {
        key: "getFallbackCodes",
        value: function getFallbackCodes(fallbacks, code) {
          if (!fallbacks) return [];
          if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
          if (typeof fallbacks === 'string') fallbacks = [fallbacks];
          if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
          if (!code) return fallbacks["default"] || [];
          var found = fallbacks[code];
          if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
          if (!found) found = fallbacks[this.formatLanguageCode(code)];
          if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
          if (!found) found = fallbacks["default"];
          return found || [];
        }
      }, {
        key: "toResolveHierarchy",
        value: function toResolveHierarchy(code, fallbackCode) {
          var _this2 = this;
          var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
          var codes = [];
          var addCode = function addCode(c) {
            if (!c) return;
            if (_this2.isSupportedCode(c)) {
              codes.push(c);
            } else {
              _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
            }
          };
          if (typeof code === 'string' && code.indexOf('-') > -1) {
            if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
            if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
          } else if (typeof code === 'string') {
            addCode(this.formatLanguageCode(code));
          }
          fallbackCodes.forEach(function (fc) {
            if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
          });
          return codes;
        }
      }]);
      return LanguageUtil;
    }();

    var sets = [{
      lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
      nr: [1, 2],
      fc: 1
    }, {
      lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
      nr: [1, 2],
      fc: 2
    }, {
      lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
      nr: [1],
      fc: 3
    }, {
      lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
      nr: [1, 2, 5],
      fc: 4
    }, {
      lngs: ['ar'],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5
    }, {
      lngs: ['cs', 'sk'],
      nr: [1, 2, 5],
      fc: 6
    }, {
      lngs: ['csb', 'pl'],
      nr: [1, 2, 5],
      fc: 7
    }, {
      lngs: ['cy'],
      nr: [1, 2, 3, 8],
      fc: 8
    }, {
      lngs: ['fr'],
      nr: [1, 2],
      fc: 9
    }, {
      lngs: ['ga'],
      nr: [1, 2, 3, 7, 11],
      fc: 10
    }, {
      lngs: ['gd'],
      nr: [1, 2, 3, 20],
      fc: 11
    }, {
      lngs: ['is'],
      nr: [1, 2],
      fc: 12
    }, {
      lngs: ['jv'],
      nr: [0, 1],
      fc: 13
    }, {
      lngs: ['kw'],
      nr: [1, 2, 3, 4],
      fc: 14
    }, {
      lngs: ['lt'],
      nr: [1, 2, 10],
      fc: 15
    }, {
      lngs: ['lv'],
      nr: [1, 2, 0],
      fc: 16
    }, {
      lngs: ['mk'],
      nr: [1, 2],
      fc: 17
    }, {
      lngs: ['mnk'],
      nr: [0, 1, 2],
      fc: 18
    }, {
      lngs: ['mt'],
      nr: [1, 2, 11, 20],
      fc: 19
    }, {
      lngs: ['or'],
      nr: [2, 1],
      fc: 2
    }, {
      lngs: ['ro'],
      nr: [1, 2, 20],
      fc: 20
    }, {
      lngs: ['sl'],
      nr: [5, 1, 2, 3],
      fc: 21
    }, {
      lngs: ['he', 'iw'],
      nr: [1, 2, 20, 21],
      fc: 22
    }];
    var _rulesPluralsTypes = {
      1: function _(n) {
        return Number(n > 1);
      },
      2: function _(n) {
        return Number(n != 1);
      },
      3: function _(n) {
        return 0;
      },
      4: function _(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      5: function _(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
      },
      6: function _(n) {
        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
      },
      7: function _(n) {
        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      8: function _(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
      },
      9: function _(n) {
        return Number(n >= 2);
      },
      10: function _(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
      },
      11: function _(n) {
        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
      },
      12: function _(n) {
        return Number(n % 10 != 1 || n % 100 == 11);
      },
      13: function _(n) {
        return Number(n !== 0);
      },
      14: function _(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
      },
      15: function _(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      16: function _(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
      },
      17: function _(n) {
        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
      },
      18: function _(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
      },
      19: function _(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
      },
      20: function _(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
      },
      21: function _(n) {
        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
      },
      22: function _(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
      }
    };
    var deprecatedJsonVersions = ['v1', 'v2', 'v3'];
    var suffixesOrder = {
      zero: 0,
      one: 1,
      two: 2,
      few: 3,
      many: 4,
      other: 5
    };
    function createRules() {
      var rules = {};
      sets.forEach(function (set) {
        set.lngs.forEach(function (l) {
          rules[l] = {
            numbers: set.nr,
            plurals: _rulesPluralsTypes[set.fc]
          };
        });
      });
      return rules;
    }
    var PluralResolver = function () {
      function PluralResolver(languageUtils) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        _classCallCheck(this, PluralResolver);
        this.languageUtils = languageUtils;
        this.options = options;
        this.logger = baseLogger.create('pluralResolver');
        if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
          this.options.compatibilityJSON = 'v3';
          this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
        }
        this.rules = createRules();
      }
      _createClass(PluralResolver, [{
        key: "addRule",
        value: function addRule(lng, obj) {
          this.rules[lng] = obj;
        }
      }, {
        key: "getRule",
        value: function getRule(code) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (this.shouldUseIntlApi()) {
            try {
              return new Intl.PluralRules(code, {
                type: options.ordinal ? 'ordinal' : 'cardinal'
              });
            } catch (_unused) {
              return;
            }
          }
          return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
        }
      }, {
        key: "needsPlural",
        value: function needsPlural(code) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var rule = this.getRule(code, options);
          if (this.shouldUseIntlApi()) {
            return rule && rule.resolvedOptions().pluralCategories.length > 1;
          }
          return rule && rule.numbers.length > 1;
        }
      }, {
        key: "getPluralFormsOfKey",
        value: function getPluralFormsOfKey(code, key) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return this.getSuffixes(code, options).map(function (suffix) {
            return "".concat(key).concat(suffix);
          });
        }
      }, {
        key: "getSuffixes",
        value: function getSuffixes(code) {
          var _this = this;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var rule = this.getRule(code, options);
          if (!rule) {
            return [];
          }
          if (this.shouldUseIntlApi()) {
            return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {
              return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
            }).map(function (pluralCategory) {
              return "".concat(_this.options.prepend).concat(pluralCategory);
            });
          }
          return rule.numbers.map(function (number) {
            return _this.getSuffix(code, number, options);
          });
        }
      }, {
        key: "getSuffix",
        value: function getSuffix(code, count) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var rule = this.getRule(code, options);
          if (rule) {
            if (this.shouldUseIntlApi()) {
              return "".concat(this.options.prepend).concat(rule.select(count));
            }
            return this.getSuffixRetroCompatible(rule, count);
          }
          this.logger.warn("no plural rule found for: ".concat(code));
          return '';
        }
      }, {
        key: "getSuffixRetroCompatible",
        value: function getSuffixRetroCompatible(rule, count) {
          var _this2 = this;
          var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
          var suffix = rule.numbers[idx];
          if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            if (suffix === 2) {
              suffix = 'plural';
            } else if (suffix === 1) {
              suffix = '';
            }
          }
          var returnSuffix = function returnSuffix() {
            return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
          };
          if (this.options.compatibilityJSON === 'v1') {
            if (suffix === 1) return '';
            if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
            return returnSuffix();
          } else if (this.options.compatibilityJSON === 'v2') {
            return returnSuffix();
          } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return returnSuffix();
          }
          return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
        }
      }, {
        key: "shouldUseIntlApi",
        value: function shouldUseIntlApi() {
          return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
        }
      }]);
      return PluralResolver;
    }();

    function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    var Interpolator = function () {
      function Interpolator() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, Interpolator);
        this.logger = baseLogger.create('interpolator');
        this.options = options;
        this.format = options.interpolation && options.interpolation.format || function (value) {
          return value;
        };
        this.init(options);
      }
      _createClass(Interpolator, [{
        key: "init",
        value: function init() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          if (!options.interpolation) options.interpolation = {
            escapeValue: true
          };
          var iOpts = options.interpolation;
          this.escape = iOpts.escape !== undefined ? iOpts.escape : escape$1;
          this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
          this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
          this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
          this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
          this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
          this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
          this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
          this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
          this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
          this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
          this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
          this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
          this.resetRegExp();
        }
      }, {
        key: "reset",
        value: function reset() {
          if (this.options) this.init(this.options);
        }
      }, {
        key: "resetRegExp",
        value: function resetRegExp() {
          var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
          this.regexp = new RegExp(regexpStr, 'g');
          var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
          this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
          var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
          this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
        }
      }, {
        key: "interpolate",
        value: function interpolate(str, data, lng, options) {
          var _this = this;
          var match;
          var value;
          var replaces;
          var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
          function regexSafe(val) {
            return val.replace(/\$/g, '$$$$');
          }
          var handleFormat = function handleFormat(key) {
            if (key.indexOf(_this.formatSeparator) < 0) {
              var path = getPathWithDefaults(data, defaultData, key);
              return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
                interpolationkey: key
              })) : path;
            }
            var p = key.split(_this.formatSeparator);
            var k = p.shift().trim();
            var f = p.join(_this.formatSeparator).trim();
            return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
              interpolationkey: k
            }));
          };
          this.resetRegExp();
          var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
          var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
          var todos = [{
            regex: this.regexpUnescape,
            safeValue: function safeValue(val) {
              return regexSafe(val);
            }
          }, {
            regex: this.regexp,
            safeValue: function safeValue(val) {
              return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
            }
          }];
          todos.forEach(function (todo) {
            replaces = 0;
            while (match = todo.regex.exec(str)) {
              var matchedVar = match[1].trim();
              value = handleFormat(matchedVar);
              if (value === undefined) {
                if (typeof missingInterpolationHandler === 'function') {
                  var temp = missingInterpolationHandler(str, match, options);
                  value = typeof temp === 'string' ? temp : '';
                } else if (options && options.hasOwnProperty(matchedVar)) {
                  value = '';
                } else if (skipOnVariables) {
                  value = match[0];
                  continue;
                } else {
                  _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
                  value = '';
                }
              } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {
                value = makeString(value);
              }
              var safeValue = todo.safeValue(value);
              str = str.replace(match[0], safeValue);
              if (skipOnVariables) {
                todo.regex.lastIndex += value.length;
                todo.regex.lastIndex -= match[0].length;
              } else {
                todo.regex.lastIndex = 0;
              }
              replaces++;
              if (replaces >= _this.maxReplaces) {
                break;
              }
            }
          });
          return str;
        }
      }, {
        key: "nest",
        value: function nest(str, fc) {
          var _this2 = this;
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var match;
          var value;
          var clonedOptions;
          function handleHasOptions(key, inheritedOptions) {
            var sep = this.nestingOptionsSeparator;
            if (key.indexOf(sep) < 0) return key;
            var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
            var optionsString = "{".concat(c[1]);
            key = c[0];
            optionsString = this.interpolate(optionsString, clonedOptions);
            var matchedSingleQuotes = optionsString.match(/'/g);
            var matchedDoubleQuotes = optionsString.match(/"/g);
            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
              optionsString = optionsString.replace(/'/g, '"');
            }
            try {
              clonedOptions = JSON.parse(optionsString);
              if (inheritedOptions) clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
            } catch (e) {
              this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
              return "".concat(key).concat(sep).concat(optionsString);
            }
            delete clonedOptions.defaultValue;
            return key;
          }
          while (match = this.nestingRegexp.exec(str)) {
            var formatters = [];
            clonedOptions = _objectSpread$3({}, options);
            clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== 'string' ? clonedOptions.replace : clonedOptions;
            clonedOptions.applyPostProcessor = false;
            delete clonedOptions.defaultValue;
            var doReduce = false;
            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
              var r = match[1].split(this.formatSeparator).map(function (elem) {
                return elem.trim();
              });
              match[1] = r.shift();
              formatters = r;
              doReduce = true;
            }
            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
            if (value && match[0] === str && typeof value !== 'string') return value;
            if (typeof value !== 'string') value = makeString(value);
            if (!value) {
              this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
              value = '';
            }
            if (doReduce) {
              value = formatters.reduce(function (v, f) {
                return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
                  interpolationkey: match[1].trim()
                }));
              }, value.trim());
            }
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
          }
          return str;
        }
      }]);
      return Interpolator;
    }();

    function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    function parseFormatStr(formatStr) {
      var formatName = formatStr.toLowerCase().trim();
      var formatOptions = {};
      if (formatStr.indexOf('(') > -1) {
        var p = formatStr.split('(');
        formatName = p[0].toLowerCase().trim();
        var optStr = p[1].substring(0, p[1].length - 1);
        if (formatName === 'currency' && optStr.indexOf(':') < 0) {
          if (!formatOptions.currency) formatOptions.currency = optStr.trim();
        } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
          if (!formatOptions.range) formatOptions.range = optStr.trim();
        } else {
          var opts = optStr.split(';');
          opts.forEach(function (opt) {
            if (!opt) return;
            var _opt$split = opt.split(':'),
              _opt$split2 = _toArray(_opt$split),
              key = _opt$split2[0],
              rest = _opt$split2.slice(1);
            var val = rest.join(':').trim().replace(/^'+|'+$/g, '');
            if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
            if (val === 'false') formatOptions[key.trim()] = false;
            if (val === 'true') formatOptions[key.trim()] = true;
            if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
          });
        }
      }
      return {
        formatName: formatName,
        formatOptions: formatOptions
      };
    }
    function createCachedFormatter(fn) {
      var cache = {};
      return function invokeFormatter(val, lng, options) {
        var key = lng + JSON.stringify(options);
        var formatter = cache[key];
        if (!formatter) {
          formatter = fn(lng, options);
          cache[key] = formatter;
        }
        return formatter(val);
      };
    }
    var Formatter = function () {
      function Formatter() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, Formatter);
        this.logger = baseLogger.create('formatter');
        this.options = options;
        this.formats = {
          number: createCachedFormatter(function (lng, options) {
            var formatter = new Intl.NumberFormat(lng, options);
            return function (val) {
              return formatter.format(val);
            };
          }),
          currency: createCachedFormatter(function (lng, options) {
            var formatter = new Intl.NumberFormat(lng, _objectSpread$2(_objectSpread$2({}, options), {}, {
              style: 'currency'
            }));
            return function (val) {
              return formatter.format(val);
            };
          }),
          datetime: createCachedFormatter(function (lng, options) {
            var formatter = new Intl.DateTimeFormat(lng, _objectSpread$2({}, options));
            return function (val) {
              return formatter.format(val);
            };
          }),
          relativetime: createCachedFormatter(function (lng, options) {
            var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$2({}, options));
            return function (val) {
              return formatter.format(val, options.range || 'day');
            };
          }),
          list: createCachedFormatter(function (lng, options) {
            var formatter = new Intl.ListFormat(lng, _objectSpread$2({}, options));
            return function (val) {
              return formatter.format(val);
            };
          })
        };
        this.init(options);
      }
      _createClass(Formatter, [{
        key: "init",
        value: function init(services) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            interpolation: {}
          };
          var iOpts = options.interpolation;
          this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
        }
      }, {
        key: "add",
        value: function add(name, fc) {
          this.formats[name.toLowerCase().trim()] = fc;
        }
      }, {
        key: "addCached",
        value: function addCached(name, fc) {
          this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
        }
      }, {
        key: "format",
        value: function format(value, _format, lng, options) {
          var _this = this;
          var formats = _format.split(this.formatSeparator);
          var result = formats.reduce(function (mem, f) {
            var _parseFormatStr = parseFormatStr(f),
              formatName = _parseFormatStr.formatName,
              formatOptions = _parseFormatStr.formatOptions;
            if (_this.formats[formatName]) {
              var formatted = mem;
              try {
                var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
                var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
                formatted = _this.formats[formatName](mem, l, _objectSpread$2(_objectSpread$2(_objectSpread$2({}, formatOptions), options), valOptions));
              } catch (error) {
                _this.logger.warn(error);
              }
              return formatted;
            } else {
              _this.logger.warn("there was no format function for ".concat(formatName));
            }
            return mem;
          }, value);
          return result;
        }
      }]);
      return Formatter;
    }();

    function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
    function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    function removePending(q, name) {
      if (q.pending[name] !== undefined) {
        delete q.pending[name];
        q.pendingCount--;
      }
    }
    var Connector = function (_EventEmitter) {
      _inherits(Connector, _EventEmitter);
      var _super = _createSuper$1(Connector);
      function Connector(backend, store, services) {
        var _this;
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        _classCallCheck(this, Connector);
        _this = _super.call(this);
        if (isIE10) {
          EventEmitter.call(_assertThisInitialized(_this));
        }
        _this.backend = backend;
        _this.store = store;
        _this.services = services;
        _this.languageUtils = services.languageUtils;
        _this.options = options;
        _this.logger = baseLogger.create('backendConnector');
        _this.waitingReads = [];
        _this.maxParallelReads = options.maxParallelReads || 10;
        _this.readingCalls = 0;
        _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
        _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
        _this.state = {};
        _this.queue = [];
        if (_this.backend && _this.backend.init) {
          _this.backend.init(services, options.backend, options);
        }
        return _this;
      }
      _createClass(Connector, [{
        key: "queueLoad",
        value: function queueLoad(languages, namespaces, options, callback) {
          var _this2 = this;
          var toLoad = {};
          var pending = {};
          var toLoadLanguages = {};
          var toLoadNamespaces = {};
          languages.forEach(function (lng) {
            var hasAllNamespaces = true;
            namespaces.forEach(function (ns) {
              var name = "".concat(lng, "|").concat(ns);
              if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
                _this2.state[name] = 2;
              } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
                if (pending[name] === undefined) pending[name] = true;
              } else {
                _this2.state[name] = 1;
                hasAllNamespaces = false;
                if (pending[name] === undefined) pending[name] = true;
                if (toLoad[name] === undefined) toLoad[name] = true;
                if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
              }
            });
            if (!hasAllNamespaces) toLoadLanguages[lng] = true;
          });
          if (Object.keys(toLoad).length || Object.keys(pending).length) {
            this.queue.push({
              pending: pending,
              pendingCount: Object.keys(pending).length,
              loaded: {},
              errors: [],
              callback: callback
            });
          }
          return {
            toLoad: Object.keys(toLoad),
            pending: Object.keys(pending),
            toLoadLanguages: Object.keys(toLoadLanguages),
            toLoadNamespaces: Object.keys(toLoadNamespaces)
          };
        }
      }, {
        key: "loaded",
        value: function loaded(name, err, data) {
          var s = name.split('|');
          var lng = s[0];
          var ns = s[1];
          if (err) this.emit('failedLoading', lng, ns, err);
          if (data) {
            this.store.addResourceBundle(lng, ns, data);
          }
          this.state[name] = err ? -1 : 2;
          var loaded = {};
          this.queue.forEach(function (q) {
            pushPath(q.loaded, [lng], ns);
            removePending(q, name);
            if (err) q.errors.push(err);
            if (q.pendingCount === 0 && !q.done) {
              Object.keys(q.loaded).forEach(function (l) {
                if (!loaded[l]) loaded[l] = {};
                var loadedKeys = q.loaded[l];
                if (loadedKeys.length) {
                  loadedKeys.forEach(function (ns) {
                    if (loaded[l][ns] === undefined) loaded[l][ns] = true;
                  });
                }
              });
              q.done = true;
              if (q.errors.length) {
                q.callback(q.errors);
              } else {
                q.callback();
              }
            }
          });
          this.emit('loaded', loaded);
          this.queue = this.queue.filter(function (q) {
            return !q.done;
          });
        }
      }, {
        key: "read",
        value: function read(lng, ns, fcName) {
          var _this3 = this;
          var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
          var callback = arguments.length > 5 ? arguments[5] : undefined;
          if (!lng.length) return callback(null, {});
          if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
              lng: lng,
              ns: ns,
              fcName: fcName,
              tried: tried,
              wait: wait,
              callback: callback
            });
            return;
          }
          this.readingCalls++;
          var resolver = function resolver(err, data) {
            _this3.readingCalls--;
            if (_this3.waitingReads.length > 0) {
              var next = _this3.waitingReads.shift();
              _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
            }
            if (err && data && tried < _this3.maxRetries) {
              setTimeout(function () {
                _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
              }, wait);
              return;
            }
            callback(err, data);
          };
          var fc = this.backend[fcName].bind(this.backend);
          if (fc.length === 2) {
            try {
              var r = fc(lng, ns);
              if (r && typeof r.then === 'function') {
                r.then(function (data) {
                  return resolver(null, data);
                })["catch"](resolver);
              } else {
                resolver(null, r);
              }
            } catch (err) {
              resolver(err);
            }
            return;
          }
          return fc(lng, ns, resolver);
        }
      }, {
        key: "prepareLoading",
        value: function prepareLoading(languages, namespaces) {
          var _this4 = this;
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var callback = arguments.length > 3 ? arguments[3] : undefined;
          if (!this.backend) {
            this.logger.warn('No backend was added via i18next.use. Will not load resources.');
            return callback && callback();
          }
          if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
          if (typeof namespaces === 'string') namespaces = [namespaces];
          var toLoad = this.queueLoad(languages, namespaces, options, callback);
          if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length) callback();
            return null;
          }
          toLoad.toLoad.forEach(function (name) {
            _this4.loadOne(name);
          });
        }
      }, {
        key: "load",
        value: function load(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {}, callback);
        }
      }, {
        key: "reload",
        value: function reload(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {
            reload: true
          }, callback);
        }
      }, {
        key: "loadOne",
        value: function loadOne(name) {
          var _this5 = this;
          var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var s = name.split('|');
          var lng = s[0];
          var ns = s[1];
          this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
            if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
            if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
            _this5.loaded(name, err, data);
          });
        }
      }, {
        key: "saveMissing",
        value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
          var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
          var clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function () {};
          if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
            this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
            return;
          }
          if (key === undefined || key === null || key === '') return;
          if (this.backend && this.backend.create) {
            var opts = _objectSpread$1(_objectSpread$1({}, options), {}, {
              isUpdate: isUpdate
            });
            var fc = this.backend.create.bind(this.backend);
            if (fc.length < 6) {
              try {
                var r;
                if (fc.length === 5) {
                  r = fc(languages, namespace, key, fallbackValue, opts);
                } else {
                  r = fc(languages, namespace, key, fallbackValue);
                }
                if (r && typeof r.then === 'function') {
                  r.then(function (data) {
                    return clb(null, data);
                  })["catch"](clb);
                } else {
                  clb(null, r);
                }
              } catch (err) {
                clb(err);
              }
            } else {
              fc(languages, namespace, key, fallbackValue, clb, opts);
            }
          }
          if (!languages || !languages[0]) return;
          this.store.addResource(languages[0], namespace, key, fallbackValue);
        }
      }]);
      return Connector;
    }(EventEmitter);

    function get() {
      return {
        debug: false,
        initImmediate: true,
        ns: ['translation'],
        defaultNS: ['translation'],
        fallbackLng: ['dev'],
        fallbackNS: false,
        supportedLngs: false,
        nonExplicitSupportedLngs: false,
        load: 'all',
        preload: false,
        simplifyPluralSuffix: true,
        keySeparator: '.',
        nsSeparator: ':',
        pluralSeparator: '_',
        contextSeparator: '_',
        partialBundledLanguages: false,
        saveMissing: false,
        updateMissing: false,
        saveMissingTo: 'fallback',
        saveMissingPlurals: true,
        missingKeyHandler: false,
        missingInterpolationHandler: false,
        postProcess: false,
        postProcessPassResolved: false,
        returnNull: true,
        returnEmptyString: true,
        returnObjects: false,
        joinArrays: false,
        returnedObjectHandler: false,
        parseMissingKeyHandler: false,
        appendNamespaceToMissingKey: false,
        appendNamespaceToCIMode: false,
        overloadTranslationOptionHandler: function handle(args) {
          var ret = {};
          if (_typeof$2(args[1]) === 'object') ret = args[1];
          if (typeof args[1] === 'string') ret.defaultValue = args[1];
          if (typeof args[2] === 'string') ret.tDescription = args[2];
          if (_typeof$2(args[2]) === 'object' || _typeof$2(args[3]) === 'object') {
            var options = args[3] || args[2];
            Object.keys(options).forEach(function (key) {
              ret[key] = options[key];
            });
          }
          return ret;
        },
        interpolation: {
          escapeValue: true,
          format: function format(value, _format, lng, options) {
            return value;
          },
          prefix: '{{',
          suffix: '}}',
          formatSeparator: ',',
          unescapePrefix: '-',
          nestingPrefix: '$t(',
          nestingSuffix: ')',
          nestingOptionsSeparator: ',',
          maxReplaces: 1000,
          skipOnVariables: true
        }
      };
    }
    function transformOptions(options) {
      if (typeof options.ns === 'string') options.ns = [options.ns];
      if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
      if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];
      if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
        options.supportedLngs = options.supportedLngs.concat(['cimode']);
      }
      return options;
    }

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    function noop() {}
    function bindMemberFunctions(inst) {
      var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
      mems.forEach(function (mem) {
        if (typeof inst[mem] === 'function') {
          inst[mem] = inst[mem].bind(inst);
        }
      });
    }
    var I18n = function (_EventEmitter) {
      _inherits(I18n, _EventEmitter);
      var _super = _createSuper(I18n);
      function I18n() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : undefined;
        _classCallCheck(this, I18n);
        _this = _super.call(this);
        if (isIE10) {
          EventEmitter.call(_assertThisInitialized(_this));
        }
        _this.options = transformOptions(options);
        _this.services = {};
        _this.logger = baseLogger;
        _this.modules = {
          external: []
        };
        bindMemberFunctions(_assertThisInitialized(_this));
        if (callback && !_this.isInitialized && !options.isClone) {
          if (!_this.options.initImmediate) {
            _this.init(options, callback);
            return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
          }
          setTimeout(function () {
            _this.init(options, callback);
          }, 0);
        }
        return _this;
      }
      _createClass(I18n, [{
        key: "init",
        value: function init() {
          var _this2 = this;
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : undefined;
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          if (!options.defaultNS && options.defaultNS !== false && options.ns) {
            if (typeof options.ns === 'string') {
              options.defaultNS = options.ns;
            } else if (options.ns.indexOf('translation') < 0) {
              options.defaultNS = options.ns[0];
            }
          }
          var defOpts = get();
          this.options = _objectSpread(_objectSpread(_objectSpread({}, defOpts), this.options), transformOptions(options));
          if (this.options.compatibilityAPI !== 'v1') {
            this.options.interpolation = _objectSpread(_objectSpread({}, defOpts.interpolation), this.options.interpolation);
          }
          if (options.keySeparator !== undefined) {
            this.options.userDefinedKeySeparator = options.keySeparator;
          }
          if (options.nsSeparator !== undefined) {
            this.options.userDefinedNsSeparator = options.nsSeparator;
          }
          function createClassOnDemand(ClassOrObject) {
            if (!ClassOrObject) return null;
            if (typeof ClassOrObject === 'function') return new ClassOrObject();
            return ClassOrObject;
          }
          if (!this.options.isClone) {
            if (this.modules.logger) {
              baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
            } else {
              baseLogger.init(null, this.options);
            }
            var formatter;
            if (this.modules.formatter) {
              formatter = this.modules.formatter;
            } else if (typeof Intl !== 'undefined') {
              formatter = Formatter;
            }
            var lu = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources, this.options);
            var s = this.services;
            s.logger = baseLogger;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver(lu, {
              prepend: this.options.pluralSeparator,
              compatibilityJSON: this.options.compatibilityJSON,
              simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
              s.formatter = createClassOnDemand(formatter);
              s.formatter.init(s, this.options);
              this.options.interpolation.format = s.formatter.format.bind(s.formatter);
            }
            s.interpolator = new Interpolator(this.options);
            s.utils = {
              hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on('*', function (event) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              _this2.emit.apply(_this2, [event].concat(args));
            });
            if (this.modules.languageDetector) {
              s.languageDetector = createClassOnDemand(this.modules.languageDetector);
              if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
              s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
              if (s.i18nFormat.init) s.i18nFormat.init(this);
            }
            this.translator = new Translator(this.services, this.options);
            this.translator.on('*', function (event) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              _this2.emit.apply(_this2, [event].concat(args));
            });
            this.modules.external.forEach(function (m) {
              if (m.init) m.init(_this2);
            });
          }
          this.format = this.options.interpolation.format;
          if (!callback) callback = noop;
          if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
          }
          if (!this.services.languageDetector && !this.options.lng) {
            this.logger.warn('init: no languageDetector is used and no lng is defined');
          }
          var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
          storeApi.forEach(function (fcName) {
            _this2[fcName] = function () {
              var _this2$store;
              return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
            };
          });
          var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
          storeApiChained.forEach(function (fcName) {
            _this2[fcName] = function () {
              var _this2$store2;
              (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
              return _this2;
            };
          });
          var deferred = defer();
          var load = function load() {
            var finish = function finish(err, t) {
              if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');
              _this2.isInitialized = true;
              if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);
              _this2.emit('initialized', _this2.options);
              deferred.resolve(t);
              callback(err, t);
            };
            if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
            _this2.changeLanguage(_this2.options.lng, finish);
          };
          if (this.options.resources || !this.options.initImmediate) {
            load();
          } else {
            setTimeout(load, 0);
          }
          return deferred;
        }
      }, {
        key: "loadResources",
        value: function loadResources(language) {
          var _this3 = this;
          var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
          var usedCallback = callback;
          var usedLng = typeof language === 'string' ? language : this.language;
          if (typeof language === 'function') usedCallback = language;
          if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
            var toLoad = [];
            var append = function append(lng) {
              if (!lng) return;
              var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
              lngs.forEach(function (l) {
                if (toLoad.indexOf(l) < 0) toLoad.push(l);
              });
            };
            if (!usedLng) {
              var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              fallbacks.forEach(function (l) {
                return append(l);
              });
            } else {
              append(usedLng);
            }
            if (this.options.preload) {
              this.options.preload.forEach(function (l) {
                return append(l);
              });
            }
            this.services.backendConnector.load(toLoad, this.options.ns, function (e) {
              if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);
              usedCallback(e);
            });
          } else {
            usedCallback(null);
          }
        }
      }, {
        key: "reloadResources",
        value: function reloadResources(lngs, ns, callback) {
          var deferred = defer();
          if (!lngs) lngs = this.languages;
          if (!ns) ns = this.options.ns;
          if (!callback) callback = noop;
          this.services.backendConnector.reload(lngs, ns, function (err) {
            deferred.resolve();
            callback(err);
          });
          return deferred;
        }
      }, {
        key: "use",
        value: function use(module) {
          if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
          if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
          if (module.type === 'backend') {
            this.modules.backend = module;
          }
          if (module.type === 'logger' || module.log && module.warn && module.error) {
            this.modules.logger = module;
          }
          if (module.type === 'languageDetector') {
            this.modules.languageDetector = module;
          }
          if (module.type === 'i18nFormat') {
            this.modules.i18nFormat = module;
          }
          if (module.type === 'postProcessor') {
            postProcessor.addPostProcessor(module);
          }
          if (module.type === 'formatter') {
            this.modules.formatter = module;
          }
          if (module.type === '3rdParty') {
            this.modules.external.push(module);
          }
          return this;
        }
      }, {
        key: "setResolvedLanguage",
        value: function setResolvedLanguage(l) {
          if (!l || !this.languages) return;
          if (['cimode', 'dev'].indexOf(l) > -1) return;
          for (var li = 0; li < this.languages.length; li++) {
            var lngInLngs = this.languages[li];
            if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;
            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
              this.resolvedLanguage = lngInLngs;
              break;
            }
          }
        }
      }, {
        key: "changeLanguage",
        value: function changeLanguage(lng, callback) {
          var _this4 = this;
          this.isLanguageChangingTo = lng;
          var deferred = defer();
          this.emit('languageChanging', lng);
          var setLngProps = function setLngProps(l) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
            _this4.resolvedLanguage = undefined;
            _this4.setResolvedLanguage(l);
          };
          var done = function done(err, l) {
            if (l) {
              setLngProps(l);
              _this4.translator.changeLanguage(l);
              _this4.isLanguageChangingTo = undefined;
              _this4.emit('languageChanged', l);
              _this4.logger.log('languageChanged', l);
            } else {
              _this4.isLanguageChangingTo = undefined;
            }
            deferred.resolve(function () {
              return _this4.t.apply(_this4, arguments);
            });
            if (callback) callback(err, function () {
              return _this4.t.apply(_this4, arguments);
            });
          };
          var setLng = function setLng(lngs) {
            if (!lng && !lngs && _this4.services.languageDetector) lngs = [];
            var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
            if (l) {
              if (!_this4.language) {
                setLngProps(l);
              }
              if (!_this4.translator.language) _this4.translator.changeLanguage(l);
              if (_this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage) _this4.services.languageDetector.cacheUserLanguage(l);
            }
            _this4.loadResources(l, function (err) {
              done(err, l);
            });
          };
          if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
          } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            if (this.services.languageDetector.detect.length === 0) {
              this.services.languageDetector.detect().then(setLng);
            } else {
              this.services.languageDetector.detect(setLng);
            }
          } else {
            setLng(lng);
          }
          return deferred;
        }
      }, {
        key: "getFixedT",
        value: function getFixedT(lng, ns, keyPrefix) {
          var _this5 = this;
          var fixedT = function fixedT(key, opts) {
            var options;
            if (_typeof$2(opts) !== 'object') {
              for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                rest[_key3 - 2] = arguments[_key3];
              }
              options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
            } else {
              options = _objectSpread({}, opts);
            }
            options.lng = options.lng || fixedT.lng;
            options.lngs = options.lngs || fixedT.lngs;
            options.ns = options.ns || fixedT.ns;
            options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
            var keySeparator = _this5.options.keySeparator || '.';
            var resultKey;
            if (options.keyPrefix && Array.isArray(key)) {
              resultKey = key.map(function (k) {
                return "".concat(options.keyPrefix).concat(keySeparator).concat(k);
              });
            } else {
              resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
            }
            return _this5.t(resultKey, options);
          };
          if (typeof lng === 'string') {
            fixedT.lng = lng;
          } else {
            fixedT.lngs = lng;
          }
          fixedT.ns = ns;
          fixedT.keyPrefix = keyPrefix;
          return fixedT;
        }
      }, {
        key: "t",
        value: function t() {
          var _this$translator;
          return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
        }
      }, {
        key: "exists",
        value: function exists() {
          var _this$translator2;
          return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
        }
      }, {
        key: "setDefaultNamespace",
        value: function setDefaultNamespace(ns) {
          this.options.defaultNS = ns;
        }
      }, {
        key: "hasLoadedNamespace",
        value: function hasLoadedNamespace(ns) {
          var _this6 = this;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (!this.isInitialized) {
            this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
            return false;
          }
          if (!this.languages || !this.languages.length) {
            this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
            return false;
          }
          var lng = this.resolvedLanguage || this.languages[0];
          var fallbackLng = this.options ? this.options.fallbackLng : false;
          var lastLng = this.languages[this.languages.length - 1];
          if (lng.toLowerCase() === 'cimode') return true;
          var loadNotPending = function loadNotPending(l, n) {
            var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
            return loadState === -1 || loadState === 2;
          };
          if (options.precheck) {
            var preResult = options.precheck(this, loadNotPending);
            if (preResult !== undefined) return preResult;
          }
          if (this.hasResourceBundle(lng, ns)) return true;
          if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
          if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
          return false;
        }
      }, {
        key: "loadNamespaces",
        value: function loadNamespaces(ns, callback) {
          var _this7 = this;
          var deferred = defer();
          if (!this.options.ns) {
            callback && callback();
            return Promise.resolve();
          }
          if (typeof ns === 'string') ns = [ns];
          ns.forEach(function (n) {
            if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
          });
          this.loadResources(function (err) {
            deferred.resolve();
            if (callback) callback(err);
          });
          return deferred;
        }
      }, {
        key: "loadLanguages",
        value: function loadLanguages(lngs, callback) {
          var deferred = defer();
          if (typeof lngs === 'string') lngs = [lngs];
          var preloaded = this.options.preload || [];
          var newLngs = lngs.filter(function (lng) {
            return preloaded.indexOf(lng) < 0;
          });
          if (!newLngs.length) {
            if (callback) callback();
            return Promise.resolve();
          }
          this.options.preload = preloaded.concat(newLngs);
          this.loadResources(function (err) {
            deferred.resolve();
            if (callback) callback(err);
          });
          return deferred;
        }
      }, {
        key: "dir",
        value: function dir(lng) {
          if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
          if (!lng) return 'rtl';
          var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
          var languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
          return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
        }
      }, {
        key: "cloneInstance",
        value: function cloneInstance() {
          var _this8 = this;
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
          var mergedOptions = _objectSpread(_objectSpread(_objectSpread({}, this.options), options), {
            isClone: true
          });
          var clone = new I18n(mergedOptions);
          if (options.debug !== undefined || options.prefix !== undefined) {
            clone.logger = clone.logger.clone(options);
          }
          var membersToCopy = ['store', 'services', 'language'];
          membersToCopy.forEach(function (m) {
            clone[m] = _this8[m];
          });
          clone.services = _objectSpread({}, this.services);
          clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
          };
          clone.translator = new Translator(clone.services, clone.options);
          clone.translator.on('*', function (event) {
            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args[_key4 - 1] = arguments[_key4];
            }
            clone.emit.apply(clone, [event].concat(args));
          });
          clone.init(mergedOptions, callback);
          clone.translator.options = clone.options;
          clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
          };
          return clone;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
          };
        }
      }]);
      return I18n;
    }(EventEmitter);
    _defineProperty(I18n, "createInstance", function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      return new I18n(options, callback);
    });
    var instance = I18n.createInstance();
    instance.createInstance = I18n.createInstance;

    instance.createInstance;
    instance.dir;
    instance.init;
    instance.loadResources;
    instance.reloadResources;
    instance.use;
    instance.changeLanguage;
    instance.getFixedT;
    var t = instance.t;
    instance.exists;
    instance.setDefaultNamespace;
    instance.hasLoadedNamespace;
    instance.loadNamespaces;
    instance.loadLanguages;

    var useTitleNotification = function () {
        var _a = require$$0$1.useState(true), showTitle = _a[0], setShowTitle = _a[1];
        var _b = require$$0$1.useState(true), blinking = _b[0], setBlinking = _b[1];
        var _c = require$$0$1.useState(''), text = _c[0], setText = _c[1];
        var defaultTitle = require$$0$1.useMemo(function () { return document.title; }, []);
        var show = function (text) {
            setText(text);
            setBlinking(true);
        };
        var resetTitle = function () {
            setBlinking(false);
        };
        require$$0$1.useEffect(function () {
            var intervalId = setInterval(function () {
                setShowTitle(function (prevShowTitle) { return !prevShowTitle; });
            }, 1000);
            if (!blinking) {
                clearInterval(intervalId);
                setShowTitle(false);
                setText('');
            }
            return function () { return clearInterval(intervalId); };
        }, [blinking]);
        require$$0$1.useEffect(function () {
            document.title = showTitle ? text : defaultTitle;
        }, [showTitle]);
        return { show: show, resetTitle: resetTitle };
    };

    var MESSAGES_PER_PAGE = 30;
    var Body = function () {
        var scrollViewRef = require$$0$1.useRef(null);
        var rid = useAppSelector(function (state) { return state.room; }).rid;
        var user = useAppSelector(function (state) { return state.user; }).user;
        var rc = useRc().rc;
        var messages = useAppSelector(messagesSelectors.selectAll);
        var dispatch = useAppDispatch();
        var windowFocused = useWindowFocus();
        var _a = useTitleNotification(), show = _a.show, resetTitle = _a.resetTitle;
        var _b = require$$0$1.useState({
            display: false,
            username: ''
        }), isTyping = _b[0], setIsTyping = _b[1];
        var scrollDown = require$$0$1.useCallback(function (config) {
            if (!scrollViewRef.current)
                return;
            scrollViewRef.current.scrollIntoView(config);
        }, [scrollViewRef]);
        var _c = useInfiniteQuery({
            queryKey: ['messages', rid],
            queryFn: function (_a) {
                var pageParam = _a.pageParam;
                return rid ? rc.getMessages(rid, pageParam, MESSAGES_PER_PAGE) : undefined;
            },
            initialPageParam: 0,
            getNextPageParam: function (lastPage, allPages) {
                if (lastPage && lastPage.count < MESSAGES_PER_PAGE)
                    return undefined;
                return MESSAGES_PER_PAGE * allPages.length;
            },
            enabled: !!rid
        }), data = _c.data, fetchNextPage = _c.fetchNextPage, isFetchingNextPage = _c.isFetchingNextPage;
        var debouncedCancelIsTyping = require$$0__default["default"].useRef(lodash_debounce(function () {
            setIsTyping({
                display: false,
                username: ''
            });
        }, 5000)).current;
        var debouncedMarkAsRead = require$$0__default["default"].useRef(lodash_debounce(function (_rid) {
            rc.markAsRead(_rid);
        }, 1000));
        var onMessage = function (res) {
            var _a, _b;
            dispatch(upsertMessage(res));
            if (document.hasFocus()) {
                debouncedMarkAsRead.current(rid);
            }
            else {
                if (((user === null || user === void 0 ? void 0 : user._id) !== res.u._id)) {
                    show(((_a = res.attachments) === null || _a === void 0 ? void 0 : _a.length) ? res.u.name + ' ' + t('SENT_A_FILE') : res.u.name + ' ' + t('SENT_A_NEW_MESSAGE'));
                    useNotification(res.u.name, { body: ((_b = res.attachments) === null || _b === void 0 ? void 0 : _b.length) ? res.u.name + ' ' + t('SENT_A_FILE') : res.msg });
                }
            }
            setTimeout(function () {
                scrollDown({
                    behavior: 'smooth',
                });
            }, 50);
        };
        var handleIsTypingEvent = function (username, display) {
            setIsTyping({
                display: display,
                username: username
            });
            debouncedCancelIsTyping();
        };
        var handleDeleteMessageEvent = function (message) {
            dispatch(removeOne(message._id));
        };
        var onStream = function (event, args) {
            switch (event) {
                case EventType.TYPING:
                    handleIsTypingEvent.apply(void 0, args);
                    break;
                case EventType.DELETE_MESSAGE:
                    handleDeleteMessageEvent.apply(void 0, args);
                    break;
            }
        };
        require$$0$1.useEffect(function () {
            data === null || data === void 0 ? void 0 : data.pages.forEach(function (page) {
                if (page) {
                    dispatch(addMessages(page.messages));
                    setTimeout(function () {
                        scrollDown();
                    }, 10);
                }
            });
        }, [data]);
        require$$0$1.useEffect(function () {
            if (!rid)
                return;
            console.log('Create socket');
            rc.realtime(rid, onMessage, onStream);
            return function () {
                console.log('Close socket');
                rc.close();
            };
        }, [rid]);
        require$$0$1.useEffect(function () {
            if (windowFocused && rid) {
                rc.markAsRead(rid);
                resetTitle();
            }
        }, [windowFocused, rid]);
        return (require$$0__default["default"].createElement("div", { style: { fontSize: '16px' }, className: "h-full" },
            require$$0__default["default"].createElement(DropZone, null,
                require$$0__default["default"].createElement(NotificationButton, null),
                require$$0__default["default"].createElement(List, { ref: scrollViewRef, isLoading: isFetchingNextPage, loadMore: fetchNextPage, messages: messages }),
                require$$0__default["default"].createElement(Composer, { isTyping: isTyping }))));
    };

    var App = function (_a) {
        _a.lang;
        var rc = useRc().rc;
        var isAuthorized = useAppSelector(function (state) { return state.user; }).isAuthorized;
        var dispatch = useAppDispatch();
        require$$0$1.useEffect(function () {
            dispatch(removeAll());
            dispatch(clearRoom());
            function init() {
                return __awaiter$5(this, void 0, void 0, function () {
                    var userRes, room, _a;
                    return __generator$5(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _b.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, rc.me()];
                            case 1:
                                userRes = _b.sent();
                                if ((userRes === null || userRes === void 0 ? void 0 : userRes.status) === 'error')
                                    throw new Error();
                                dispatch(setUser(userRes));
                                dispatch(setAuthorized(true));
                                return [3 /*break*/, 3];
                            case 2:
                                _b.sent();
                                dispatch(setUser(null));
                                dispatch(setAuthorized(false));
                                return [2 /*return*/];
                            case 3:
                                _b.trys.push([3, 8, , 9]);
                                if (!rc.rid && !rc.dmUid)
                                    throw new Error('Cannot initialize chat. Room id or Dm User id is not defined');
                                if (!rc.rid) return [3 /*break*/, 5];
                                return [4 /*yield*/, rc.getRoomInfo(rc.rid)];
                            case 4:
                                _a = _b.sent();
                                return [3 /*break*/, 7];
                            case 5: return [4 /*yield*/, rc.autoDiscoverImRoom(rc.dmUid)];
                            case 6:
                                _a = _b.sent();
                                _b.label = 7;
                            case 7:
                                room = _a;
                                dispatch(setRoom(room));
                                return [3 /*break*/, 9];
                            case 8:
                                _b.sent();
                                dispatch(clearRoom());
                                return [3 /*break*/, 9];
                            case 9: return [2 /*return*/];
                        }
                    });
                });
            }
            init();
        }, [rc.rid, rc.dmUid]);
        // useEffect(() => {
        //     i18n.changeLanguage(lang);
        // }, [lang])
        return isAuthorized ? require$$0__default["default"].createElement(Body, null) : null;
    };

    var css_248z = "/*\n! tailwindcss v3.2.4 | MIT License | https://tailwindcss.com\n*//*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: #e5e7eb; /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured `sans` font-family by default.\n5. Use the user's configured `sans` font-feature-settings by default.\n*/\n\nhtml {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  -o-tab-size: 4;\n     tab-size: 4; /* 3 */\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"; /* 4 */\n  font-feature-settings: normal; /* 5 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::-moz-placeholder, textarea::-moz-placeholder {\n  opacity: 1; /* 1 */\n  color: #9ca3af; /* 2 */\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: #9ca3af; /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden] {\n  display: none;\n}\n\n*, ::before, ::after {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n}\n\n::backdrop {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n}\n.container {\n  width: 100%;\n}\n@media (min-width: 500px) {\n\n  .container {\n    max-width: 500px;\n  }\n}\n@media (min-width: 640px) {\n\n  .container {\n    max-width: 640px;\n  }\n}\n@media (min-width: 768px) {\n\n  .container {\n    max-width: 768px;\n  }\n}\n@media (min-width: 1024px) {\n\n  .container {\n    max-width: 1024px;\n  }\n}\n@media (min-width: 1280px) {\n\n  .container {\n    max-width: 1280px;\n  }\n}\n@media (min-width: 1536px) {\n\n  .container {\n    max-width: 1536px;\n  }\n}\n.\\!visible {\n  visibility: visible !important;\n}\n.invisible {\n  visibility: hidden;\n}\n.absolute {\n  position: absolute;\n}\n.relative {\n  position: relative;\n}\n.bottom-0 {\n  bottom: 0px;\n}\n.left-4 {\n  left: 1em;\n}\n.top-0 {\n  top: 0px;\n}\n.-left-8 {\n  left: -2em;\n}\n.-right-8 {\n  right: -2em;\n}\n.\\!left-auto {\n  left: auto !important;\n}\n.\\!right-0 {\n  right: 0px !important;\n}\n.left-0 {\n  left: 0px;\n}\n.right-auto {\n  right: auto;\n}\n.z-10 {\n  z-index: 10;\n}\n.m-1 {\n  margin: 0.25em;\n}\n.m-2 {\n  margin: 0.5em;\n}\n.mx-4 {\n  margin-left: 1em;\n  margin-right: 1em;\n}\n.my-auto {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n.mx-0 {\n  margin-left: 0px;\n  margin-right: 0px;\n}\n.mx-1 {\n  margin-left: 0.25em;\n  margin-right: 0.25em;\n}\n.my-2 {\n  margin-top: 0.5em;\n  margin-bottom: 0.5em;\n}\n.ml-1 {\n  margin-left: 0.25em;\n}\n.ml-2 {\n  margin-left: 0.5em;\n}\n.mr-3 {\n  margin-right: 0.75em;\n}\n.mb-0\\.5 {\n  margin-bottom: 0.125em;\n}\n.mb-0 {\n  margin-bottom: 0px;\n}\n.mr-2 {\n  margin-right: 0.5em;\n}\n.mr-5 {\n  margin-right: 1.25em;\n}\n.mr-1 {\n  margin-right: 0.25em;\n}\n.mr-1\\.5 {\n  margin-right: 0.375em;\n}\n.mb-2 {\n  margin-bottom: 0.5em;\n}\n.mr-2\\.5 {\n  margin-right: 0.625em;\n}\n.ml-3 {\n  margin-left: 0.75em;\n}\n.box-content {\n  box-sizing: content-box;\n}\n.block {\n  display: block;\n}\n.inline {\n  display: inline;\n}\n.flex {\n  display: flex;\n}\n.hidden {\n  display: none;\n}\n.h-full {\n  height: 100%;\n}\n.h-4 {\n  height: 1em;\n}\n.h-\\[18px\\] {\n  height: 18px;\n}\n.h-20 {\n  height: 5em;\n}\n.h-1 {\n  height: 0.25em;\n}\n.h-6 {\n  height: 1.5em;\n}\n.h-3 {\n  height: 0.75em;\n}\n.h-2 {\n  height: 0.5em;\n}\n.h-min {\n  height: -moz-min-content;\n  height: min-content;\n}\n.h-5 {\n  height: 1.25em;\n}\n.w-4 {\n  width: 1em;\n}\n.w-\\[18px\\] {\n  width: 18px;\n}\n.w-full {\n  width: 100%;\n}\n.w-6 {\n  width: 1.5em;\n}\n.w-3 {\n  width: 0.75em;\n}\n.w-2 {\n  width: 0.5em;\n}\n.w-5 {\n  width: 1.25em;\n}\n.w-40 {\n  width: 10em;\n}\n.min-w-\\[43px\\] {\n  min-width: 43px;\n}\n.max-w-\\[300px\\] {\n  max-width: 300px;\n}\n.max-w-\\[calc\\(100\\%_-_2\\.31rem\\)\\] {\n  max-width: calc(100% - 2.31rem);\n}\n.flex-1 {\n  flex: 1 1 0%;\n}\n.shrink {\n  flex-shrink: 1;\n}\n.basis-8 {\n  flex-basis: 2em;\n}\n.basis-full {\n  flex-basis: 100%;\n}\n.origin-top-right {\n  transform-origin: top right;\n}\n.-rotate-45 {\n  --tw-rotate: -45deg;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.scale-95 {\n  --tw-scale-x: .95;\n  --tw-scale-y: .95;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.scale-100 {\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.transform {\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n@keyframes spin {\n\n  to {\n    transform: rotate(360deg);\n  }\n}\n.animate-spin {\n  animation: spin 1s linear infinite;\n}\n.cursor-pointer {\n  cursor: pointer;\n}\n.\\!cursor-not-allowed {\n  cursor: not-allowed !important;\n}\n.flex-col {\n  flex-direction: column;\n}\n.flex-wrap {\n  flex-wrap: wrap;\n}\n.items-end {\n  align-items: flex-end;\n}\n.items-center {\n  align-items: center;\n}\n.justify-end {\n  justify-content: flex-end;\n}\n.justify-center {\n  justify-content: center;\n}\n.gap-4 {\n  gap: 1em;\n}\n.overflow-hidden {\n  overflow: hidden;\n}\n.overflow-x-hidden {\n  overflow-x: hidden;\n}\n.overflow-y-scroll {\n  overflow-y: scroll;\n}\n.break-words {\n  overflow-wrap: break-word;\n}\n.rounded-xl {\n  border-radius: 0.75rem;\n}\n.rounded-md {\n  border-radius: 0.375rem;\n}\n.rounded-full {\n  border-radius: 9999px;\n}\n.bg-white {\n  --tw-bg-opacity: 1;\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\n}\n.bg-theme-teal-1 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(19 189 157 / var(--tw-bg-opacity));\n}\n.bg-sky-200 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(186 230 253 / var(--tw-bg-opacity));\n}\n.bg-gray-200 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\n}\n.bg-red-600 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(220 38 38 / var(--tw-bg-opacity));\n}\n.\\!bg-theme-teal-0 {\n  --tw-bg-opacity: 1 !important;\n  background-color: rgb(240 249 249 / var(--tw-bg-opacity)) !important;\n}\n.\\!bg-sky-50 {\n  --tw-bg-opacity: 1 !important;\n  background-color: rgb(240 249 255 / var(--tw-bg-opacity)) !important;\n}\n.bg-gray-100 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\n}\n.bg-sky-400 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(56 189 248 / var(--tw-bg-opacity));\n}\n.bg-opacity-70 {\n  --tw-bg-opacity: 0.7;\n}\n.fill-white {\n  fill: #fff;\n}\n.object-cover {\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n.p-2\\.5 {\n  padding: 0.625em;\n}\n.p-2 {\n  padding: 0.5em;\n}\n.p-4 {\n  padding: 1em;\n}\n.px-1 {\n  padding-left: 0.25em;\n  padding-right: 0.25em;\n}\n.px-4 {\n  padding-left: 1em;\n  padding-right: 1em;\n}\n.py-1 {\n  padding-top: 0.25em;\n  padding-bottom: 0.25em;\n}\n.py-2 {\n  padding-top: 0.5em;\n  padding-bottom: 0.5em;\n}\n.pb-4 {\n  padding-bottom: 1em;\n}\n.pl-4 {\n  padding-left: 1em;\n}\n.pr-4 {\n  padding-right: 1em;\n}\n.pt-4 {\n  padding-top: 1em;\n}\n.\\!pl-3 {\n  padding-left: 0.75em !important;\n}\n.pb-2\\.5 {\n  padding-bottom: 0.625em;\n}\n.pb-2 {\n  padding-bottom: 0.5em;\n}\n.pt-2 {\n  padding-top: 0.5em;\n}\n.\\!pb-2 {\n  padding-bottom: 0.5em !important;\n}\n.text-right {\n  text-align: right;\n}\n.align-middle {\n  vertical-align: middle;\n}\n.text-sm {\n  font-size: 0.8em;\n}\n.text-\\[10px\\] {\n  font-size: 10px;\n}\n.text-xs {\n  font-size: 0.75em;\n}\n.font-normal {\n  font-weight: 400;\n}\n.font-medium {\n  font-weight: 500;\n}\n.leading-5 {\n  line-height: 1.25rem;\n}\n.leading-4 {\n  line-height: 1rem;\n}\n.text-gray-500 {\n  --tw-text-opacity: 1;\n  color: rgb(107 114 128 / var(--tw-text-opacity));\n}\n.text-theme-teal-1 {\n  --tw-text-opacity: 1;\n  color: rgb(19 189 157 / var(--tw-text-opacity));\n}\n.text-sky-500 {\n  --tw-text-opacity: 1;\n  color: rgb(14 165 233 / var(--tw-text-opacity));\n}\n.text-gray-300 {\n  --tw-text-opacity: 1;\n  color: rgb(209 213 219 / var(--tw-text-opacity));\n}\n.text-gray-400 {\n  --tw-text-opacity: 1;\n  color: rgb(156 163 175 / var(--tw-text-opacity));\n}\n.text-indigo-500 {\n  --tw-text-opacity: 1;\n  color: rgb(99 102 241 / var(--tw-text-opacity));\n}\n.text-gray-900 {\n  --tw-text-opacity: 1;\n  color: rgb(17 24 39 / var(--tw-text-opacity));\n}\n.text-red-600 {\n  --tw-text-opacity: 1;\n  color: rgb(220 38 38 / var(--tw-text-opacity));\n}\n.text-green-600 {\n  --tw-text-opacity: 1;\n  color: rgb(22 163 74 / var(--tw-text-opacity));\n}\n.\\!text-red-500 {\n  --tw-text-opacity: 1 !important;\n  color: rgb(239 68 68 / var(--tw-text-opacity)) !important;\n}\n.text-theme-teal-2 {\n  --tw-text-opacity: 1;\n  color: rgb(29 96 99 / var(--tw-text-opacity));\n}\n.text-sky-900 {\n  --tw-text-opacity: 1;\n  color: rgb(12 74 110 / var(--tw-text-opacity));\n}\n.text-gray-700 {\n  --tw-text-opacity: 1;\n  color: rgb(55 65 81 / var(--tw-text-opacity));\n}\n.\\!text-gray-400 {\n  --tw-text-opacity: 1 !important;\n  color: rgb(156 163 175 / var(--tw-text-opacity)) !important;\n}\n.text-sky-600 {\n  --tw-text-opacity: 1;\n  color: rgb(2 132 199 / var(--tw-text-opacity));\n}\n.text-gray-600 {\n  --tw-text-opacity: 1;\n  color: rgb(75 85 99 / var(--tw-text-opacity));\n}\n.text-white {\n  --tw-text-opacity: 1;\n  color: rgb(255 255 255 / var(--tw-text-opacity));\n}\n.text-sky-400 {\n  --tw-text-opacity: 1;\n  color: rgb(56 189 248 / var(--tw-text-opacity));\n}\n.text-red-500 {\n  --tw-text-opacity: 1;\n  color: rgb(239 68 68 / var(--tw-text-opacity));\n}\n.opacity-0 {\n  opacity: 0;\n}\n.opacity-100 {\n  opacity: 1;\n}\n.shadow-lg {\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.outline-none {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n.outline {\n  outline-style: solid;\n}\n.outline-1 {\n  outline-width: 1px;\n}\n.outline-gray-300 {\n  outline-color: #d1d5db;\n}\n.ring-1 {\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\n}\n.ring-black {\n  --tw-ring-opacity: 1;\n  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));\n}\n.ring-opacity-5 {\n  --tw-ring-opacity: 0.05;\n}\n.transition {\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.duration-100 {\n  transition-duration: 100ms;\n}\n.duration-75 {\n  transition-duration: 75ms;\n}\n.ease-out {\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n}\n.ease-in {\n  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);\n}\n.\\@container {\n  container-type: inline-size;\n}\n.placeholder\\:text-gray-500::-moz-placeholder {\n  --tw-text-opacity: 1;\n  color: rgb(107 114 128 / var(--tw-text-opacity));\n}\n.placeholder\\:text-gray-500::placeholder {\n  --tw-text-opacity: 1;\n  color: rgb(107 114 128 / var(--tw-text-opacity));\n}\n.before\\:content-\\[attr\\(data-message\\)\\]::before {\n  --tw-content: attr(data-message);\n  content: var(--tw-content);\n}\n.first\\:pt-4:first-child {\n  padding-top: 1em;\n}\n.hover\\:cursor-pointer:hover {\n  cursor: pointer;\n}\n.hover\\:bg-gray-100:hover {\n  --tw-bg-opacity: 1;\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\n}\n.focus\\:outline-none:focus {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n.group:hover .group-hover\\:visible {\n  visibility: visible;\n}\n.group:nth-last-child(2) .group-\\[\\:nth-last-child\\(2\\)\\]\\:bottom-\\[calc\\(100\\%_\\+_0\\.5rem\\)\\] {\n  bottom: calc(100% + 0.5rem);\n}\n@container (min-width: 42rem) {\n\n  .\\@2xl\\:right-0 {\n    right: 0px;\n  }\n\n  .\\@2xl\\:left-auto {\n    left: auto;\n  }\n\n  .\\@2xl\\:\\!left-auto {\n    left: auto !important;\n  }\n\n  .\\@2xl\\:\\!right-0 {\n    right: 0px !important;\n  }\n}\n.\\[\\&\\:not\\(\\:first-child\\)\\]\\:pt-0:not(:first-child) {\n  padding-top: 0px;\n}\n";
    styleInject(css_248z,{"insertAt":"top"});

    var MESSAGE$1 = "Message";
    var IS_TYPING$1 = "is typing";
    var DROP_TO_UPLOAD_FILE$1 = "Drop to upload file";
    var DELETE$1 = "Delete";
    var UPLOAD_FAILED$1 = "Upload failed";
    var TODAY$1 = "today";
    var TOMORROW$1 = "tomorrow";
    var YESTERDAY$1 = "yesterday";
    var SENT_A_FILE$1 = "sent a file.";
    var SENT_A_NEW_MESSAGE$1 = "wrote a new message.";
    var THANKS_YOU_FOR_ENABLING_NOTIFICATION$1 = "Thanks you for enabling notification";
    var ENABLE_PUSH_NOTIFICATIONS$1 = " Enable Push Notifications";
    var en = {
    	MESSAGE: MESSAGE$1,
    	IS_TYPING: IS_TYPING$1,
    	DROP_TO_UPLOAD_FILE: DROP_TO_UPLOAD_FILE$1,
    	DELETE: DELETE$1,
    	UPLOAD_FAILED: UPLOAD_FAILED$1,
    	TODAY: TODAY$1,
    	TOMORROW: TOMORROW$1,
    	YESTERDAY: YESTERDAY$1,
    	SENT_A_FILE: SENT_A_FILE$1,
    	SENT_A_NEW_MESSAGE: SENT_A_NEW_MESSAGE$1,
    	THANKS_YOU_FOR_ENABLING_NOTIFICATION: THANKS_YOU_FOR_ENABLING_NOTIFICATION$1,
    	ENABLE_PUSH_NOTIFICATIONS: ENABLE_PUSH_NOTIFICATIONS$1
    };

    var MESSAGE = "Nachricht";
    var IS_TYPING = "tippt";
    var DROP_TO_UPLOAD_FILE = "Ablegen, um Datei hochzuladen";
    var DELETE = "Löschen";
    var UPLOAD_FAILED = "Hochladen fehlgeschlagen";
    var TODAY = "heute";
    var TOMORROW = "morgen";
    var YESTERDAY = "gestern";
    var SENT_A_FILE = "hat eine Datei gesendet.";
    var SENT_A_NEW_MESSAGE = "hat eine neue Nachricht geschrieben.";
    var THANKS_YOU_FOR_ENABLING_NOTIFICATION = "Danke für die Aktivierung der Benachrichtigungen";
    var ENABLE_PUSH_NOTIFICATIONS = "Push-Benachrichtigungen aktivieren";
    var de = {
    	MESSAGE: MESSAGE,
    	IS_TYPING: IS_TYPING,
    	DROP_TO_UPLOAD_FILE: DROP_TO_UPLOAD_FILE,
    	DELETE: DELETE,
    	UPLOAD_FAILED: UPLOAD_FAILED,
    	TODAY: TODAY,
    	TOMORROW: TOMORROW,
    	YESTERDAY: YESTERDAY,
    	SENT_A_FILE: SENT_A_FILE,
    	SENT_A_NEW_MESSAGE: SENT_A_NEW_MESSAGE,
    	THANKS_YOU_FOR_ENABLING_NOTIFICATION: THANKS_YOU_FOR_ENABLING_NOTIFICATION,
    	ENABLE_PUSH_NOTIFICATIONS: ENABLE_PUSH_NOTIFICATIONS
    };

    var settings = {
        debug: true,
        fallbackLng: 'de',
        supportedLngs: ['de', 'en'],
        resources: {
            en: {
                translation: en,
            },
            de: {
                translation: de,
            },
        },
        interpolation: {
            escapeValue: false,
        },
    };
    instance.use(initReactI18next).init(settings);

    // This optional code is used to register a service worker.
    // register() is not called by default.
    // This lets the app load faster on subsequent visits in production, and gives
    // it offline capabilities. However, it also means that developers (and users)
    // will only see deployed updates on subsequent visits to a page, after all the
    // existing tabs open on the page have been closed, since previously cached
    // resources are updated in the background.
    // To learn more about the benefits of this model and instructions on how to
    // opt-in, read https://cra.link/PWA
    var isLocalhost = Boolean(window.location.hostname === 'localhost' ||
        // [::1] is the IPv6 localhost address.
        window.location.hostname === '[::1]' ||
        // 127.0.0.0/8 are considered localhost for IPv4.
        window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));
    function register(config) {
        if ('serviceWorker' in navigator) {
            // The URL constructor is available in all browsers that support SW.
            var publicUrl = new URL("window".PUBLIC_URL, window.location.href);
            if (publicUrl.origin !== window.location.origin) {
                // Our service worker won't work if PUBLIC_URL is on a different origin
                // from what our page is served on. This might happen if a CDN is used to
                // serve assets; see https://github.com/facebook/create-react-app/issues/2374
                return;
            }
            window.addEventListener('load', function () {
                var swUrl = "".concat("window".PUBLIC_URL, "/service-worker.js");
                if (isLocalhost) {
                    // This is running on localhost. Let's check if a service worker still exists or not.
                    checkValidServiceWorker(swUrl, config);
                }
                else {
                    // Is not localhost. Just register service worker
                    registerValidSW(swUrl, config);
                }
            });
        }
    }
    function registerValidSW(swUrl, config) {
        navigator.serviceWorker
            .register(swUrl)
            .then(function (registration) {
            registration.onupdatefound = function () {
                var installingWorker = registration.installing;
                if (installingWorker == null) {
                    return;
                }
                installingWorker.onstatechange = function () {
                    if (installingWorker.state === 'installed') {
                        if (navigator.serviceWorker.controller) {
                            if (config && config.onUpdate) {
                                config.onUpdate(registration);
                            }
                        }
                        else {
                            if (config && config.onSuccess) {
                                config.onSuccess(registration);
                            }
                        }
                    }
                };
            };
        })
            .catch(function (error) {
            console.error('Error during service worker registration:', error);
        });
    }
    function checkValidServiceWorker(swUrl, config) {
        // Check if the service worker can be found. If it can't reload the page.
        fetch(swUrl, {
            headers: { 'Service-Worker': 'script' },
        })
            .then(function (response) {
            // Ensure service worker exists, and that we really are getting a JS file.
            var contentType = response.headers.get('content-type');
            if (response.status === 404 ||
                (contentType != null && contentType.indexOf('javascript') === -1)) {
                // No service worker found. Probably a different app. Reload the page.
                navigator.serviceWorker.ready.then(function (registration) {
                    registration.unregister().then(function () {
                        window.location.reload();
                    });
                });
            }
            else {
                // Service worker found. Proceed as normal.
                registerValidSW(swUrl, config);
            }
        })
            .catch(function () {
            console.log('No internet connection found. App is running in offline mode.');
        });
    }

    var queryClient = new QueryClient({
        defaultOptions: {
            queries: {
                retry: 1,
                refetchOnWindowFocus: false
            },
        },
    });
    var Chat = function (_a) {
        var config = _a.config, theme = _a.theme, lng = _a.lng;
        console.log('new RCService', config);
        var rc = new RcService(config);
        //i18n.changeLanguage(config.lng);
        return (React.createElement(Provider, { store: store },
            React.createElement(QueryClientProvider, { client: queryClient },
                React.createElement(Rc, { instance: rc },
                    React.createElement(ThemeProvider, { theme: theme },
                        React.createElement(App, { lang: lng }))))));
    };
    // If you want your app to work offline and load faster, you can change
    // unregister() to register() below. Note this comes with some pitfalls.
    // Learn more about service workers: https://cra.link/PWA
    register();

    return Chat;

}));
//# sourceMappingURL=ja_chat.min.js.map
